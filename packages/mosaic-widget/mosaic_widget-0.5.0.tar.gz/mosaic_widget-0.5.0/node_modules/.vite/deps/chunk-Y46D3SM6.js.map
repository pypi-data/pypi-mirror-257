{
  "version": 3,
  "sources": ["../../../../../node_modules/flatbuffers/mjs/constants.js", "../../../../../node_modules/flatbuffers/mjs/utils.js", "../../../../../node_modules/flatbuffers/mjs/encoding.js", "../../../../../node_modules/flatbuffers/mjs/byte-buffer.js", "../../../../../node_modules/flatbuffers/mjs/builder.js"],
  "sourcesContent": ["export const SIZEOF_SHORT = 2;\nexport const SIZEOF_INT = 4;\nexport const FILE_IDENTIFIER_LENGTH = 4;\nexport const SIZE_PREFIX_LENGTH = 4;\n", "export const int32 = new Int32Array(2);\nexport const float32 = new Float32Array(int32.buffer);\nexport const float64 = new Float64Array(int32.buffer);\nexport const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n", "export var Encoding;\n(function (Encoding) {\n    Encoding[Encoding[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n    Encoding[Encoding[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n", "import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants.js\";\nimport { int32, isLittleEndian, float32, float64 } from \"./utils.js\";\nimport { Encoding } from \"./encoding.js\";\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return this.readUint8(offset) << 24 >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return this.readUint16(offset) << 16 >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n    }\n    readInt32(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\n            FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = \"\";\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' +\n                FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n", "import { ByteBuffer } from \"./byte-buffer.js\";\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants.js\";\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8(this.space -= 1, value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16(this.space -= 2, value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32(this.space -= 4, value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64(this.space -= 8, value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32(this.space -= 4, value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64(this.space -= 8, value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new TypeError('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new TypeError('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xC0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT +\n                FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new TypeError('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition(this.space -= utf8.length);\n        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n            bytes[offset++] = utf8[i];\n        }\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n"],
  "mappings": "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",
  "names": ["Encoding"]
}
