# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/aggregates_from_pote.ipynb.

# %% auto 0
__all__ = [
    "tc",
    "extraction_date",
    "csv_pote_extractions_folder",
    "calib_copulas_and_quantile_folder",
    "of_vars",
    "df_dgfip",
    "metadata",
    "ref_pote_2018",
    "ref_pote_2019",
    "ref_pote_2020",
    "ref_pote_2021",
    "labels",
    "perimeter",
    "year",
    "liste_des_variables",
    "pote",
    "aggregates_from_csv",
    "agm",
    "pote_var_to_dict",
]

# %% ../notebooks/aggregates_from_pote.ipynb 5
import time
import unittest

# import numpy as np
import pandas as pd

from leximpact_aggregates.aggregate import (
    AggregateManager,
    DataStructure,
    Perimeter,
    Reference,
    get_openfisca_variables,
)

# from typing import List, Union


# from leximpact_socio_fisca_simu_etat.logger import logger
# from ruamel.yaml import YAML
# from tqdm import tqdm

tc = unittest.TestCase()


# yaml = YAML()  # typ='unsafe' for testing

extraction_date = time.strftime("%Y-%m-%d")

# %% ../notebooks/aggregates_from_pote.ipynb 6
csv_pote_extractions_folder = (
    "/mnt/data-in/casd_extract/pote/20230417-ExtractionPOTE-revenus_activite/data"
)
calib_copulas_and_quantile_folder = csv_pote_extractions_folder

# 20230417-ExtractionPOTE-revenus_activite/data (POTE 2019)
# 20230516-ExtractionPOTE_reductions_credits/data (POTE 2019)
# 20230719-POTE2021-ERFS2019
# 20230823-complement-POTE2021-ERFS2019

# %% ../notebooks/aggregates_from_pote.ipynb 11
of_vars = get_openfisca_variables()

# %% ../notebooks/aggregates_from_pote.ipynb 14
df_dgfip = pd.read_excel("Colonnes_POTE_2019.xlsx", skiprows=1)
df_dgfip["Variable"] = df_dgfip["Variable"].str.lower()
df_dgfip["Libellé"] = df_dgfip["Libellé"].str.lower()
df_dgfip.query("Variable == 'revkire'")

# %% ../notebooks/aggregates_from_pote.ipynb 16
metadata = {}


def pote_var_to_dict(row):
    """On contruit un dictionnaire `metadata` à partir du fichier de
    description de POTE Si la variable existe dans le dictionnaire d'OpenFisca
    (OF), on utilise le libelllé OF."""
    pote_var = row["Variable"].lower()
    if of_vars.get(pote_var):
        # The name from pote exist in OpenFisca
        metadata[pote_var] = {
            "openfisca_variable": pote_var,
            "ux_name": of_vars[pote_var]["label"],
            "description": of_vars[pote_var]["label"],
        }
    elif of_vars.get("f" + pote_var[1:]):
        # The name exist in OFF with a f instead of a z as first letter
        metadata[pote_var] = {
            "openfisca_variable": "f" + pote_var[1:],
        }
        if of_vars["f" + pote_var[1:]].get("label"):
            metadata[pote_var]["ux_name"] = of_vars["f" + pote_var[1:]]["label"]
            metadata[pote_var]["description"] = of_vars["f" + pote_var[1:]]["label"]
    else:
        # The name from pote don't exist in OpenFisca
        metadata[pote_var] = {
            "ux_name": row["Libellé"],
            "description": row["Libellé"],
        }
    return row


_ = df_dgfip.apply(pote_var_to_dict, axis=1)

# %% ../notebooks/aggregates_from_pote.ipynb 22
ref_pote_2018 = Reference(
    title="POTE 2018 (DGFIP)",
    href="https://www.casd.eu/source/declarations-dimpot-sur-le-revenu-des-foyers-fiscaux-formulaire-2042-et-annexes/",
)
ref_pote_2019 = Reference(
    title="POTE 2019 (DGFIP)",
    href="https://www.casd.eu/source/declarations-dimpot-sur-le-revenu-des-foyers-fiscaux-formulaire-2042-et-annexes/",
)
ref_pote_2020 = Reference(
    title="POTE 2020 (DGFIP)",
    href="https://www.casd.eu/source/declarations-dimpot-sur-le-revenu-des-foyers-fiscaux-formulaire-2042-et-annexes/",
)
ref_pote_2021 = Reference(
    title="POTE 2021 (DGFIP)",
    href="https://www.casd.eu/source/declarations-dimpot-sur-le-revenu-des-foyers-fiscaux-formulaire-2042-et-annexes/",
)
labels = {
    "V": "Veuf(ve)",
    "C": "Célibataire",
    "O": "Pacsé(e)s",
    "D": "Divorcé(e)/séparé(e)",
    "M": "Marié(e)s",
}
perimeter = Perimeter(entity="foyer", period="year", geographic="France entière")

# %% ../notebooks/aggregates_from_pote.ipynb 23
metadata["mat"] = {
    "description": "Situation matrimoniale du foyer fiscal",
    "openfisca_variable": "statut_marital",
    "ux_template": "Parmi les foyers français {value} sont {label}.",
    "labels": labels,
}
metadata["n"] = {
    "description": "Nombre d'enfants mariés/pacsés et d'enfants non mariés chargés de famille",
    "short_name": "nb_enfants_maries",
    "openfisca_variable": "nbN",
    "ux_template": "Parmi les foyers français {value} ont fait le choix de rattacher {label} enfants mariés ou chargés de famille.",
}
metadata["nbefi"] = {
    "description": "Nombre d'enfants à charge non mariés, qui ne sont pas en résidence alternée, de moins de 18 ans au 1er janvier de l'année de perception des revenus, ou nés durant la même année ou handicapés quel que soit leur âge",
    "openfisca_variable": "nbF",
    "short_name": "nb_enfants_a_charge",
    "ux_template": "Parmi les foyers français {value} sont {label}.",
}
metadata["revkire"] = {
    "description": "Revenu fiscal de référence",
    "openfisca_variable": "rfr",
}
metadata["revkire_par_part"] = {
    "description": "Revenu fiscal de référence, par part",
}
metadata["mcirrd"] = {
    "description": "Réductions d'impôt sur le revenu",
    "openfisca_variable": "reductions",
}
metadata["rnimjw"] = {
    "description": "Somme des crédits d'impôt pour l'impôt sur le revenu",
    "openfisca_variable": "credits_impot_avec_acomptes_ir",
}
metadata["rev_salaire"] = {
    "description": "Somme des salaires nets imposables du foyer",
    "openfisca_variable": "salaire_imposable",
}
metadata["retraites"] = {
    "description": "Somme des retraites nets imposables du foyer",
    "openfisca_variable": "retraite_imposable",
}
metadata["rnirgi"] = {
    "description": "Montant de l'impôt dû par le foyer",
    "openfisca_variable": "irpp_economique",
}
metadata["rev_salaire_erfs"] = {}
metadata["ric_erfs"] = {
    "description": "Somme des revenus industriels et commerciaux du foyer, au sens de l'erfs",
}
metadata["rnc_erfs"] = {
    "description": "Somme des revenus non commerciaux du foyer, au sens de l'erfs",
}
metadata["rag_erfs"] = {
    "description": "Somme des revenus agricoles du foyer, au sens de l'erfs",
}
metadata["revenus_individuels"] = {
    "description": "Somme de rev_salaires_erfs, retraites, chomages et indemnites, rag_erfs, ric_erfs, rnc_erfs, pensions alimentaires percues et pensions invalidité",
}
metadata["revenus_individuels_par_part"] = {
    "description": "Somme des des revenus individuels divisé par le nombre de part fiscal du foyer",
}
year = "2019"

# %% ../notebooks/aggregates_from_pote.ipynb 31
pd.set_option("display.max_colwidth", 80)
pd.options.display.float_format = "{:,.7f}".format

liste_des_variables = pd.read_csv(
    csv_pote_extractions_folder + "/agregats_POTE_revenus_rici_2019.csv"
)

pote = {
    "2021": [liste_des_variables],
    # "2020": [liste_des_variables_revenus_2020, liste_des_variables_csg_2020],
    # "2019": [liste_des_variables_csg_2019, liste_des_variables_revenus_2019],
    # "2018": [liste_des_variables_csg_2018],
}

# %% ../notebooks/aggregates_from_pote.ipynb 35
aggregates_from_csv = []
for year_tmp, dfs in pote.items():
    for df in dfs:
        if year_tmp == "2021":
            ref = ref_pote_2021
        if year_tmp == "2020":
            ref = ref_pote_2020
        if year_tmp == "2019":
            ref = ref_pote_2019
        elif year_tmp == "2018":
            ref = ref_pote_2018
        # df.columns
        df["name"] = df["name"].str.lower()
        _ = df.apply(
            AggregateManager.get_aggregats_from_row,
            args=[
                aggregates_from_csv,
                year_tmp,
                df.columns.to_list(),
                ref,
                metadata,
                perimeter,
            ],
            axis=1,
        )
aggregates_from_csv[2]

# %% ../notebooks/aggregates_from_pote.ipynb 56
agm = AggregateManager()
agm.load_aggregate(
    "POTE", "rfr", year, str(DataStructure.COPULAS_100), copules_var="rfr"
)
tc.assertEqual(agm.aggregate.openfisca_variable, "rfr")
tc.assertEqual(agm.aggregate.description, metadata["revkire"]["description"])
tc.assertEqual(
    agm.aggregate.data[-1].values[-1]["buckets"][-1]["mean_above_upper_bound"], 0
)
