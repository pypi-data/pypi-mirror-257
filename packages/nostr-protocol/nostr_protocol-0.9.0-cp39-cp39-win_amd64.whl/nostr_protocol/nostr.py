

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)

class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value
 
    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("nostr_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 25
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_nostr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_nostr_ffi_checksum_func_create_delegation_tag() != 52290:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_extract_relay_list() != 51894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_generate_shared_key() != 16959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_get_leading_zero_bits() != 56837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_get_nip05_profile() != 40366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_get_prefixes_for_difficulty() != 40322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_gift_wrap() != 43459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_decrypt() != 43832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_encrypt() != 30892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip44_decrypt() != 45478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip44_encrypt() != 44460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip57_anonymous_zap_request() != 35211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip57_decrypt_private_zap_message() != 2070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip57_private_zap_request() != 36832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip59_extract_rumor() != 60704:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_sign_delegation() != 26608:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_validate_delegation_tag() != 36583:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_verify_delegation_signature() != 25197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_verify_nip05() != 27291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_alias() != 19227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_public_key() != 34202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_relay_url() != 44747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_identifier() != 48595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_kind() != 36812:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_public_key() != 32316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_relays() != 12945:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_to_bech32() != 29387:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_coordinate_to_nostr_uri() != 54439:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_key_security() != 20932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_bech32() != 47366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_secret_key() != 22123:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_version() != 27626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_as_json() != 13177:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_author() != 31558:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_content() != 3434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_coordinates() != 58273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_created_at() != 30924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_event_ids() != 3712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_expiration() != 35230:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_id() != 63996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_identifier() != 23430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral() != 21349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_expired() != 57175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_job_request() != 26053:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_job_result() != 54684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable() != 17253:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_regular() != 8941:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_replaceable() != 57468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_kind() != 59997:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_public_keys() != 60897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_signature() != 11666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_tags() != 52723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify() != 11448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify_id() != 58200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify_signature() != 63925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_custom_created_at() != 9457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event() != 50209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event() != 41869:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event() != 47176:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event() != 37944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes() != 42102:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32() != 64584:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_hex() != 61729:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri() != 46695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm() != 55682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash() != 35842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions() != 9884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet() != 41489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_size() != 57454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_as_json() != 460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_author() != 4917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_authors() != 53178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_custom_tag() != 18730:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_event() != 59794:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_events() != 38326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_hashtag() != 50093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_hashtags() != 62694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_id() != 45833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_identifier() != 20298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_identifiers() != 54889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_ids() != 55244:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_is_empty() != 26481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kind() != 52242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kinds() != 3094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_limit() != 4466:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkey() != 31814:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkeys() != 34042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_reference() != 56897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_references() != 4549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_authors() != 33646:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag() != 19654:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_events() != 49125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags() != 35531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers() != 49347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_ids() != 5421:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds() != 61773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_limit() != 20675:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys() != 34681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_references() != 5487:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_search() != 63633:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_since() != 1723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_until() != 9495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_search() != 14640:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_since() != 26072:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_until() != 9880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_height() != 33735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_width() != 1901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_public_key() != 11578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_secret_key() != 9033:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr() != 7507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_as_json() != 65508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_about() != 6408:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_banner() != 8981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field() != 61645:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name() != 17403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06() != 2507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16() != 58234:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_name() != 23420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05() != 23082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_picture() != 40475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_website() != 33949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_about() != 3274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_banner() != 37978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field() != 37744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name() != 42475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06() != 43495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16() != 48202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_name() != 28889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05() != 56573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_picture() != 61689:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_website() != 48106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19_as_enum() != 16291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19event_author() != 43489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19event_event_id() != 39306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19event_relays() != 18458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19event_to_bech32() != 62414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19event_to_nostr_uri() != 17113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key() != 18567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_relays() != 40076:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32() != 6768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri() != 7355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip21_as_enum() != 62859:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip21_to_nostr_uri() != 50917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_as_json() != 44995:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_description() != 52113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_icons() != 11019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_url() != 56866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description() != 40293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name() != 44591:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key() != 5374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url() != 32058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url() != 42493:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version() != 11110:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_lud16() != 46259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_public_key() != 58306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_relay_url() != 45352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_secret() != 60204:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32() != 6908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_hex() != 28417:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri() != 23126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact() != 46735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description() != 23135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_fees() != 55926:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_icon() != 32188:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_language_tags() != 31609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_limitation() != 40270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name() != 18381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_payments_url() != 40933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_posting_policy() != 8196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey() != 58101:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_relay_countries() != 36520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_retention() != 49899:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software() != 10815:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips() != 15217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_tags() != 12950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version() != 8680:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_request_method() != 18547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_request_params() != 61907:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_encrypt() != 56190:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32() != 37711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex() != 26766:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost() != 1960:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_name() != 4425:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions() != 45072:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_lowercase() != 14686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_uppercase() != 50218:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_enum() != 27944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_vec() != 44400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_kind() != 45790:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs() != 12186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime() != 33432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature() != 50095:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json() != 632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_author() != 762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_content() != 59369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at() != 14364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_id() != 54089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind() != 49180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign() != 25171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags() != 37002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount() != 46823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id() != 47057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl() != 51318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_message() != 17128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_contact_new() != 39020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_bech32() != 2839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_nostr_uri() != 7990:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_coordinate_new() != 37354:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_coordinate_parse() != 19068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_from_bech32() != 40229:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_new() != 56686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_event_from_json() != 7211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth() != 21486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge() != 56466:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel() != 5175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_metadata() != 23769:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_msg() != 27666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_contact_list() != 63371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge() != 60447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete() != 16936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_encrypted_direct_msg() != 902:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata() != 58037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 6412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth() != 18302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback() != 56220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request() != 58728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result() != 28672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event() != 55426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg() != 37436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 61682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_metadata() != 26937:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 6:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new() != 13099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect() != 56662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_product_data() != 11658:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges() != 32949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_zap_request() != 20783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_reaction() != 44985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list() != 9523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report() != 38094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost() != 22762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_sealed_direct() != 34241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_stall_data() != 765:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_text_note() != 14067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_zap_receipt() != 60996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32() != 30950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes() != 63467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex() != 28688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri() != 38461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_new() != 33385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_parse() != 30827:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new() != 49746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_from_json() != 29556:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_new() != 52942:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new() != 12930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic() != 57901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key() != 25705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_generate() != 38677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_new() != 14520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_parse() != 48405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_vanity() != 19009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json() != 2104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_new() != 46492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19_from_bech32() != 34793:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_bech32() != 43281:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_nostr_uri() != 3227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19event_new() != 5357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32() != 32898:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 51607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new() != 57515:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip21_parse() != 49103:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrconnectmetadata_new() != 24321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string() != 27884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new() != 29464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_new() != 30349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_parse() != 6145:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32() != 691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes() != 39862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex() != 36005:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri() != 29733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_parse() != 47514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get() != 3532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_new() != 54594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_request_new() != 25537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_request_parse() != 47621:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32() != 63087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes() != 49241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex() != 3323:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_parse() != 59226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new() != 29131:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_lowercase() != 27584:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_uppercase() != 53032:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_event() != 31838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum() != 27753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_parse() != 24378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_public_key() != 19528:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs() != 62064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_now() != 25457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_tweaked() != 29177:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json() != 62944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new() != 33304:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_nostr_ffi_fn_clone_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_contact.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_coordinate.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_encryptedsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_encryptedsecretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_encryptedsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_encryptedsecretkey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_key_security.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_key_security.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_secret_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_secret_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_event.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_contact_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_contact_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_encrypted_direct_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_encrypted_direct_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_product_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_product_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_public_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_public_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_reaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_reaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_sealed_direct.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_sealed_direct.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_stall_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_stall_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_zap_receipt.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_zap_receipt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_custom_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_custom_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_filter.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_clone_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19event.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_author.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip21.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip21.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nip21.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nip21.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip21_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip21_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnectmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnectmetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnectmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnectmetadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnectmetadata_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnectmetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_description.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_description.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_icons.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_icons.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_url.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_url.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrwalletconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrwalletconnecturi.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrwalletconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrwalletconnecturi.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_lud16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_lud16.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_secret.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_icon.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_icon.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_language_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_language_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_limitation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_limitation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_payments_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_payments_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_posting_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_posting_policy.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_relay_countries.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_relay_countries.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_retention.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_retention.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_request.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_request_method.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_request_method.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_request_params.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_request_params.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_response.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_response.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_response.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_response.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_double,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_singlelettertag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_singlelettertag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_singlelettertag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_singlelettertag.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_lowercase.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_lowercase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_uppercase.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_uppercase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_lowercase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_lowercase.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_uppercase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_uppercase.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_clone_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_tweaked.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_tweaked.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_create_delegation_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_create_delegation_tag.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_extract_relay_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_extract_relay_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_get_leading_zero_bits.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_get_leading_zero_bits.restype = ctypes.c_uint8
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_get_prefixes_for_difficulty.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_get_prefixes_for_difficulty.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_gift_wrap.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_gift_wrap.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_anonymous_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_anonymous_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_decrypt_private_zap_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_decrypt_private_zap_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_private_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_private_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_nip59_extract_rumor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip59_extract_rumor.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_sign_delegation.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_sign_delegation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_validate_delegation_tag.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_validate_delegation_tag.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_delegation_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_delegation_signature.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_nostr_ffi_checksum_func_create_delegation_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_create_delegation_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_extract_relay_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_extract_relay_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_leading_zero_bits.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_leading_zero_bits.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_prefixes_for_difficulty.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_prefixes_for_difficulty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_gift_wrap.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_gift_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_anonymous_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_anonymous_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_decrypt_private_zap_message.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_decrypt_private_zap_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_private_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip57_private_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip59_extract_rumor.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip59_extract_rumor.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_sign_delegation.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_sign_delegation.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_validate_delegation_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_validate_delegation_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_delegation_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_delegation_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_coordinate_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_key_security.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_key_security.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_secret_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_secret_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_encryptedsecretkey_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_coordinates.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_coordinates.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_event_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_event_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_expiration.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_expired.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_regular.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_regular.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_replaceable.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_replaceable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_public_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_public_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_custom_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_custom_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_is_empty.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_reference.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_references.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_events.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_references.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_search.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_since.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_until.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19event_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip21_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip21_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip21_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip21_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_icons.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_icons.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_secret.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_fees.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_icon.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_icon.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_language_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_language_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_limitation.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_limitation.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_payments_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_payments_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_posting_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_posting_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_relay_countries.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_relay_countries.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_retention.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_retention.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_request_method.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_request_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_request_params.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_request_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_lowercase.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_lowercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_uppercase.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_singlelettertag_is_uppercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_message.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_coordinate_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_contact_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_contact_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_encrypted_direct_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_encrypted_direct_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_product_data.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_product_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_reaction.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_sealed_direct.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_sealed_direct.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_stall_data.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_stall_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_zap_receipt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_zap_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19event_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip21_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip21_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnectmetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnectmetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_request_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_request_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_request_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_request_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_lowercase.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_lowercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_uppercase.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_singlelettertag_uppercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_tweaked.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_tweaked.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class ContactProtocol(typing.Protocol):
    def alias(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relay_url(self, ):
        raise NotImplementedError

class Contact:

    _pointer: ctypes.c_void_p
    def __init__(self, pk: "PublicKey",relay_url: "typing.Optional[str]",alias: "typing.Optional[str]"):
        _UniffiConverterTypePublicKey.check_lower(pk)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterOptionalString.check_lower(alias)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new,
        _UniffiConverterTypePublicKey.lower(pk),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterOptionalString.lower(alias))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_contact, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_contact, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def alias(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key,self._uniffi_clone_pointer(),)
        )






    def relay_url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeContact:

    @staticmethod
    def lift(value: int):
        return Contact._make_instance_(value)

    @staticmethod
    def check_lower(value: Contact):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ContactProtocol):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ContactProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class CoordinateProtocol(typing.Protocol):
    """Coordinate for event (`a` tag)"""

    def identifier(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class Coordinate:
    """Coordinate for event (`a` tag)"""


    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int",public_key: "PublicKey"):
        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_new,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterTypePublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_coordinate, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_coordinate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, coordinate: "str"):
        _UniffiConverterString.check_lower(coordinate)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_coordinate_parse,
        _UniffiConverterString.lower(coordinate))
        return cls._make_instance_(pointer)



    def identifier(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_identifier,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_kind,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_public_key,self._uniffi_clone_pointer(),)
        )






    def relays(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_relays,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_coordinate_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeCoordinate:

    @staticmethod
    def lift(value: int):
        return Coordinate._make_instance_(value)

    @staticmethod
    def check_lower(value: Coordinate):
        if not isinstance(value, Coordinate):
            raise TypeError("Expected Coordinate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CoordinateProtocol):
        if not isinstance(value, Coordinate):
            raise TypeError("Expected Coordinate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CoordinateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EncryptedSecretKeyProtocol(typing.Protocol):
    """Encrypted Secret Key"""

    def key_security(self, ):
        """Get encrypted secret key security"""

        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_secret_key(self, password: "str"):
        """Decrypt secret key"""

        raise NotImplementedError
    def version(self, ):
        """Get encrypted secret key version"""

        raise NotImplementedError

class EncryptedSecretKey:
    """Encrypted Secret Key"""


    _pointer: ctypes.c_void_p
    def __init__(self, secret_key: "SecretKey",password: "str",log_n: "int",key_security: "KeySecurity"):
        """Encrypt secret key"""

        _UniffiConverterTypeSecretKey.check_lower(secret_key)
        
        _UniffiConverterString.check_lower(password)
        
        _UniffiConverterUInt8.check_lower(log_n)
        
        _UniffiConverterTypeKeySecurity.check_lower(key_security)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_new,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterString.lower(password),
        _UniffiConverterUInt8.lower(log_n),
        _UniffiConverterTypeKeySecurity.lower(key_security))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_encryptedsecretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_encryptedsecretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, encrypted_secret_key: "str"):
        _UniffiConverterString.check_lower(encrypted_secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_from_bech32,
        _UniffiConverterString.lower(encrypted_secret_key))
        return cls._make_instance_(pointer)



    def key_security(self, ) -> "KeySecurity":
        """Get encrypted secret key security"""

        return _UniffiConverterTypeKeySecurity.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_key_security,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_secret_key(self, password: "str") -> "SecretKey":
        """Decrypt secret key"""

        _UniffiConverterString.check_lower(password)
        
        return _UniffiConverterTypeSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_secret_key,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(password))
        )






    def version(self, ) -> "EncryptedSecretKeyVersion":
        """Get encrypted secret key version"""

        return _UniffiConverterTypeEncryptedSecretKeyVersion.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_encryptedsecretkey_version,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeEncryptedSecretKey:

    @staticmethod
    def lift(value: int):
        return EncryptedSecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: EncryptedSecretKey):
        if not isinstance(value, EncryptedSecretKey):
            raise TypeError("Expected EncryptedSecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EncryptedSecretKeyProtocol):
        if not isinstance(value, EncryptedSecretKey):
            raise TypeError("Expected EncryptedSecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EncryptedSecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def author(self, ):
        """Get event author (`pubkey` field)"""

        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def coordinates(self, ):
        """Extract coordinates from tags (`a` tag)"""

        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def event_ids(self, ):
        """Extract event IDs from tags (`e` tag)"""

        raise NotImplementedError
    def expiration(self, ):
        """Get `Timestamp` expiration if set"""

        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def identifier(self, ):
        """Extract identifier (`d` tag), if exists."""

        raise NotImplementedError
    def is_ephemeral(self, ):
        """
        Check if event `Kind` is `Ephemeral`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_expired(self, ):
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no `Expiration` tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        raise NotImplementedError
    def is_job_request(self, ):
        """
        Check if `Kind` is a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_job_result(self, ):
        """
        Check if `Kind` is a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_parameterized_replaceable(self, ):
        """
        Check if event `Kind` is `Parameterized replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_regular(self, ):
        """
        Check if event `Kind` is `Regular`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_replaceable(self, ):
        """
        Check if event `Kind` is `Replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def public_keys(self, ):
        """Extract public keys from tags (`p` tag)"""

        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
    def verify(self, ):
        """Verify both `EventId` and `Signature`"""

        raise NotImplementedError
    def verify_id(self, ):
        """Verify if the `EventId` it's composed correctly"""

        raise NotImplementedError
    def verify_signature(self, ):
        """Verify only event `Signature`"""

        raise NotImplementedError

class Event:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_event, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_event, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json,self._uniffi_clone_pointer(),)
        )






    def author(self, ) -> "PublicKey":
        """Get event author (`pubkey` field)"""

        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_author,self._uniffi_clone_pointer(),)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_content,self._uniffi_clone_pointer(),)
        )






    def coordinates(self, ) -> "typing.List[Coordinate]":
        """Extract coordinates from tags (`a` tag)"""

        return _UniffiConverterSequenceTypeCoordinate.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates,self._uniffi_clone_pointer(),)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at,self._uniffi_clone_pointer(),)
        )






    def event_ids(self, ) -> "typing.List[EventId]":
        """Extract event IDs from tags (`e` tag)"""

        return _UniffiConverterSequenceTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids,self._uniffi_clone_pointer(),)
        )






    def expiration(self, ) -> "typing.Optional[Timestamp]":
        """Get `Timestamp` expiration if set"""

        return _UniffiConverterOptionalTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration,self._uniffi_clone_pointer(),)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_id,self._uniffi_clone_pointer(),)
        )






    def identifier(self, ) -> "typing.Optional[str]":
        """Extract identifier (`d` tag), if exists."""

        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier,self._uniffi_clone_pointer(),)
        )






    def is_ephemeral(self, ) -> "bool":
        """
        Check if event `Kind` is `Ephemeral`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral,self._uniffi_clone_pointer(),)
        )






    def is_expired(self, ) -> "bool":
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no `Expiration` tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired,self._uniffi_clone_pointer(),)
        )






    def is_job_request(self, ) -> "bool":
        """
        Check if `Kind` is a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request,self._uniffi_clone_pointer(),)
        )






    def is_job_result(self, ) -> "bool":
        """
        Check if `Kind` is a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result,self._uniffi_clone_pointer(),)
        )






    def is_parameterized_replaceable(self, ) -> "bool":
        """
        Check if event `Kind` is `Parameterized replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable,self._uniffi_clone_pointer(),)
        )






    def is_regular(self, ) -> "bool":
        """
        Check if event `Kind` is `Regular`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular,self._uniffi_clone_pointer(),)
        )






    def is_replaceable(self, ) -> "bool":
        """
        Check if event `Kind` is `Replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind,self._uniffi_clone_pointer(),)
        )






    def public_keys(self, ) -> "typing.List[PublicKey]":
        """Extract public keys from tags (`p` tag)"""

        return _UniffiConverterSequenceTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys,self._uniffi_clone_pointer(),)
        )






    def signature(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature,self._uniffi_clone_pointer(),)
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags,self._uniffi_clone_pointer(),)
        )






    def verify(self, ) -> "bool":
        """Verify both `EventId` and `Signature`"""

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify,self._uniffi_clone_pointer(),)
        )






    def verify_id(self, ):
        """Verify if the `EventId` it's composed correctly"""

        _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id,self._uniffi_clone_pointer(),)







    def verify_signature(self, ):
        """Verify only event `Signature`"""

        _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature,self._uniffi_clone_pointer(),)






class _UniffiConverterTypeEvent:

    @staticmethod
    def lift(value: int):
        return Event._make_instance_(value)

    @staticmethod
    def check_lower(value: Event):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventProtocol):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventBuilderProtocol(typing.Protocol):
    def custom_created_at(self, created_at: "Timestamp"):
        """Set a custom `created_at` UNIX timestamp"""

        raise NotImplementedError
    def to_event(self, keys: "Keys"):
        raise NotImplementedError
    def to_pow_event(self, keys: "Keys",difficulty: "int"):
        raise NotImplementedError
    def to_unsigned_event(self, public_key: "PublicKey"):
        raise NotImplementedError
    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int"):
        raise NotImplementedError

class EventBuilder:

    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int",content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def auth(cls, challenge: "str",relay_url: "str"):
        _UniffiConverterString.check_lower(challenge)
        
        _UniffiConverterString.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth,
        _UniffiConverterString.lower(challenge),
        _UniffiConverterString.lower(relay_url))
        return cls._make_instance_(pointer)


    @classmethod
    def award_badge(cls, badge_definition: "Event",awarded_pubkeys: "typing.List[Tag]"):
        _UniffiConverterTypeEvent.check_lower(badge_definition)
        
        _UniffiConverterSequenceTypeTag.check_lower(awarded_pubkeys)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge,
        _UniffiConverterTypeEvent.lower(badge_definition),
        _UniffiConverterSequenceTypeTag.lower(awarded_pubkeys))
        return cls._make_instance_(pointer)


    @classmethod
    def channel(cls, metadata: "Metadata"):
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def channel_metadata(cls, channel_id: "EventId",relay_url: "typing.Optional[str]",metadata: "Metadata"):
        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_metadata,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def channel_msg(cls, channel_id: "EventId",relay_url: "str",content: "str"):
        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterString.check_lower(relay_url)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_msg,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterString.lower(relay_url),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def contact_list(cls, list: "typing.List[Contact]"):
        _UniffiConverterSequenceTypeContact.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_contact_list,
        _UniffiConverterSequenceTypeContact.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def define_badge(cls, badge_id: "str",name: "typing.Optional[str]",description: "typing.Optional[str]",image: "typing.Optional[str]",image_dimensions: "typing.Optional[ImageDimensions]",thumbnails: "typing.List[Image]"):
        _UniffiConverterString.check_lower(badge_id)
        
        _UniffiConverterOptionalString.check_lower(name)
        
        _UniffiConverterOptionalString.check_lower(description)
        
        _UniffiConverterOptionalString.check_lower(image)
        
        _UniffiConverterOptionalTypeImageDimensions.check_lower(image_dimensions)
        
        _UniffiConverterSequenceTypeImage.check_lower(thumbnails)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge,
        _UniffiConverterString.lower(badge_id),
        _UniffiConverterOptionalString.lower(name),
        _UniffiConverterOptionalString.lower(description),
        _UniffiConverterOptionalString.lower(image),
        _UniffiConverterOptionalTypeImageDimensions.lower(image_dimensions),
        _UniffiConverterSequenceTypeImage.lower(thumbnails))
        return cls._make_instance_(pointer)


    @classmethod
    def delete(cls, ids: "typing.List[EventId]",reason: "typing.Optional[str]"):
        """Create delete event"""

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete,
        _UniffiConverterSequenceTypeEventId.lower(ids),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def encrypted_direct_msg(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",content: "str",reply_to: "typing.Optional[EventId]"):
        """Create encrypted direct msg event"""

        _UniffiConverterTypeKeys.check_lower(sender_keys)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterOptionalTypeEventId.check_lower(reply_to)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_encrypted_direct_msg,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalTypeEventId.lower(reply_to))
        return cls._make_instance_(pointer)


    @classmethod
    def file_metadata(cls, description: "str",metadata: "FileMetadata"):
        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterTypeFileMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata,
        _UniffiConverterString.lower(description),
        _UniffiConverterTypeFileMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def hide_channel_msg(cls, message_id: "EventId",reason: "typing.Optional[str]"):
        _UniffiConverterTypeEventId.check_lower(message_id)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg,
        _UniffiConverterTypeEventId.lower(message_id),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def http_auth(cls, data: "HttpData"):
        _UniffiConverterTypeHttpData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth,
        _UniffiConverterTypeHttpData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def job_feedback(cls, job_request: "Event",status: "DataVendingMachineStatus",extra_info: "typing.Optional[str]",amount_millisats: "int",bolt11: "typing.Optional[str]",payload: "typing.Optional[str]"):
        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterTypeDataVendingMachineStatus.check_lower(status)
        
        _UniffiConverterOptionalString.check_lower(extra_info)
        
        _UniffiConverterUInt64.check_lower(amount_millisats)
        
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        _UniffiConverterOptionalString.check_lower(payload)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterTypeDataVendingMachineStatus.lower(status),
        _UniffiConverterOptionalString.lower(extra_info),
        _UniffiConverterUInt64.lower(amount_millisats),
        _UniffiConverterOptionalString.lower(bolt11),
        _UniffiConverterOptionalString.lower(payload))
        return cls._make_instance_(pointer)


    @classmethod
    def job_request(cls, kind: "int",tags: "typing.List[Tag]"):
        """
        Data Vending Machine - Job Request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def job_result(cls, job_request: "Event",amount_millisats: "int",bolt11: "typing.Optional[str]"):
        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterUInt64.check_lower(amount_millisats)
        
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterUInt64.lower(amount_millisats),
        _UniffiConverterOptionalString.lower(bolt11))
        return cls._make_instance_(pointer)


    @classmethod
    def live_event(cls, live_event: "LiveEvent"):
        _UniffiConverterTypeLiveEvent.check_lower(live_event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event,
        _UniffiConverterTypeLiveEvent.lower(live_event))
        return cls._make_instance_(pointer)


    @classmethod
    def live_event_msg(cls, live_event_id: "str",live_event_host: "PublicKey",content: "str",relay_url: "typing.Optional[str]",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(live_event_id)
        
        _UniffiConverterTypePublicKey.check_lower(live_event_host)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg,
        _UniffiConverterString.lower(live_event_id),
        _UniffiConverterTypePublicKey.lower(live_event_host),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def long_form_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def metadata(cls, metadata: "Metadata"):
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_metadata,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def mute_channel_user(cls, public_key: "PublicKey",reason: "typing.Optional[str]"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def nostr_connect(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",msg: "NostrConnectMessage"):
        _UniffiConverterTypeKeys.check_lower(sender_keys)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
        
        _UniffiConverterTypeNostrConnectMessage.check_lower(msg)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterTypeNostrConnectMessage.lower(msg))
        return cls._make_instance_(pointer)


    @classmethod
    def product_data(cls, data: "ProductData"):
        _UniffiConverterTypeProductData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_product_data,
        _UniffiConverterTypeProductData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def profile_badges(cls, badge_definitions: "typing.List[Event]",badge_awards: "typing.List[Event]",pubkey_awarded: "PublicKey"):
        _UniffiConverterSequenceTypeEvent.check_lower(badge_definitions)
        
        _UniffiConverterSequenceTypeEvent.check_lower(badge_awards)
        
        _UniffiConverterTypePublicKey.check_lower(pubkey_awarded)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges,
        _UniffiConverterSequenceTypeEvent.lower(badge_definitions),
        _UniffiConverterSequenceTypeEvent.lower(badge_awards),
        _UniffiConverterTypePublicKey.lower(pubkey_awarded))
        return cls._make_instance_(pointer)


    @classmethod
    def public_zap_request(cls, data: "ZapRequestData"):
        """
        Create **public** zap request event

        **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.

        To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.

        <https://github.com/nostr-protocol/nips/blob/master/57.md>
        """

        _UniffiConverterTypeZapRequestData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_public_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def reaction(cls, event_id: "EventId",public_key: "PublicKey",content: "str"):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_reaction,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def relay_list(cls, list: "dict"):
        _UniffiConverterMapStringOptionalTypeRelayMetadata.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list,
        _UniffiConverterMapStringOptionalTypeRelayMetadata.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def report(cls, tags: "typing.List[Tag]",content: "str"):
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report,
        _UniffiConverterSequenceTypeTag.lower(tags),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def repost(cls, event_id: "EventId",public_key: "PublicKey"):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)


    @classmethod
    def sealed_direct(cls, receiver: "PublicKey",message: "str"):
        """GiftWrapped Sealed Direct message"""

        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterString.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_sealed_direct,
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterString.lower(message))
        return cls._make_instance_(pointer)


    @classmethod
    def stall_data(cls, data: "StallData"):
        _UniffiConverterTypeStallData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_stall_data,
        _UniffiConverterTypeStallData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def text_note(cls, content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def zap_receipt(cls, bolt11: "str",preimage: "typing.Optional[str]",zap_request: "Event"):
        _UniffiConverterString.check_lower(bolt11)
        
        _UniffiConverterOptionalString.check_lower(preimage)
        
        _UniffiConverterTypeEvent.check_lower(zap_request)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_zap_receipt,
        _UniffiConverterString.lower(bolt11),
        _UniffiConverterOptionalString.lower(preimage),
        _UniffiConverterTypeEvent.lower(zap_request))
        return cls._make_instance_(pointer)



    def custom_created_at(self, created_at: "Timestamp") -> "EventBuilder":
        """Set a custom `created_at` UNIX timestamp"""

        _UniffiConverterTypeTimestamp.check_lower(created_at)
        
        return _UniffiConverterTypeEventBuilder.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_custom_created_at,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(created_at))
        )






    def to_event(self, keys: "Keys") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )






    def to_pow_event(self, keys: "Keys",difficulty: "int") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys),
        _UniffiConverterUInt8.lower(difficulty))
        )






    def to_unsigned_event(self, public_key: "PublicKey") -> "UnsignedEvent":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(public_key))
        )






    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int") -> "UnsignedEvent":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(difficulty))
        )





class _UniffiConverterTypeEventBuilder:

    @staticmethod
    def lift(value: int):
        return EventBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: EventBuilder):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventBuilderProtocol):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventIdProtocol(typing.Protocol):
    def as_bytes(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class EventId:

    _pointer: ctypes.c_void_p
    def __init__(self, pubkey: "PublicKey",created_at: "Timestamp",kind: "int",tags: "typing.List[typing.List[str]]",content: "str"):
        _UniffiConverterTypePublicKey.check_lower(pubkey)
        
        _UniffiConverterTypeTimestamp.check_lower(created_at)
        
        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterSequenceSequenceString.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new,
        _UniffiConverterTypePublicKey.lower(pubkey),
        _UniffiConverterTypeTimestamp.lower(created_at),
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterSequenceSequenceString.lower(tags),
        _UniffiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventid, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, id: "str"):
        _UniffiConverterString.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32,
        _UniffiConverterString.lower(id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, id: "str"):
        """Try to parse event ID from `hex` or `bech32`"""

        _UniffiConverterString.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_parse,
        _UniffiConverterString.lower(id))
        return cls._make_instance_(pointer)



    def as_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeEventId:

    @staticmethod
    def lift(value: int):
        return EventId._make_instance_(value)

    @staticmethod
    def check_lower(value: EventId):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventIdProtocol):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventIdProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FileMetadataProtocol(typing.Protocol):
    def aes_256_gcm(self, key: "str",iv: "str"):
        raise NotImplementedError
    def blurhash(self, blurhash: "str"):
        """Add blurhash"""

        raise NotImplementedError
    def dimensions(self, dim: "ImageDimensions"):
        """Add file size (pixels)"""

        raise NotImplementedError
    def magnet(self, magnet: "str"):
        """Add magnet"""

        raise NotImplementedError
    def size(self, size: "int"):
        """Add file size (bytes)"""

        raise NotImplementedError

class FileMetadata:

    _pointer: ctypes.c_void_p
    def __init__(self, url: "str",mime_type: "str",hash: "str"):
        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterString.check_lower(mime_type)
        
        _UniffiConverterString.check_lower(hash)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new,
        _UniffiConverterString.lower(url),
        _UniffiConverterString.lower(mime_type),
        _UniffiConverterString.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def aes_256_gcm(self, key: "str",iv: "str") -> "FileMetadata":
        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterString.check_lower(iv)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(iv))
        )






    def blurhash(self, blurhash: "str") -> "FileMetadata":
        """Add blurhash"""

        _UniffiConverterString.check_lower(blurhash)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(blurhash))
        )






    def dimensions(self, dim: "ImageDimensions") -> "FileMetadata":
        """Add file size (pixels)"""

        _UniffiConverterTypeImageDimensions.check_lower(dim)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions,self._uniffi_clone_pointer(),
        _UniffiConverterTypeImageDimensions.lower(dim))
        )






    def magnet(self, magnet: "str") -> "FileMetadata":
        """Add magnet"""

        _UniffiConverterString.check_lower(magnet)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(magnet))
        )






    def size(self, size: "int") -> "FileMetadata":
        """Add file size (bytes)"""

        _UniffiConverterUInt64.check_lower(size)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(size))
        )





class _UniffiConverterTypeFileMetadata:

    @staticmethod
    def lift(value: int):
        return FileMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: FileMetadata):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FileMetadataProtocol):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FileMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FilterProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def author(self, author: "PublicKey"):
        """Add event author Public Key"""

        raise NotImplementedError
    def authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def custom_tag(self, tag: "SingleLetterTag",content: "typing.List[str]"):
        raise NotImplementedError
    def event(self, event_id: "EventId"):
        """Add event ID (`e` tag)"""

        raise NotImplementedError
    def events(self, ids: "typing.List[EventId]"):
        """Add event IDs (`e` tag)"""

        raise NotImplementedError
    def hashtag(self, hashtag: "str"):
        raise NotImplementedError
    def hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def id(self, id: "EventId"):
        raise NotImplementedError
    def identifier(self, identifier: "str"):
        raise NotImplementedError
    def identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def is_empty(self, ):
        raise NotImplementedError
    def kind(self, kind: "int"):
        raise NotImplementedError
    def kinds(self, kinds: "typing.List[int]"):
        raise NotImplementedError
    def limit(self, limit: "int"):
        raise NotImplementedError
    def pubkey(self, pubkey: "PublicKey"):
        """Add Public Key (`p` tag)"""

        raise NotImplementedError
    def pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        """Add Public Keys (`p` tag)"""

        raise NotImplementedError
    def reference(self, reference: "str"):
        raise NotImplementedError
    def references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_custom_tag(self, tag: "SingleLetterTag",content: "typing.List[str]"):
        raise NotImplementedError
    def remove_events(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def remove_identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def remove_ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_kinds(self, kinds: "typing.List[int]"):
        raise NotImplementedError
    def remove_limit(self, ):
        raise NotImplementedError
    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_search(self, ):
        raise NotImplementedError
    def remove_since(self, ):
        raise NotImplementedError
    def remove_until(self, ):
        raise NotImplementedError
    def search(self, text: "str"):
        raise NotImplementedError
    def since(self, timestamp: "Timestamp"):
        raise NotImplementedError
    def until(self, timestamp: "Timestamp"):
        raise NotImplementedError

class Filter:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filter, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_filter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json,self._uniffi_clone_pointer(),)
        )






    def author(self, author: "PublicKey") -> "Filter":
        """Add event author Public Key"""

        _UniffiConverterTypePublicKey.check_lower(author)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(author))
        )






    def authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )






    def custom_tag(self, tag: "SingleLetterTag",content: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeSingleLetterTag.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(content)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(tag),
        _UniffiConverterSequenceString.lower(content))
        )






    def event(self, event_id: "EventId") -> "Filter":
        """Add event ID (`e` tag)"""

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def events(self, ids: "typing.List[EventId]") -> "Filter":
        """Add event IDs (`e` tag)"""

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def hashtag(self, hashtag: "str") -> "Filter":
        _UniffiConverterString.check_lower(hashtag)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(hashtag))
        )






    def hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )






    def id(self, id: "EventId") -> "Filter":
        _UniffiConverterTypeEventId.check_lower(id)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(id))
        )






    def identifier(self, identifier: "str") -> "Filter":
        _UniffiConverterString.check_lower(identifier)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(identifier))
        )






    def identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )






    def ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def is_empty(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty,self._uniffi_clone_pointer(),)
        )






    def kind(self, kind: "int") -> "Filter":
        _UniffiConverterUInt64.check_lower(kind)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(kind))
        )






    def kinds(self, kinds: "typing.List[int]") -> "Filter":
        _UniffiConverterSequenceUInt64.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt64.lower(kinds))
        )






    def limit(self, limit: "int") -> "Filter":
        _UniffiConverterUInt64.check_lower(limit)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(limit))
        )






    def pubkey(self, pubkey: "PublicKey") -> "Filter":
        """Add Public Key (`p` tag)"""

        _UniffiConverterTypePublicKey.check_lower(pubkey)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(pubkey))
        )






    def pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        """Add Public Keys (`p` tag)"""

        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def reference(self, reference: "str") -> "Filter":
        _UniffiConverterString.check_lower(reference)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(reference))
        )






    def references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )






    def remove_authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )






    def remove_custom_tag(self, tag: "SingleLetterTag",content: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeSingleLetterTag.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(content)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(tag),
        _UniffiConverterSequenceString.lower(content))
        )






    def remove_events(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def remove_hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )






    def remove_identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )






    def remove_ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def remove_kinds(self, kinds: "typing.List[int]") -> "Filter":
        _UniffiConverterSequenceUInt64.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt64.lower(kinds))
        )






    def remove_limit(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit,self._uniffi_clone_pointer(),)
        )






    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def remove_references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )






    def remove_search(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search,self._uniffi_clone_pointer(),)
        )






    def remove_since(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since,self._uniffi_clone_pointer(),)
        )






    def remove_until(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until,self._uniffi_clone_pointer(),)
        )






    def search(self, text: "str") -> "Filter":
        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )






    def since(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )






    def until(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )





class _UniffiConverterTypeFilter:

    @staticmethod
    def lift(value: int):
        return Filter._make_instance_(value)

    @staticmethod
    def check_lower(value: Filter):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FilterProtocol):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FilterProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ImageDimensionsProtocol(typing.Protocol):
    def height(self, ):
        raise NotImplementedError
    def width(self, ):
        raise NotImplementedError

class ImageDimensions:

    _pointer: ctypes.c_void_p
    def __init__(self, width: "int",height: "int"):
        _UniffiConverterUInt64.check_lower(width)
        
        _UniffiConverterUInt64.check_lower(height)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new,
        _UniffiConverterUInt64.lower(width),
        _UniffiConverterUInt64.lower(height))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def height(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height,self._uniffi_clone_pointer(),)
        )






    def width(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeImageDimensions:

    @staticmethod
    def lift(value: int):
        return ImageDimensions._make_instance_(value)

    @staticmethod
    def check_lower(value: ImageDimensions):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ImageDimensionsProtocol):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ImageDimensionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class KeysProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def secret_key(self, ):
        raise NotImplementedError
    def sign_schnorr(self, message: "bytes"):
        raise NotImplementedError

class Keys:

    _pointer: ctypes.c_void_p
    def __init__(self, sk: "SecretKey"):
        _UniffiConverterTypeSecretKey.check_lower(sk)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new,
        _UniffiConverterTypeSecretKey.lower(sk))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_keys, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_keys, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_mnemonic(cls, mnemonic: "str",passphrase: "typing.Optional[str]",account: "typing.Optional[int]"):
        """
        Derive `Keys` from BIP-39 mnemonics (ENGLISH wordlist).

        By default no passphrase is used and account is set to `0`.

        <https://github.com/nostr-protocol/nips/blob/master/06.md>
        """

        _UniffiConverterString.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(passphrase)
        
        _UniffiConverterOptionalUInt32.check_lower(account)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase),
        _UniffiConverterOptionalUInt32.lower(account))
        return cls._make_instance_(pointer)


    @classmethod
    def from_public_key(cls, pk: "PublicKey"):
        _UniffiConverterTypePublicKey.check_lower(pk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key,
        _UniffiConverterTypePublicKey.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate,)
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, secret_key: "str"):
        """Try to parse keys from **secret key** `hex` or `bech32`"""

        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_parse,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)


    @classmethod
    def vanity(cls, prefixes: "typing.List[str]",bech32: "bool",num_cores: "int"):
        _UniffiConverterSequenceString.check_lower(prefixes)
        
        _UniffiConverterBool.check_lower(bech32)
        
        _UniffiConverterUInt8.check_lower(num_cores)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity,
        _UniffiConverterSequenceString.lower(prefixes),
        _UniffiConverterBool.lower(bech32),
        _UniffiConverterUInt8.lower(num_cores))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key,self._uniffi_clone_pointer(),)
        )






    def secret_key(self, ) -> "SecretKey":
        return _UniffiConverterTypeSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key,self._uniffi_clone_pointer(),)
        )






    def sign_schnorr(self, message: "bytes") -> "str":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





class _UniffiConverterTypeKeys:

    @staticmethod
    def lift(value: int):
        return Keys._make_instance_(value)

    @staticmethod
    def check_lower(value: Keys):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: KeysProtocol):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: KeysProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MetadataProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def get_about(self, ):
        raise NotImplementedError
    def get_banner(self, ):
        raise NotImplementedError
    def get_custom_field(self, key: "str"):
        raise NotImplementedError
    def get_display_name(self, ):
        raise NotImplementedError
    def get_lud06(self, ):
        raise NotImplementedError
    def get_lud16(self, ):
        raise NotImplementedError
    def get_name(self, ):
        raise NotImplementedError
    def get_nip05(self, ):
        raise NotImplementedError
    def get_picture(self, ):
        raise NotImplementedError
    def get_website(self, ):
        raise NotImplementedError
    def set_about(self, about: "str"):
        raise NotImplementedError
    def set_banner(self, banner: "str"):
        raise NotImplementedError
    def set_custom_field(self, key: "str",value: "JsonValue"):
        raise NotImplementedError
    def set_display_name(self, display_name: "str"):
        raise NotImplementedError
    def set_lud06(self, lud06: "str"):
        raise NotImplementedError
    def set_lud16(self, lud16: "str"):
        raise NotImplementedError
    def set_name(self, name: "str"):
        raise NotImplementedError
    def set_nip05(self, nip05: "str"):
        raise NotImplementedError
    def set_picture(self, picture: "str"):
        raise NotImplementedError
    def set_website(self, website: "str"):
        raise NotImplementedError

class Metadata:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_metadata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json,self._uniffi_clone_pointer(),)
        )






    def get_about(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about,self._uniffi_clone_pointer(),)
        )






    def get_banner(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner,self._uniffi_clone_pointer(),)
        )






    def get_custom_field(self, key: "str") -> "typing.Optional[JsonValue]":
        _UniffiConverterString.check_lower(key)
        
        return _UniffiConverterOptionalTypeJsonValue.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key))
        )






    def get_display_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name,self._uniffi_clone_pointer(),)
        )






    def get_lud06(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06,self._uniffi_clone_pointer(),)
        )






    def get_lud16(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16,self._uniffi_clone_pointer(),)
        )






    def get_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name,self._uniffi_clone_pointer(),)
        )






    def get_nip05(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05,self._uniffi_clone_pointer(),)
        )






    def get_picture(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture,self._uniffi_clone_pointer(),)
        )






    def get_website(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website,self._uniffi_clone_pointer(),)
        )






    def set_about(self, about: "str") -> "Metadata":
        _UniffiConverterString.check_lower(about)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(about))
        )






    def set_banner(self, banner: "str") -> "Metadata":
        _UniffiConverterString.check_lower(banner)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(banner))
        )






    def set_custom_field(self, key: "str",value: "JsonValue") -> "Metadata":
        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterTypeJsonValue.check_lower(value)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterTypeJsonValue.lower(value))
        )






    def set_display_name(self, display_name: "str") -> "Metadata":
        _UniffiConverterString.check_lower(display_name)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(display_name))
        )






    def set_lud06(self, lud06: "str") -> "Metadata":
        _UniffiConverterString.check_lower(lud06)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lud06))
        )






    def set_lud16(self, lud16: "str") -> "Metadata":
        _UniffiConverterString.check_lower(lud16)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lud16))
        )






    def set_name(self, name: "str") -> "Metadata":
        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )






    def set_nip05(self, nip05: "str") -> "Metadata":
        _UniffiConverterString.check_lower(nip05)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(nip05))
        )






    def set_picture(self, picture: "str") -> "Metadata":
        _UniffiConverterString.check_lower(picture)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(picture))
        )






    def set_website(self, website: "str") -> "Metadata":
        _UniffiConverterString.check_lower(website)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(website))
        )





class _UniffiConverterTypeMetadata:

    @staticmethod
    def lift(value: int):
        return Metadata._make_instance_(value)

    @staticmethod
    def check_lower(value: Metadata):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MetadataProtocol):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Nip19Protocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError

class Nip19:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nip19, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, string: "str"):
        _UniffiConverterString.check_lower(string)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19_from_bech32,
        _UniffiConverterString.lower(string))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "Nip19Enum":
        return _UniffiConverterTypeNip19Enum.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19_as_enum,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNip19:

    @staticmethod
    def lift(value: int):
        return Nip19._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19):
        if not isinstance(value, Nip19):
            raise TypeError("Expected Nip19 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19Protocol):
        if not isinstance(value, Nip19):
            raise TypeError("Expected Nip19 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Nip19EventProtocol(typing.Protocol):
    def author(self, ):
        raise NotImplementedError
    def event_id(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class Nip19Event:

    _pointer: ctypes.c_void_p
    def __init__(self, event_id: "EventId",author: "typing.Optional[PublicKey]",relays: "typing.List[str]"):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterOptionalTypePublicKey.check_lower(author)
        
        _UniffiConverterSequenceString.check_lower(relays)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_new,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterOptionalTypePublicKey.lower(author),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nip19event, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19event, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19event_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def author(self, ) -> "typing.Optional[PublicKey]":
        return _UniffiConverterOptionalTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_author,self._uniffi_clone_pointer(),)
        )






    def event_id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_event_id,self._uniffi_clone_pointer(),)
        )






    def relays(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_relays,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19event_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNip19Event:

    @staticmethod
    def lift(value: int):
        return Nip19Event._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Event):
        if not isinstance(value, Nip19Event):
            raise TypeError("Expected Nip19Event instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19EventProtocol):
        if not isinstance(value, Nip19Event):
            raise TypeError("Expected Nip19Event instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19EventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Nip19ProfileProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class Nip19Profile:

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        """New NIP19 profile"""

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceString.check_lower(relays)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key,self._uniffi_clone_pointer(),)
        )






    def relays(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNip19Profile:

    @staticmethod
    def lift(value: int):
        return Nip19Profile._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Profile):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19ProfileProtocol):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19ProfileProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Nip21Protocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        """Serialize to NIP21 nostr URI"""

        raise NotImplementedError

class Nip21:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nip21, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nip21, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def parse(cls, uri: "str"):
        """Parse NIP21 string"""

        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip21_parse,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "Nip21Enum":
        return _UniffiConverterTypeNip21Enum.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_as_enum,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        """Serialize to NIP21 nostr URI"""

        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip21_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNip21:

    @staticmethod
    def lift(value: int):
        return Nip21._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip21):
        if not isinstance(value, Nip21):
            raise TypeError("Expected Nip21 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip21Protocol):
        if not isinstance(value, Nip21):
            raise TypeError("Expected Nip21 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip21Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrConnectMetadataProtocol(typing.Protocol):
    def as_json(self, ):
        """Serialize as JSON string"""

        raise NotImplementedError
    def description(self, description: "str"):
        """Description of the `App`"""

        raise NotImplementedError
    def icons(self, icons: "typing.List[str]"):
        """List of URLs for icons of the `App`"""

        raise NotImplementedError
    def url(self, url: "str"):
        """URL of the website requesting the connection"""

        raise NotImplementedError

class NostrConnectMetadata:

    _pointer: ctypes.c_void_p
    def __init__(self, name: "str"):
        """New Nostr Connect Metadata"""

        _UniffiConverterString.check_lower(name)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnectmetadata_new,
        _UniffiConverterString.lower(name))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnectmetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnectmetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_json(self, ) -> "str":
        """Serialize as JSON string"""

        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_as_json,self._uniffi_clone_pointer(),)
        )






    def description(self, description: "str") -> "NostrConnectMetadata":
        """Description of the `App`"""

        _UniffiConverterString.check_lower(description)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_description,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(description))
        )






    def icons(self, icons: "typing.List[str]") -> "NostrConnectMetadata":
        """List of URLs for icons of the `App`"""

        _UniffiConverterSequenceString.check_lower(icons)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_icons,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(icons))
        )






    def url(self, url: "str") -> "NostrConnectMetadata":
        """URL of the website requesting the connection"""

        _UniffiConverterString.check_lower(url)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnectmetadata_url,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(url))
        )





class _UniffiConverterTypeNostrConnectMetadata:

    @staticmethod
    def lift(value: int):
        return NostrConnectMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnectMetadata):
        if not isinstance(value, NostrConnectMetadata):
            raise TypeError("Expected NostrConnectMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectMetadataProtocol):
        if not isinstance(value, NostrConnectMetadata):
            raise TypeError("Expected NostrConnectMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrConnectUriProtocol(typing.Protocol):
    def description(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relay_url(self, ):
        raise NotImplementedError
    def url(self, ):
        raise NotImplementedError

class NostrConnectUri:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description,self._uniffi_clone_pointer(),)
        )






    def name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key,self._uniffi_clone_pointer(),)
        )






    def relay_url(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url,self._uniffi_clone_pointer(),)
        )






    def url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNostrConnectURI:

    @staticmethod
    def lift(value: int):
        return NostrConnectUri._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnectUri):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectUriProtocol):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectUriProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrLibraryProtocol(typing.Protocol):
    def git_hash_version(self, ):
        raise NotImplementedError

class NostrLibrary:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def git_hash_version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNostrLibrary:

    @staticmethod
    def lift(value: int):
        return NostrLibrary._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrLibrary):
        if not isinstance(value, NostrLibrary):
            raise TypeError("Expected NostrLibrary instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrLibraryProtocol):
        if not isinstance(value, NostrLibrary):
            raise TypeError("Expected NostrLibrary instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrLibraryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrWalletConnectUriProtocol(typing.Protocol):
    """Nostr Connect URI"""

    def lud16(self, ):
        """A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured."""

        raise NotImplementedError
    def public_key(self, ):
        """App Pubkey"""

        raise NotImplementedError
    def relay_url(self, ):
        """URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages."""

        raise NotImplementedError
    def secret(self, ):
        """32-byte randomly generated hex encoded string"""

        raise NotImplementedError

class NostrWalletConnectUri:
    """Nostr Connect URI"""


    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relay_url: "str",random_secret_key: "SecretKey",lud16: "typing.Optional[str]"):
        """Create new Nostr Wallet Connect URI"""

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(relay_url)
        
        _UniffiConverterTypeSecretKey.check_lower(random_secret_key)
        
        _UniffiConverterOptionalString.check_lower(lud16)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(relay_url),
        _UniffiConverterTypeSecretKey.lower(random_secret_key),
        _UniffiConverterOptionalString.lower(lud16))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrwalletconnecturi, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrwalletconnecturi, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def parse(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_parse,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def lud16(self, ) -> "typing.Optional[str]":
        """A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured."""

        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_lud16,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        """App Pubkey"""

        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_public_key,self._uniffi_clone_pointer(),)
        )






    def relay_url(self, ) -> "str":
        """URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages."""

        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_relay_url,self._uniffi_clone_pointer(),)
        )






    def secret(self, ) -> "SecretKey":
        """32-byte randomly generated hex encoded string"""

        return _UniffiConverterTypeSecretKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_secret,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNostrWalletConnectURI:

    @staticmethod
    def lift(value: int):
        return NostrWalletConnectUri._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrWalletConnectUri):
        if not isinstance(value, NostrWalletConnectUri):
            raise TypeError("Expected NostrWalletConnectUri instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrWalletConnectUriProtocol):
        if not isinstance(value, NostrWalletConnectUri):
            raise TypeError("Expected NostrWalletConnectUri instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrWalletConnectUriProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PublicKeyProtocol(typing.Protocol):
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class PublicKey:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, pk: "str"):
        _UniffiConverterString.check_lower(pk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32,
        _UniffiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, public_key: "str"):
        """Try to parse public key from `hex` or `bech32`"""

        _UniffiConverterString.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_parse,
        _UniffiConverterString.lower(public_key))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypePublicKey:

    @staticmethod
    def lift(value: int):
        return PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: PublicKey):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PublicKeyProtocol):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RelayInformationDocumentProtocol(typing.Protocol):
    def contact(self, ):
        raise NotImplementedError
    def description(self, ):
        raise NotImplementedError
    def fees(self, ):
        raise NotImplementedError
    def icon(self, ):
        raise NotImplementedError
    def language_tags(self, ):
        raise NotImplementedError
    def limitation(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def payments_url(self, ):
        raise NotImplementedError
    def posting_policy(self, ):
        raise NotImplementedError
    def pubkey(self, ):
        raise NotImplementedError
    def relay_countries(self, ):
        raise NotImplementedError
    def retention(self, ):
        raise NotImplementedError
    def software(self, ):
        raise NotImplementedError
    def supported_nips(self, ):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError

class RelayInformationDocument:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """Create new empty [`RelayInformationDocument`]"""

        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def get(cls, url: "str",proxy: "typing.Optional[str]"):
        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterOptionalString.check_lower(proxy)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get,
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalString.lower(proxy))
        return cls._make_instance_(pointer)



    def contact(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact,self._uniffi_clone_pointer(),)
        )






    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description,self._uniffi_clone_pointer(),)
        )






    def fees(self, ) -> "typing.Optional[FeeSchedules]":
        return _UniffiConverterOptionalTypeFeeSchedules.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_fees,self._uniffi_clone_pointer(),)
        )






    def icon(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_icon,self._uniffi_clone_pointer(),)
        )






    def language_tags(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_language_tags,self._uniffi_clone_pointer(),)
        )






    def limitation(self, ) -> "typing.Optional[Limitation]":
        return _UniffiConverterOptionalTypeLimitation.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_limitation,self._uniffi_clone_pointer(),)
        )






    def name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name,self._uniffi_clone_pointer(),)
        )






    def payments_url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_payments_url,self._uniffi_clone_pointer(),)
        )






    def posting_policy(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_posting_policy,self._uniffi_clone_pointer(),)
        )






    def pubkey(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey,self._uniffi_clone_pointer(),)
        )






    def relay_countries(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_relay_countries,self._uniffi_clone_pointer(),)
        )






    def retention(self, ) -> "typing.List[Retention]":
        return _UniffiConverterSequenceTypeRetention.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_retention,self._uniffi_clone_pointer(),)
        )






    def software(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software,self._uniffi_clone_pointer(),)
        )






    def supported_nips(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt16.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips,self._uniffi_clone_pointer(),)
        )






    def tags(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_tags,self._uniffi_clone_pointer(),)
        )






    def version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeRelayInformationDocument:

    @staticmethod
    def lift(value: int):
        return RelayInformationDocument._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayInformationDocument):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayInformationDocumentProtocol):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayInformationDocumentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RequestProtocol(typing.Protocol):
    """NIP47 Request"""

    def method(self, ):
        raise NotImplementedError
    def params(self, ):
        raise NotImplementedError

class Request:
    """NIP47 Request"""


    _pointer: ctypes.c_void_p
    def __init__(self, method: "Method",params: "RequestParams"):
        _UniffiConverterTypeMethod.check_lower(method)
        
        _UniffiConverterTypeRequestParams.check_lower(params)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_new,
        _UniffiConverterTypeMethod.lower(method),
        _UniffiConverterTypeRequestParams.lower(params))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_request, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_request, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def parse(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_request_parse,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def method(self, ) -> "Method":
        return _UniffiConverterTypeMethod.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_request_method,self._uniffi_clone_pointer(),)
        )






    def params(self, ) -> "RequestParams":
        return _UniffiConverterTypeRequestParams.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_request_params,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeRequest:

    @staticmethod
    def lift(value: int):
        return Request._make_instance_(value)

    @staticmethod
    def check_lower(value: Request):
        if not isinstance(value, Request):
            raise TypeError("Expected Request instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RequestProtocol):
        if not isinstance(value, Request):
            raise TypeError("Expected Request instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ResponseProtocol(typing.Protocol):
    """NIP47 Response"""

    pass

class Response:
    """NIP47 Response"""


    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_response, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_response, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

class _UniffiConverterTypeResponse:

    @staticmethod
    def lift(value: int):
        return Response._make_instance_(value)

    @staticmethod
    def check_lower(value: Response):
        if not isinstance(value, Response):
            raise TypeError("Expected Response instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ResponseProtocol):
        if not isinstance(value, Response):
            raise TypeError("Expected Response instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ResponseProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SecretKeyProtocol(typing.Protocol):
    def encrypt(self, password: "str"):
        """
        Encrypt `SecretKey`

        By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
        To use custom values check `EncryptedSecretKey` constructor.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError

class SecretKey:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, sk: "str"):
        _UniffiConverterString.check_lower(sk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32,
        _UniffiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, secret_key: "str"):
        """Try to parse secret key from `hex` or `bech32`"""

        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_parse,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def encrypt(self, password: "str") -> "EncryptedSecretKey":
        """
        Encrypt `SecretKey`

        By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
        To use custom values check `EncryptedSecretKey` constructor.
        """

        _UniffiConverterString.check_lower(password)
        
        return _UniffiConverterTypeEncryptedSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_encrypt,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(password))
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeSecretKey:

    @staticmethod
    def lift(value: int):
        return SecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: SecretKey):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SecretKeyProtocol):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ShippingMethodProtocol(typing.Protocol):
    def get_shipping_cost(self, ):
        """Get the product shipping cost of the shipping method"""

        raise NotImplementedError
    def name(self, name: "str"):
        """Set the name of the shipping method"""

        raise NotImplementedError
    def regions(self, regions: "typing.List[str]"):
        """Add a region to the shipping method"""

        raise NotImplementedError

class ShippingMethod:

    _pointer: ctypes.c_void_p
    def __init__(self, id: "str",cost: "float"):
        """Create a new shipping method"""

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterDouble.check_lower(cost)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new,
        _UniffiConverterString.lower(id),
        _UniffiConverterDouble.lower(cost))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_shipping_cost(self, ) -> "ShippingCost":
        """Get the product shipping cost of the shipping method"""

        return _UniffiConverterTypeShippingCost.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost,self._uniffi_clone_pointer(),)
        )






    def name(self, name: "str") -> "ShippingMethod":
        """Set the name of the shipping method"""

        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )






    def regions(self, regions: "typing.List[str]") -> "ShippingMethod":
        """Add a region to the shipping method"""

        _UniffiConverterSequenceString.check_lower(regions)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(regions))
        )





class _UniffiConverterTypeShippingMethod:

    @staticmethod
    def lift(value: int):
        return ShippingMethod._make_instance_(value)

    @staticmethod
    def check_lower(value: ShippingMethod):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ShippingMethodProtocol):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ShippingMethodProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SingleLetterTagProtocol(typing.Protocol):
    def is_lowercase(self, ):
        raise NotImplementedError
    def is_uppercase(self, ):
        raise NotImplementedError

class SingleLetterTag:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_singlelettertag, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_singlelettertag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def lowercase(cls, character: "Alphabet"):
        _UniffiConverterTypeAlphabet.check_lower(character)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_lowercase,
        _UniffiConverterTypeAlphabet.lower(character))
        return cls._make_instance_(pointer)


    @classmethod
    def uppercase(cls, character: "Alphabet"):
        _UniffiConverterTypeAlphabet.check_lower(character)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_singlelettertag_uppercase,
        _UniffiConverterTypeAlphabet.lower(character))
        return cls._make_instance_(pointer)



    def is_lowercase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_lowercase,self._uniffi_clone_pointer(),)
        )






    def is_uppercase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_singlelettertag_is_uppercase,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeSingleLetterTag:

    @staticmethod
    def lift(value: int):
        return SingleLetterTag._make_instance_(value)

    @staticmethod
    def check_lower(value: SingleLetterTag):
        if not isinstance(value, SingleLetterTag):
            raise TypeError("Expected SingleLetterTag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SingleLetterTagProtocol):
        if not isinstance(value, SingleLetterTag):
            raise TypeError("Expected SingleLetterTag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SingleLetterTagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TagProtocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError
    def as_vec(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError

class Tag:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_tag, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_tag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def event(cls, event_id: "EventId"):
        """Compose `["e", "<event-id>"]` tag"""

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_event,
        _UniffiConverterTypeEventId.lower(event_id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_enum(cls, e: "TagEnum"):
        _UniffiConverterTypeTagEnum.check_lower(e)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum,
        _UniffiConverterTypeTagEnum.lower(e))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, data: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse,
        _UniffiConverterSequenceString.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def public_key(cls, public_key: "PublicKey"):
        """Compose `["p", "<public-key>"]` tag"""

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_public_key,
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "TagEnum":
        return _UniffiConverterTypeTagEnum.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum,self._uniffi_clone_pointer(),)
        )






    def as_vec(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "TagKind":
        return _UniffiConverterTypeTagKind.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeTag:

    @staticmethod
    def lift(value: int):
        return Tag._make_instance_(value)

    @staticmethod
    def check_lower(value: Tag):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TagProtocol):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TimestampProtocol(typing.Protocol):
    def as_secs(self, ):
        """Get timestamp as [`u64`]"""

        raise NotImplementedError
    def to_human_datetime(self, ):
        """Convert [`Timestamp`] to human datetime"""

        raise NotImplementedError

class Timestamp:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_secs(cls, secs: "int"):
        _UniffiConverterUInt64.check_lower(secs)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs,
        _UniffiConverterUInt64.lower(secs))
        return cls._make_instance_(pointer)


    @classmethod
    def now(cls, ):
        """Get UNIX timestamp"""

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now,)
        return cls._make_instance_(pointer)


    @classmethod
    def tweaked(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_tweaked,)
        return cls._make_instance_(pointer)



    def as_secs(self, ) -> "int":
        """Get timestamp as [`u64`]"""

        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs,self._uniffi_clone_pointer(),)
        )






    def to_human_datetime(self, ) -> "str":
        """Convert [`Timestamp`] to human datetime"""

        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeTimestamp:

    @staticmethod
    def lift(value: int):
        return Timestamp._make_instance_(value)

    @staticmethod
    def check_lower(value: Timestamp):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TimestampProtocol):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TimestampProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class UnsignedEventProtocol(typing.Protocol):
    def add_signature(self, sig: "str"):
        """Add signature to [`UnsignedEvent`]"""

        raise NotImplementedError
    def as_json(self, ):
        raise NotImplementedError
    def author(self, ):
        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def sign(self, keys: "Keys"):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError

class UnsignedEvent:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def add_signature(self, sig: "str") -> "Event":
        """Add signature to [`UnsignedEvent`]"""

        _UniffiConverterString.check_lower(sig)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(sig))
        )






    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json,self._uniffi_clone_pointer(),)
        )






    def author(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_author,self._uniffi_clone_pointer(),)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content,self._uniffi_clone_pointer(),)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at,self._uniffi_clone_pointer(),)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind,self._uniffi_clone_pointer(),)
        )






    def sign(self, keys: "Keys") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeUnsignedEvent:

    @staticmethod
    def lift(value: int):
        return UnsignedEvent._make_instance_(value)

    @staticmethod
    def check_lower(value: UnsignedEvent):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UnsignedEventProtocol):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UnsignedEventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ZapRequestDataProtocol(typing.Protocol):
    def amount(self, amount: "int"):
        raise NotImplementedError
    def event_id(self, event_id: "EventId"):
        raise NotImplementedError
    def lnurl(self, lnurl: "str"):
        raise NotImplementedError
    def message(self, message: "str"):
        raise NotImplementedError

class ZapRequestData:

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceString.check_lower(relays)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amount(self, amount: "int") -> "ZapRequestData":
        _UniffiConverterUInt64.check_lower(amount)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount))
        )






    def event_id(self, event_id: "EventId") -> "ZapRequestData":
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def lnurl(self, lnurl: "str") -> "ZapRequestData":
        _UniffiConverterString.check_lower(lnurl)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lnurl))
        )






    def message(self, message: "str") -> "ZapRequestData":
        _UniffiConverterString.check_lower(message)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_message,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(message))
        )





class _UniffiConverterTypeZapRequestData:

    @staticmethod
    def lift(value: int):
        return ZapRequestData._make_instance_(value)

    @staticmethod
    def check_lower(value: ZapRequestData):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZapRequestDataProtocol):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZapRequestDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class FeeSchedule:
    """The specific information about a fee schedule"""

    amount: "int"
    """The fee amount"""

    unit: "str"
    """The denomination of the feed"""

    period: "typing.Optional[int]"
    """The duration for which the fee is valid"""

    kinds: "typing.Optional[typing.List[str]]"
    """The event kinds the fee allows the client to publish to the relay"""

    @typing.no_type_check
    def __init__(self, amount: "int", unit: "str", period: "typing.Optional[int]", kinds: "typing.Optional[typing.List[str]]"):
        self.amount = amount
        self.unit = unit
        self.period = period
        self.kinds = kinds

    def __str__(self):
        return "FeeSchedule(amount={}, unit={}, period={}, kinds={})".format(self.amount, self.unit, self.period, self.kinds)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.unit != other.unit:
            return False
        if self.period != other.period:
            return False
        if self.kinds != other.kinds:
            return False
        return True

class _UniffiConverterTypeFeeSchedule(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSchedule(
            amount=_UniffiConverterInt32.read(buf),
            unit=_UniffiConverterString.read(buf),
            period=_UniffiConverterOptionalInt32.read(buf),
            kinds=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.unit)
        _UniffiConverterOptionalInt32.check_lower(value.period)
        _UniffiConverterOptionalSequenceString.check_lower(value.kinds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.amount, buf)
        _UniffiConverterString.write(value.unit, buf)
        _UniffiConverterOptionalInt32.write(value.period, buf)
        _UniffiConverterOptionalSequenceString.write(value.kinds, buf)


class FeeSchedules:
    """Available fee schedules"""

    admission: "typing.List[FeeSchedule]"
    """Fees for admission to use the relay"""

    subscription: "typing.List[FeeSchedule]"
    """Fees for subscription to use the relay"""

    publication: "typing.List[FeeSchedule]"
    """Fees to publish to the relay"""

    @typing.no_type_check
    def __init__(self, admission: "typing.List[FeeSchedule]", subscription: "typing.List[FeeSchedule]", publication: "typing.List[FeeSchedule]"):
        self.admission = admission
        self.subscription = subscription
        self.publication = publication

    def __str__(self):
        return "FeeSchedules(admission={}, subscription={}, publication={})".format(self.admission, self.subscription, self.publication)

    def __eq__(self, other):
        if self.admission != other.admission:
            return False
        if self.subscription != other.subscription:
            return False
        if self.publication != other.publication:
            return False
        return True

class _UniffiConverterTypeFeeSchedules(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSchedules(
            admission=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
            subscription=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
            publication=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.admission)
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.subscription)
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.publication)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeFeeSchedule.write(value.admission, buf)
        _UniffiConverterSequenceTypeFeeSchedule.write(value.subscription, buf)
        _UniffiConverterSequenceTypeFeeSchedule.write(value.publication, buf)


class GetBalanceResponseResult:
    """NIP47 Response Result"""

    balance: "int"
    """Balance amount in msats"""

    @typing.no_type_check
    def __init__(self, balance: "int"):
        self.balance = balance

    def __str__(self):
        return "GetBalanceResponseResult(balance={})".format(self.balance)

    def __eq__(self, other):
        if self.balance != other.balance:
            return False
        return True

class _UniffiConverterTypeGetBalanceResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBalanceResponseResult(
            balance=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.balance)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.balance, buf)


class GetInfoResponseResult:
    """NIP47 Response Result"""

    alias: "str"
    """The alias of the lightning node"""

    color: "str"
    """The color of the current node in hex code format"""

    pubkey: "str"
    """Lightning Node's public key"""

    network: "str"
    """Active network"""

    block_height: "int"
    """Current block height"""

    block_hash: "str"
    """Most Recent Block Hash"""

    methods: "typing.List[str]"
    """Available methods for this connection"""

    @typing.no_type_check
    def __init__(self, alias: "str", color: "str", pubkey: "str", network: "str", block_height: "int", block_hash: "str", methods: "typing.List[str]"):
        self.alias = alias
        self.color = color
        self.pubkey = pubkey
        self.network = network
        self.block_height = block_height
        self.block_hash = block_hash
        self.methods = methods

    def __str__(self):
        return "GetInfoResponseResult(alias={}, color={}, pubkey={}, network={}, block_height={}, block_hash={}, methods={})".format(self.alias, self.color, self.pubkey, self.network, self.block_height, self.block_hash, self.methods)

    def __eq__(self, other):
        if self.alias != other.alias:
            return False
        if self.color != other.color:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.network != other.network:
            return False
        if self.block_height != other.block_height:
            return False
        if self.block_hash != other.block_hash:
            return False
        if self.methods != other.methods:
            return False
        return True

class _UniffiConverterTypeGetInfoResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetInfoResponseResult(
            alias=_UniffiConverterString.read(buf),
            color=_UniffiConverterString.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            network=_UniffiConverterString.read(buf),
            block_height=_UniffiConverterUInt32.read(buf),
            block_hash=_UniffiConverterString.read(buf),
            methods=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.alias)
        _UniffiConverterString.check_lower(value.color)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.network)
        _UniffiConverterUInt32.check_lower(value.block_height)
        _UniffiConverterString.check_lower(value.block_hash)
        _UniffiConverterSequenceString.check_lower(value.methods)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.alias, buf)
        _UniffiConverterString.write(value.color, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterString.write(value.network, buf)
        _UniffiConverterUInt32.write(value.block_height, buf)
        _UniffiConverterString.write(value.block_hash, buf)
        _UniffiConverterSequenceString.write(value.methods, buf)


class HttpData:
    url: "str"
    method: "HttpMethod"
    payload: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, url: "str", method: "HttpMethod", payload: "typing.Optional[str]"):
        self.url = url
        self.method = method
        self.payload = payload

    def __str__(self):
        return "HttpData(url={}, method={}, payload={})".format(self.url, self.method, self.payload)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.method != other.method:
            return False
        if self.payload != other.payload:
            return False
        return True

class _UniffiConverterTypeHttpData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HttpData(
            url=_UniffiConverterString.read(buf),
            method=_UniffiConverterTypeHttpMethod.read(buf),
            payload=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterTypeHttpMethod.check_lower(value.method)
        _UniffiConverterOptionalString.check_lower(value.payload)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterTypeHttpMethod.write(value.method, buf)
        _UniffiConverterOptionalString.write(value.payload, buf)


class Identity:
    """A NIP-39 external identity"""

    platform: "ExternalIdentity"
    """The external identity provider"""

    ident: "str"
    """The user's identity (username) on the provider"""

    proof: "str"
    """The user's proof on the provider"""

    @typing.no_type_check
    def __init__(self, platform: "ExternalIdentity", ident: "str", proof: "str"):
        self.platform = platform
        self.ident = ident
        self.proof = proof

    def __str__(self):
        return "Identity(platform={}, ident={}, proof={})".format(self.platform, self.ident, self.proof)

    def __eq__(self, other):
        if self.platform != other.platform:
            return False
        if self.ident != other.ident:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Identity(
            platform=_UniffiConverterTypeExternalIdentity.read(buf),
            ident=_UniffiConverterString.read(buf),
            proof=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentity.check_lower(value.platform)
        _UniffiConverterString.check_lower(value.ident)
        _UniffiConverterString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentity.write(value.platform, buf)
        _UniffiConverterString.write(value.ident, buf)
        _UniffiConverterString.write(value.proof, buf)


class Image:
    url: "str"
    dimensions: "typing.Optional[ImageDimensions]"
    @typing.no_type_check
    def __init__(self, url: "str", dimensions: "typing.Optional[ImageDimensions]"):
        self.url = url
        self.dimensions = dimensions

    def __str__(self):
        return "Image(url={}, dimensions={})".format(self.url, self.dimensions)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.dimensions != other.dimensions:
            return False
        return True

class _UniffiConverterTypeImage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Image(
            url=_UniffiConverterString.read(buf),
            dimensions=_UniffiConverterOptionalTypeImageDimensions.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)


class KeysendTlvRecord:
    """TLVs to be added to the keysend payment"""

    tlv_type: "int"
    """TLV type"""

    value: "str"
    """TLV value"""

    @typing.no_type_check
    def __init__(self, tlv_type: "int", value: "str"):
        self.tlv_type = tlv_type
        self.value = value

    def __str__(self):
        return "KeysendTlvRecord(tlv_type={}, value={})".format(self.tlv_type, self.value)

    def __eq__(self, other):
        if self.tlv_type != other.tlv_type:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeKeysendTLVRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeysendTlvRecord(
            tlv_type=_UniffiConverterUInt64.read(buf),
            value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.tlv_type)
        _UniffiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.tlv_type, buf)
        _UniffiConverterString.write(value.value, buf)


class Limitation:
    """
    These are limitations imposed by the relay on clients. Your client should
    expect that requests which exceed these practical limitations are rejected or fail immediately.
    """

    max_message_length: "typing.Optional[int]"
    """Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon"""

    max_subscriptions: "typing.Optional[int]"
    """Total number of subscriptions that may be active on a single websocket connection"""

    max_filters: "typing.Optional[int]"
    """Maximum number of filter values in each subscription"""

    max_limit: "typing.Optional[int]"
    """Relay will clamp each filter's limit value to this number"""

    max_subid_length: "typing.Optional[int]"
    """Maximum length of subscription id as a string"""

    max_event_tags: "typing.Optional[int]"
    """Maximum number of elements in the tags list"""

    max_content_length: "typing.Optional[int]"
    """Maximum number of characters in the content field of any event"""

    min_pow_difficulty: "typing.Optional[int]"
    """New events will require at least this difficulty of PoW,"""

    auth_required: "typing.Optional[bool]"
    """Relay requires NIP-42 authentication to happen before a new connection may perform any other action"""

    payment_required: "typing.Optional[bool]"
    """Relay requires payment before a new connection may perform any action"""

    created_at_lower_limit: "typing.Optional[Timestamp]"
    """'created_at' lower limit"""

    created_at_upper_limit: "typing.Optional[Timestamp]"
    """'created_at' upper limit"""

    @typing.no_type_check
    def __init__(self, max_message_length: "typing.Optional[int]", max_subscriptions: "typing.Optional[int]", max_filters: "typing.Optional[int]", max_limit: "typing.Optional[int]", max_subid_length: "typing.Optional[int]", max_event_tags: "typing.Optional[int]", max_content_length: "typing.Optional[int]", min_pow_difficulty: "typing.Optional[int]", auth_required: "typing.Optional[bool]", payment_required: "typing.Optional[bool]", created_at_lower_limit: "typing.Optional[Timestamp]", created_at_upper_limit: "typing.Optional[Timestamp]"):
        self.max_message_length = max_message_length
        self.max_subscriptions = max_subscriptions
        self.max_filters = max_filters
        self.max_limit = max_limit
        self.max_subid_length = max_subid_length
        self.max_event_tags = max_event_tags
        self.max_content_length = max_content_length
        self.min_pow_difficulty = min_pow_difficulty
        self.auth_required = auth_required
        self.payment_required = payment_required
        self.created_at_lower_limit = created_at_lower_limit
        self.created_at_upper_limit = created_at_upper_limit

    def __str__(self):
        return "Limitation(max_message_length={}, max_subscriptions={}, max_filters={}, max_limit={}, max_subid_length={}, max_event_tags={}, max_content_length={}, min_pow_difficulty={}, auth_required={}, payment_required={}, created_at_lower_limit={}, created_at_upper_limit={})".format(self.max_message_length, self.max_subscriptions, self.max_filters, self.max_limit, self.max_subid_length, self.max_event_tags, self.max_content_length, self.min_pow_difficulty, self.auth_required, self.payment_required, self.created_at_lower_limit, self.created_at_upper_limit)

    def __eq__(self, other):
        if self.max_message_length != other.max_message_length:
            return False
        if self.max_subscriptions != other.max_subscriptions:
            return False
        if self.max_filters != other.max_filters:
            return False
        if self.max_limit != other.max_limit:
            return False
        if self.max_subid_length != other.max_subid_length:
            return False
        if self.max_event_tags != other.max_event_tags:
            return False
        if self.max_content_length != other.max_content_length:
            return False
        if self.min_pow_difficulty != other.min_pow_difficulty:
            return False
        if self.auth_required != other.auth_required:
            return False
        if self.payment_required != other.payment_required:
            return False
        if self.created_at_lower_limit != other.created_at_lower_limit:
            return False
        if self.created_at_upper_limit != other.created_at_upper_limit:
            return False
        return True

class _UniffiConverterTypeLimitation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Limitation(
            max_message_length=_UniffiConverterOptionalInt32.read(buf),
            max_subscriptions=_UniffiConverterOptionalInt32.read(buf),
            max_filters=_UniffiConverterOptionalInt32.read(buf),
            max_limit=_UniffiConverterOptionalInt32.read(buf),
            max_subid_length=_UniffiConverterOptionalInt32.read(buf),
            max_event_tags=_UniffiConverterOptionalInt32.read(buf),
            max_content_length=_UniffiConverterOptionalInt32.read(buf),
            min_pow_difficulty=_UniffiConverterOptionalInt32.read(buf),
            auth_required=_UniffiConverterOptionalBool.read(buf),
            payment_required=_UniffiConverterOptionalBool.read(buf),
            created_at_lower_limit=_UniffiConverterOptionalTypeTimestamp.read(buf),
            created_at_upper_limit=_UniffiConverterOptionalTypeTimestamp.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt32.check_lower(value.max_message_length)
        _UniffiConverterOptionalInt32.check_lower(value.max_subscriptions)
        _UniffiConverterOptionalInt32.check_lower(value.max_filters)
        _UniffiConverterOptionalInt32.check_lower(value.max_limit)
        _UniffiConverterOptionalInt32.check_lower(value.max_subid_length)
        _UniffiConverterOptionalInt32.check_lower(value.max_event_tags)
        _UniffiConverterOptionalInt32.check_lower(value.max_content_length)
        _UniffiConverterOptionalInt32.check_lower(value.min_pow_difficulty)
        _UniffiConverterOptionalBool.check_lower(value.auth_required)
        _UniffiConverterOptionalBool.check_lower(value.payment_required)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.created_at_lower_limit)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.created_at_upper_limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt32.write(value.max_message_length, buf)
        _UniffiConverterOptionalInt32.write(value.max_subscriptions, buf)
        _UniffiConverterOptionalInt32.write(value.max_filters, buf)
        _UniffiConverterOptionalInt32.write(value.max_limit, buf)
        _UniffiConverterOptionalInt32.write(value.max_subid_length, buf)
        _UniffiConverterOptionalInt32.write(value.max_event_tags, buf)
        _UniffiConverterOptionalInt32.write(value.max_content_length, buf)
        _UniffiConverterOptionalInt32.write(value.min_pow_difficulty, buf)
        _UniffiConverterOptionalBool.write(value.auth_required, buf)
        _UniffiConverterOptionalBool.write(value.payment_required, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.created_at_lower_limit, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.created_at_upper_limit, buf)


class ListTransactionsRequestParams:
    """List Invoice Request Params"""

    _from: "typing.Optional[int]"
    """Starting timestamp in seconds since epoch"""

    until: "typing.Optional[int]"
    """Ending timestamp in seconds since epoch"""

    limit: "typing.Optional[int]"
    """Number of invoices to return"""

    offset: "typing.Optional[int]"
    """Offset of the first invoice to return"""

    unpaid: "typing.Optional[bool]"
    """If true, include unpaid invoices"""

    transaction_type: "typing.Optional[TransactionType]"
    """[`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both"""

    @typing.no_type_check
    def __init__(self, _from: "typing.Optional[int]", until: "typing.Optional[int]", limit: "typing.Optional[int]", offset: "typing.Optional[int]", unpaid: "typing.Optional[bool]", transaction_type: "typing.Optional[TransactionType]"):
        self._from = _from
        self.until = until
        self.limit = limit
        self.offset = offset
        self.unpaid = unpaid
        self.transaction_type = transaction_type

    def __str__(self):
        return "ListTransactionsRequestParams(_from={}, until={}, limit={}, offset={}, unpaid={}, transaction_type={})".format(self._from, self.until, self.limit, self.offset, self.unpaid, self.transaction_type)

    def __eq__(self, other):
        if self._from != other._from:
            return False
        if self.until != other.until:
            return False
        if self.limit != other.limit:
            return False
        if self.offset != other.offset:
            return False
        if self.unpaid != other.unpaid:
            return False
        if self.transaction_type != other.transaction_type:
            return False
        return True

class _UniffiConverterTypeListTransactionsRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListTransactionsRequestParams(
            _from=_UniffiConverterOptionalUInt64.read(buf),
            until=_UniffiConverterOptionalUInt64.read(buf),
            limit=_UniffiConverterOptionalUInt64.read(buf),
            offset=_UniffiConverterOptionalUInt64.read(buf),
            unpaid=_UniffiConverterOptionalBool.read(buf),
            transaction_type=_UniffiConverterOptionalTypeTransactionType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value._from)
        _UniffiConverterOptionalUInt64.check_lower(value.until)
        _UniffiConverterOptionalUInt64.check_lower(value.limit)
        _UniffiConverterOptionalUInt64.check_lower(value.offset)
        _UniffiConverterOptionalBool.check_lower(value.unpaid)
        _UniffiConverterOptionalTypeTransactionType.check_lower(value.transaction_type)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value._from, buf)
        _UniffiConverterOptionalUInt64.write(value.until, buf)
        _UniffiConverterOptionalUInt64.write(value.limit, buf)
        _UniffiConverterOptionalUInt64.write(value.offset, buf)
        _UniffiConverterOptionalBool.write(value.unpaid, buf)
        _UniffiConverterOptionalTypeTransactionType.write(value.transaction_type, buf)


class LiveEvent:
    id: "str"
    title: "typing.Optional[str]"
    summary: "typing.Optional[str]"
    image: "typing.Optional[Image]"
    hashtags: "typing.List[str]"
    streaming: "typing.Optional[str]"
    recording: "typing.Optional[str]"
    start: "typing.Optional[Timestamp]"
    ends: "typing.Optional[Timestamp]"
    status: "typing.Optional[LiveEventStatus]"
    current_participants: "typing.Optional[int]"
    total_participants: "typing.Optional[int]"
    relays: "typing.List[str]"
    host: "typing.Optional[LiveEventHost]"
    speakers: "typing.List[Person]"
    participants: "typing.List[Person]"
    @typing.no_type_check
    def __init__(self, id: "str", title: "typing.Optional[str]", summary: "typing.Optional[str]", image: "typing.Optional[Image]", hashtags: "typing.List[str]", streaming: "typing.Optional[str]", recording: "typing.Optional[str]", start: "typing.Optional[Timestamp]", ends: "typing.Optional[Timestamp]", status: "typing.Optional[LiveEventStatus]", current_participants: "typing.Optional[int]", total_participants: "typing.Optional[int]", relays: "typing.List[str]", host: "typing.Optional[LiveEventHost]", speakers: "typing.List[Person]", participants: "typing.List[Person]"):
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.current_participants = current_participants
        self.total_participants = total_participants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants

    def __str__(self):
        return "LiveEvent(id={}, title={}, summary={}, image={}, hashtags={}, streaming={}, recording={}, start={}, ends={}, status={}, current_participants={}, total_participants={}, relays={}, host={}, speakers={}, participants={})".format(self.id, self.title, self.summary, self.image, self.hashtags, self.streaming, self.recording, self.start, self.ends, self.status, self.current_participants, self.total_participants, self.relays, self.host, self.speakers, self.participants)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.title != other.title:
            return False
        if self.summary != other.summary:
            return False
        if self.image != other.image:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.streaming != other.streaming:
            return False
        if self.recording != other.recording:
            return False
        if self.start != other.start:
            return False
        if self.ends != other.ends:
            return False
        if self.status != other.status:
            return False
        if self.current_participants != other.current_participants:
            return False
        if self.total_participants != other.total_participants:
            return False
        if self.relays != other.relays:
            return False
        if self.host != other.host:
            return False
        if self.speakers != other.speakers:
            return False
        if self.participants != other.participants:
            return False
        return True

class _UniffiConverterTypeLiveEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEvent(
            id=_UniffiConverterString.read(buf),
            title=_UniffiConverterOptionalString.read(buf),
            summary=_UniffiConverterOptionalString.read(buf),
            image=_UniffiConverterOptionalTypeImage.read(buf),
            hashtags=_UniffiConverterSequenceString.read(buf),
            streaming=_UniffiConverterOptionalString.read(buf),
            recording=_UniffiConverterOptionalString.read(buf),
            start=_UniffiConverterOptionalTypeTimestamp.read(buf),
            ends=_UniffiConverterOptionalTypeTimestamp.read(buf),
            status=_UniffiConverterOptionalTypeLiveEventStatus.read(buf),
            current_participants=_UniffiConverterOptionalUInt64.read(buf),
            total_participants=_UniffiConverterOptionalUInt64.read(buf),
            relays=_UniffiConverterSequenceString.read(buf),
            host=_UniffiConverterOptionalTypeLiveEventHost.read(buf),
            speakers=_UniffiConverterSequenceTypePerson.read(buf),
            participants=_UniffiConverterSequenceTypePerson.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.title)
        _UniffiConverterOptionalString.check_lower(value.summary)
        _UniffiConverterOptionalTypeImage.check_lower(value.image)
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterOptionalString.check_lower(value.streaming)
        _UniffiConverterOptionalString.check_lower(value.recording)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.start)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.ends)
        _UniffiConverterOptionalTypeLiveEventStatus.check_lower(value.status)
        _UniffiConverterOptionalUInt64.check_lower(value.current_participants)
        _UniffiConverterOptionalUInt64.check_lower(value.total_participants)
        _UniffiConverterSequenceString.check_lower(value.relays)
        _UniffiConverterOptionalTypeLiveEventHost.check_lower(value.host)
        _UniffiConverterSequenceTypePerson.check_lower(value.speakers)
        _UniffiConverterSequenceTypePerson.check_lower(value.participants)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.title, buf)
        _UniffiConverterOptionalString.write(value.summary, buf)
        _UniffiConverterOptionalTypeImage.write(value.image, buf)
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterOptionalString.write(value.streaming, buf)
        _UniffiConverterOptionalString.write(value.recording, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.start, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.ends, buf)
        _UniffiConverterOptionalTypeLiveEventStatus.write(value.status, buf)
        _UniffiConverterOptionalUInt64.write(value.current_participants, buf)
        _UniffiConverterOptionalUInt64.write(value.total_participants, buf)
        _UniffiConverterSequenceString.write(value.relays, buf)
        _UniffiConverterOptionalTypeLiveEventHost.write(value.host, buf)
        _UniffiConverterSequenceTypePerson.write(value.speakers, buf)
        _UniffiConverterSequenceTypePerson.write(value.participants, buf)


class LiveEventHost:
    public_key: "PublicKey"
    relay_url: "typing.Optional[str]"
    proof: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, public_key: "PublicKey", relay_url: "typing.Optional[str]", proof: "typing.Optional[str]"):
        self.public_key = public_key
        self.relay_url = relay_url
        self.proof = proof

    def __str__(self):
        return "LiveEventHost(public_key={}, relay_url={}, proof={})".format(self.public_key, self.relay_url, self.proof)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeLiveEventHost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEventHost(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalString.read(buf),
            proof=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalString.check_lower(value.relay_url)
        _UniffiConverterOptionalString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalString.write(value.relay_url, buf)
        _UniffiConverterOptionalString.write(value.proof, buf)


class LookupInvoiceRequestParams:
    """Lookup Invoice Request Params"""

    payment_hash: "typing.Optional[str]"
    """Payment hash of invoice"""

    bolt11: "typing.Optional[str]"
    """Bolt11 invoice"""

    @typing.no_type_check
    def __init__(self, payment_hash: "typing.Optional[str]", bolt11: "typing.Optional[str]"):
        self.payment_hash = payment_hash
        self.bolt11 = bolt11

    def __str__(self):
        return "LookupInvoiceRequestParams(payment_hash={}, bolt11={})".format(self.payment_hash, self.bolt11)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.bolt11 != other.bolt11:
            return False
        return True

class _UniffiConverterTypeLookupInvoiceRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LookupInvoiceRequestParams(
            payment_hash=_UniffiConverterOptionalString.read(buf),
            bolt11=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.bolt11)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.bolt11, buf)


class LookupInvoiceResponseResult:
    """NIP47 Response Result"""

    transaction_type: "typing.Optional[TransactionType]"
    """Transaction type"""

    invoice: "typing.Optional[str]"
    """Bolt11 invoice"""

    description: "typing.Optional[str]"
    """Invoice's description"""

    description_hash: "typing.Optional[str]"
    """Invoice's description hash"""

    preimage: "typing.Optional[str]"
    """Payment preimage"""

    payment_hash: "str"
    """Payment hash"""

    amount: "int"
    """Amount in millisatoshis"""

    fees_paid: "int"
    """Fees paid in millisatoshis"""

    created_at: "int"
    """Creation timestamp in seconds since epoch"""

    expires_at: "int"
    """Expiration timestamp in seconds since epoch"""

    settled_at: "typing.Optional[int]"
    """Settled timestamp in seconds since epoch"""

    metadata: "str"
    """Optional metadata about the payment"""

    @typing.no_type_check
    def __init__(self, transaction_type: "typing.Optional[TransactionType]", invoice: "typing.Optional[str]", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", preimage: "typing.Optional[str]", payment_hash: "str", amount: "int", fees_paid: "int", created_at: "int", expires_at: "int", settled_at: "typing.Optional[int]", metadata: "str"):
        self.transaction_type = transaction_type
        self.invoice = invoice
        self.description = description
        self.description_hash = description_hash
        self.preimage = preimage
        self.payment_hash = payment_hash
        self.amount = amount
        self.fees_paid = fees_paid
        self.created_at = created_at
        self.expires_at = expires_at
        self.settled_at = settled_at
        self.metadata = metadata

    def __str__(self):
        return "LookupInvoiceResponseResult(transaction_type={}, invoice={}, description={}, description_hash={}, preimage={}, payment_hash={}, amount={}, fees_paid={}, created_at={}, expires_at={}, settled_at={}, metadata={})".format(self.transaction_type, self.invoice, self.description, self.description_hash, self.preimage, self.payment_hash, self.amount, self.fees_paid, self.created_at, self.expires_at, self.settled_at, self.metadata)

    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.invoice != other.invoice:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.amount != other.amount:
            return False
        if self.fees_paid != other.fees_paid:
            return False
        if self.created_at != other.created_at:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.settled_at != other.settled_at:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeLookupInvoiceResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LookupInvoiceResponseResult(
            transaction_type=_UniffiConverterOptionalTypeTransactionType.read(buf),
            invoice=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            fees_paid=_UniffiConverterUInt64.read(buf),
            created_at=_UniffiConverterUInt64.read(buf),
            expires_at=_UniffiConverterUInt64.read(buf),
            settled_at=_UniffiConverterOptionalUInt64.read(buf),
            metadata=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeTransactionType.check_lower(value.transaction_type)
        _UniffiConverterOptionalString.check_lower(value.invoice)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterUInt64.check_lower(value.fees_paid)
        _UniffiConverterUInt64.check_lower(value.created_at)
        _UniffiConverterUInt64.check_lower(value.expires_at)
        _UniffiConverterOptionalUInt64.check_lower(value.settled_at)
        _UniffiConverterString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeTransactionType.write(value.transaction_type, buf)
        _UniffiConverterOptionalString.write(value.invoice, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterUInt64.write(value.fees_paid, buf)
        _UniffiConverterUInt64.write(value.created_at, buf)
        _UniffiConverterUInt64.write(value.expires_at, buf)
        _UniffiConverterOptionalUInt64.write(value.settled_at, buf)
        _UniffiConverterString.write(value.metadata, buf)


class MakeInvoiceRequestParams:
    """Make Invoice Request Params"""

    amount: "int"
    """Amount in millisatoshis"""

    description: "typing.Optional[str]"
    """Invoice description"""

    description_hash: "typing.Optional[str]"
    """Invoice description hash"""

    expiry: "typing.Optional[int]"
    """Invoice expiry in seconds"""

    @typing.no_type_check
    def __init__(self, amount: "int", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", expiry: "typing.Optional[int]"):
        self.amount = amount
        self.description = description
        self.description_hash = description_hash
        self.expiry = expiry

    def __str__(self):
        return "MakeInvoiceRequestParams(amount={}, description={}, description_hash={}, expiry={})".format(self.amount, self.description, self.description_hash, self.expiry)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        return True

class _UniffiConverterTypeMakeInvoiceRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeInvoiceRequestParams(
            amount=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            expiry=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalUInt64.check_lower(value.expiry)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalUInt64.write(value.expiry, buf)


class MakeInvoiceResponseResult:
    """NIP47 Response Result"""

    invoice: "str"
    """Bolt 11 invoice"""

    payment_hash: "str"
    """Invoice's payment hash"""

    @typing.no_type_check
    def __init__(self, invoice: "str", payment_hash: "str"):
        self.invoice = invoice
        self.payment_hash = payment_hash

    def __str__(self):
        return "MakeInvoiceResponseResult(invoice={}, payment_hash={})".format(self.invoice, self.payment_hash)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        return True

class _UniffiConverterTypeMakeInvoiceResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeInvoiceResponseResult(
            invoice=_UniffiConverterString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterString.check_lower(value.payment_hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterString.write(value.payment_hash, buf)


class MultiPayInvoiceRequestParams:
    """Multi Pay Invoice Request Params"""

    invoices: "typing.List[PayInvoiceRequestParams]"
    """Invoices to pay"""

    @typing.no_type_check
    def __init__(self, invoices: "typing.List[PayInvoiceRequestParams]"):
        self.invoices = invoices

    def __str__(self):
        return "MultiPayInvoiceRequestParams(invoices={})".format(self.invoices)

    def __eq__(self, other):
        if self.invoices != other.invoices:
            return False
        return True

class _UniffiConverterTypeMultiPayInvoiceRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiPayInvoiceRequestParams(
            invoices=_UniffiConverterSequenceTypePayInvoiceRequestParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePayInvoiceRequestParams.check_lower(value.invoices)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePayInvoiceRequestParams.write(value.invoices, buf)


class MultiPayKeysendRequestParams:
    """Multi Pay Keysend Request Params"""

    keysends: "typing.List[PayKeysendRequestParams]"
    """Keysends"""

    @typing.no_type_check
    def __init__(self, keysends: "typing.List[PayKeysendRequestParams]"):
        self.keysends = keysends

    def __str__(self):
        return "MultiPayKeysendRequestParams(keysends={})".format(self.keysends)

    def __eq__(self, other):
        if self.keysends != other.keysends:
            return False
        return True

class _UniffiConverterTypeMultiPayKeysendRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiPayKeysendRequestParams(
            keysends=_UniffiConverterSequenceTypePayKeysendRequestParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePayKeysendRequestParams.check_lower(value.keysends)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePayKeysendRequestParams.write(value.keysends, buf)


class Nip47Error:
    """NIP47 Error message"""

    code: "ErrorCode"
    """Error Code"""

    message: "str"
    """Human Readable error message"""

    @typing.no_type_check
    def __init__(self, code: "ErrorCode", message: "str"):
        self.code = code
        self.message = message

    def __str__(self):
        return "Nip47Error(code={}, message={})".format(self.code, self.message)

    def __eq__(self, other):
        if self.code != other.code:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeNIP47Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Nip47Error(
            code=_UniffiConverterTypeErrorCode.read(buf),
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeErrorCode.check_lower(value.code)
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeErrorCode.write(value.code, buf)
        _UniffiConverterString.write(value.message, buf)


class PayInvoiceRequestParams:
    """Pay Invoice Request Params"""

    id: "typing.Optional[str]"
    """Optional id"""

    invoice: "str"
    """Request invoice"""

    amount: "typing.Optional[int]"
    """Optional amount in millisatoshis"""

    @typing.no_type_check
    def __init__(self, id: "typing.Optional[str]", invoice: "str", amount: "typing.Optional[int]"):
        self.id = id
        self.invoice = invoice
        self.amount = amount

    def __str__(self):
        return "PayInvoiceRequestParams(id={}, invoice={}, amount={})".format(self.id, self.invoice, self.amount)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.invoice != other.invoice:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypePayInvoiceRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayInvoiceRequestParams(
            id=_UniffiConverterOptionalString.read(buf),
            invoice=_UniffiConverterString.read(buf),
            amount=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterOptionalUInt64.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterOptionalUInt64.write(value.amount, buf)


class PayInvoiceResponseResult:
    """NIP47 Response Result"""

    preimage: "str"
    """Response preimage"""

    @typing.no_type_check
    def __init__(self, preimage: "str"):
        self.preimage = preimage

    def __str__(self):
        return "PayInvoiceResponseResult(preimage={})".format(self.preimage)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        return True

class _UniffiConverterTypePayInvoiceResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayInvoiceResponseResult(
            preimage=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)


class PayKeysendRequestParams:
    """Pay Invoice Request Params"""

    id: "typing.Optional[str]"
    """Optional id"""

    amount: "int"
    """Amount in millisatoshis"""

    pubkey: "str"
    """Receiver's node id"""

    preimage: "typing.Optional[str]"
    """Optional preimage"""

    tlv_records: "typing.List[KeysendTlvRecord]"
    """Optional TLVs to be added to the keysend payment"""

    @typing.no_type_check
    def __init__(self, id: "typing.Optional[str]", amount: "int", pubkey: "str", preimage: "typing.Optional[str]", tlv_records: "typing.List[KeysendTlvRecord]"):
        self.id = id
        self.amount = amount
        self.pubkey = pubkey
        self.preimage = preimage
        self.tlv_records = tlv_records

    def __str__(self):
        return "PayKeysendRequestParams(id={}, amount={}, pubkey={}, preimage={}, tlv_records={})".format(self.id, self.amount, self.pubkey, self.preimage, self.tlv_records)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.amount != other.amount:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.preimage != other.preimage:
            return False
        if self.tlv_records != other.tlv_records:
            return False
        return True

class _UniffiConverterTypePayKeysendRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayKeysendRequestParams(
            id=_UniffiConverterOptionalString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            tlv_records=_UniffiConverterSequenceTypeKeysendTLVRecord.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterSequenceTypeKeysendTLVRecord.check_lower(value.tlv_records)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterSequenceTypeKeysendTLVRecord.write(value.tlv_records, buf)


class PayKeysendResponseResult:
    """NIP47 Response Result"""

    preimage: "str"
    """Response preimage"""

    @typing.no_type_check
    def __init__(self, preimage: "str"):
        self.preimage = preimage

    def __str__(self):
        return "PayKeysendResponseResult(preimage={})".format(self.preimage)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        return True

class _UniffiConverterTypePayKeysendResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayKeysendResponseResult(
            preimage=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)


class Person:
    public_key: "PublicKey"
    url: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, public_key: "PublicKey", url: "typing.Optional[str]"):
        self.public_key = public_key
        self.url = url

    def __str__(self):
        return "Person(public_key={}, url={})".format(self.public_key, self.url)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.url != other.url:
            return False
        return True

class _UniffiConverterTypePerson(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Person(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalString.check_lower(value.url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalString.write(value.url, buf)


class ProductData:
    """Payload for creating or updating product"""

    id: "str"
    """UUID of the product generated by merchant"""

    stall_id: "str"
    """Id of the stall that this product belongs to"""

    name: "str"
    """Product name"""

    description: "typing.Optional[str]"
    """Description of the product"""

    images: "typing.Optional[typing.List[str]]"
    """Image urls of the product"""

    currency: "str"
    """Currency used"""

    price: "float"
    """Price of the product"""

    quantity: "int"
    """Available items"""

    specs: "typing.Optional[typing.List[typing.List[str]]]"
    """Specifications of the product"""

    shipping: "typing.List[ShippingCost]"
    """Shipping method costs"""

    categories: "typing.Optional[typing.List[str]]"
    """Categories of the product (will be added to tags)"""

    @typing.no_type_check
    def __init__(self, id: "str", stall_id: "str", name: "str", description: "typing.Optional[str]", images: "typing.Optional[typing.List[str]]", currency: "str", price: "float", quantity: "int", specs: "typing.Optional[typing.List[typing.List[str]]]", shipping: "typing.List[ShippingCost]", categories: "typing.Optional[typing.List[str]]"):
        self.id = id
        self.stall_id = stall_id
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories

    def __str__(self):
        return "ProductData(id={}, stall_id={}, name={}, description={}, images={}, currency={}, price={}, quantity={}, specs={}, shipping={}, categories={})".format(self.id, self.stall_id, self.name, self.description, self.images, self.currency, self.price, self.quantity, self.specs, self.shipping, self.categories)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.stall_id != other.stall_id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.images != other.images:
            return False
        if self.currency != other.currency:
            return False
        if self.price != other.price:
            return False
        if self.quantity != other.quantity:
            return False
        if self.specs != other.specs:
            return False
        if self.shipping != other.shipping:
            return False
        if self.categories != other.categories:
            return False
        return True

class _UniffiConverterTypeProductData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProductData(
            id=_UniffiConverterString.read(buf),
            stall_id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            images=_UniffiConverterOptionalSequenceString.read(buf),
            currency=_UniffiConverterString.read(buf),
            price=_UniffiConverterDouble.read(buf),
            quantity=_UniffiConverterUInt64.read(buf),
            specs=_UniffiConverterOptionalSequenceSequenceString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingCost.read(buf),
            categories=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.stall_id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalSequenceString.check_lower(value.images)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterDouble.check_lower(value.price)
        _UniffiConverterUInt64.check_lower(value.quantity)
        _UniffiConverterOptionalSequenceSequenceString.check_lower(value.specs)
        _UniffiConverterSequenceTypeShippingCost.check_lower(value.shipping)
        _UniffiConverterOptionalSequenceString.check_lower(value.categories)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.stall_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalSequenceString.write(value.images, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterDouble.write(value.price, buf)
        _UniffiConverterUInt64.write(value.quantity, buf)
        _UniffiConverterOptionalSequenceSequenceString.write(value.specs, buf)
        _UniffiConverterSequenceTypeShippingCost.write(value.shipping, buf)
        _UniffiConverterOptionalSequenceString.write(value.categories, buf)


class Retention:
    """A retention schedule for the relay"""

    kinds: "typing.Optional[typing.List[RetentionKind]]"
    """The event kinds this retention pertains to"""

    time: "typing.Optional[int]"
    """The amount of time these events are kept"""

    count: "typing.Optional[int]"
    """The max number of events kept before removing older events"""

    @typing.no_type_check
    def __init__(self, kinds: "typing.Optional[typing.List[RetentionKind]]", time: "typing.Optional[int]", count: "typing.Optional[int]"):
        self.kinds = kinds
        self.time = time
        self.count = count

    def __str__(self):
        return "Retention(kinds={}, time={}, count={})".format(self.kinds, self.time, self.count)

    def __eq__(self, other):
        if self.kinds != other.kinds:
            return False
        if self.time != other.time:
            return False
        if self.count != other.count:
            return False
        return True

class _UniffiConverterTypeRetention(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Retention(
            kinds=_UniffiConverterOptionalSequenceTypeRetentionKind.read(buf),
            time=_UniffiConverterOptionalUInt64.read(buf),
            count=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeRetentionKind.check_lower(value.kinds)
        _UniffiConverterOptionalUInt64.check_lower(value.time)
        _UniffiConverterOptionalUInt64.check_lower(value.count)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeRetentionKind.write(value.kinds, buf)
        _UniffiConverterOptionalUInt64.write(value.time, buf)
        _UniffiConverterOptionalUInt64.write(value.count, buf)


class ShippingCost:
    """Delivery cost for shipping method as defined by the merchant in the product"""

    id: "str"
    """Id of the shipping method"""

    cost: "float"
    """Cost to use this shipping method"""

    @typing.no_type_check
    def __init__(self, id: "str", cost: "float"):
        self.id = id
        self.cost = cost

    def __str__(self):
        return "ShippingCost(id={}, cost={})".format(self.id, self.cost)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.cost != other.cost:
            return False
        return True

class _UniffiConverterTypeShippingCost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ShippingCost(
            id=_UniffiConverterString.read(buf),
            cost=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterDouble.check_lower(value.cost)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterDouble.write(value.cost, buf)


class StallData:
    """Payload for creating or updating stall"""

    id: "str"
    """UUID of the stall generated by merchant"""

    name: "str"
    """Stall name"""

    description: "typing.Optional[str]"
    """Stall description"""

    currency: "str"
    """Currency used"""

    shipping: "typing.List[ShippingMethod]"
    """Available shipping methods"""

    @typing.no_type_check
    def __init__(self, id: "str", name: "str", description: "typing.Optional[str]", currency: "str", shipping: "typing.List[ShippingMethod]"):
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping

    def __str__(self):
        return "StallData(id={}, name={}, description={}, currency={}, shipping={})".format(self.id, self.name, self.description, self.currency, self.shipping)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.currency != other.currency:
            return False
        if self.shipping != other.shipping:
            return False
        return True

class _UniffiConverterTypeStallData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StallData(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            currency=_UniffiConverterString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingMethod.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterSequenceTypeShippingMethod.check_lower(value.shipping)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterSequenceTypeShippingMethod.write(value.shipping, buf)





class Alphabet(enum.Enum):
    A = 1
    
    B = 2
    
    C = 3
    
    D = 4
    
    E = 5
    
    F = 6
    
    G = 7
    
    H = 8
    
    I = 9
    
    J = 10
    
    K = 11
    
    L = 12
    
    M = 13
    
    N = 14
    
    O = 15
    
    P = 16
    
    Q = 17
    
    R = 18
    
    S = 19
    
    T = 20
    
    U = 21
    
    V = 22
    
    W = 23
    
    X = 24
    
    Y = 25
    
    Z = 26
    


class _UniffiConverterTypeAlphabet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Alphabet.A
        if variant == 2:
            return Alphabet.B
        if variant == 3:
            return Alphabet.C
        if variant == 4:
            return Alphabet.D
        if variant == 5:
            return Alphabet.E
        if variant == 6:
            return Alphabet.F
        if variant == 7:
            return Alphabet.G
        if variant == 8:
            return Alphabet.H
        if variant == 9:
            return Alphabet.I
        if variant == 10:
            return Alphabet.J
        if variant == 11:
            return Alphabet.K
        if variant == 12:
            return Alphabet.L
        if variant == 13:
            return Alphabet.M
        if variant == 14:
            return Alphabet.N
        if variant == 15:
            return Alphabet.O
        if variant == 16:
            return Alphabet.P
        if variant == 17:
            return Alphabet.Q
        if variant == 18:
            return Alphabet.R
        if variant == 19:
            return Alphabet.S
        if variant == 20:
            return Alphabet.T
        if variant == 21:
            return Alphabet.U
        if variant == 22:
            return Alphabet.V
        if variant == 23:
            return Alphabet.W
        if variant == 24:
            return Alphabet.X
        if variant == 25:
            return Alphabet.Y
        if variant == 26:
            return Alphabet.Z
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Alphabet.A:
            return
        if value == Alphabet.B:
            return
        if value == Alphabet.C:
            return
        if value == Alphabet.D:
            return
        if value == Alphabet.E:
            return
        if value == Alphabet.F:
            return
        if value == Alphabet.G:
            return
        if value == Alphabet.H:
            return
        if value == Alphabet.I:
            return
        if value == Alphabet.J:
            return
        if value == Alphabet.K:
            return
        if value == Alphabet.L:
            return
        if value == Alphabet.M:
            return
        if value == Alphabet.N:
            return
        if value == Alphabet.O:
            return
        if value == Alphabet.P:
            return
        if value == Alphabet.Q:
            return
        if value == Alphabet.R:
            return
        if value == Alphabet.S:
            return
        if value == Alphabet.T:
            return
        if value == Alphabet.U:
            return
        if value == Alphabet.V:
            return
        if value == Alphabet.W:
            return
        if value == Alphabet.X:
            return
        if value == Alphabet.Y:
            return
        if value == Alphabet.Z:
            return

    @staticmethod
    def write(value, buf):
        if value == Alphabet.A:
            buf.write_i32(1)
        if value == Alphabet.B:
            buf.write_i32(2)
        if value == Alphabet.C:
            buf.write_i32(3)
        if value == Alphabet.D:
            buf.write_i32(4)
        if value == Alphabet.E:
            buf.write_i32(5)
        if value == Alphabet.F:
            buf.write_i32(6)
        if value == Alphabet.G:
            buf.write_i32(7)
        if value == Alphabet.H:
            buf.write_i32(8)
        if value == Alphabet.I:
            buf.write_i32(9)
        if value == Alphabet.J:
            buf.write_i32(10)
        if value == Alphabet.K:
            buf.write_i32(11)
        if value == Alphabet.L:
            buf.write_i32(12)
        if value == Alphabet.M:
            buf.write_i32(13)
        if value == Alphabet.N:
            buf.write_i32(14)
        if value == Alphabet.O:
            buf.write_i32(15)
        if value == Alphabet.P:
            buf.write_i32(16)
        if value == Alphabet.Q:
            buf.write_i32(17)
        if value == Alphabet.R:
            buf.write_i32(18)
        if value == Alphabet.S:
            buf.write_i32(19)
        if value == Alphabet.T:
            buf.write_i32(20)
        if value == Alphabet.U:
            buf.write_i32(21)
        if value == Alphabet.V:
            buf.write_i32(22)
        if value == Alphabet.W:
            buf.write_i32(23)
        if value == Alphabet.X:
            buf.write_i32(24)
        if value == Alphabet.Y:
            buf.write_i32(25)
        if value == Alphabet.Z:
            buf.write_i32(26)







class ClientMessage:
    """Messages sent by clients, received by relays"""

    def __init__(self):
        raise RuntimeError("ClientMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.EVENT_MSG(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_event_msg():
                return False
            if self.event != other.event:
                return False
            return True
    class REQ:
        subscription_id: "str"
        filters: "typing.List[Filter]"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[Filter]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.REQ(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_req():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class COUNT:
        subscription_id: "str"
        filters: "typing.List[Filter]"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[Filter]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.COUNT(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class CLOSE:
        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class AUTH:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.AUTH(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.event != other.event:
                return False
            return True
    class NEG_OPEN:
        """Negentropy Open"""

        subscription_id: "str"
        filter: "Filter"
        id_size: "int"
        """ID size (MUST be between 8 and 32, inclusive)"""

        initial_message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filter: "Filter", id_size: "int", initial_message: "str"):
            
            self.subscription_id = subscription_id
            self.filter = filter
            self.id_size = id_size
            self.initial_message = initial_message
            

        def __str__(self):
            return "ClientMessage.NEG_OPEN(subscription_id={}, filter={}, id_size={}, initial_message={})".format(self.subscription_id, self.filter, self.id_size, self.initial_message)

        def __eq__(self, other):
            if not other.is_neg_open():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filter != other.filter:
                return False
            if self.id_size != other.id_size:
                return False
            if self.initial_message != other.initial_message:
                return False
            return True
    class NEG_MSG:
        """Negentropy Message"""

        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "ClientMessage.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_neg_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class NEG_CLOSE:
        """Negentropy Close"""

        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.NEG_CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_neg_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_event_msg(self) -> bool:
        return isinstance(self, ClientMessage.EVENT_MSG)
    def is_req(self) -> bool:
        return isinstance(self, ClientMessage.REQ)
    def is_count(self) -> bool:
        return isinstance(self, ClientMessage.COUNT)
    def is_close(self) -> bool:
        return isinstance(self, ClientMessage.CLOSE)
    def is_auth(self) -> bool:
        return isinstance(self, ClientMessage.AUTH)
    def is_neg_open(self) -> bool:
        return isinstance(self, ClientMessage.NEG_OPEN)
    def is_neg_msg(self) -> bool:
        return isinstance(self, ClientMessage.NEG_MSG)
    def is_neg_close(self) -> bool:
        return isinstance(self, ClientMessage.NEG_CLOSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientMessage.EVENT_MSG = type("ClientMessage.EVENT_MSG", (ClientMessage.EVENT_MSG, ClientMessage,), {})  # type: ignore
ClientMessage.REQ = type("ClientMessage.REQ", (ClientMessage.REQ, ClientMessage,), {})  # type: ignore
ClientMessage.COUNT = type("ClientMessage.COUNT", (ClientMessage.COUNT, ClientMessage,), {})  # type: ignore
ClientMessage.CLOSE = type("ClientMessage.CLOSE", (ClientMessage.CLOSE, ClientMessage,), {})  # type: ignore
ClientMessage.AUTH = type("ClientMessage.AUTH", (ClientMessage.AUTH, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_OPEN = type("ClientMessage.NEG_OPEN", (ClientMessage.NEG_OPEN, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_MSG = type("ClientMessage.NEG_MSG", (ClientMessage.NEG_MSG, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_CLOSE = type("ClientMessage.NEG_CLOSE", (ClientMessage.NEG_CLOSE, ClientMessage,), {})  # type: ignore




class _UniffiConverterTypeClientMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientMessage.EVENT_MSG(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return ClientMessage.REQ(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeFilter.read(buf),
            )
        if variant == 3:
            return ClientMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeFilter.read(buf),
            )
        if variant == 4:
            return ClientMessage.CLOSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ClientMessage.AUTH(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 6:
            return ClientMessage.NEG_OPEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeFilter.read(buf),
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ClientMessage.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ClientMessage.NEG_CLOSE(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_event_msg():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_req():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterSequenceTypeFilter.check_lower(value.filters)
            return
        if value.is_count():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterSequenceTypeFilter.check_lower(value.filters)
            return
        if value.is_close():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_auth():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_neg_open():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeFilter.check_lower(value.filter)
            _UniffiConverterUInt8.check_lower(value.id_size)
            _UniffiConverterString.check_lower(value.initial_message)
            return
        if value.is_neg_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_neg_close():
            _UniffiConverterString.check_lower(value.subscription_id)
            return

    @staticmethod
    def write(value, buf):
        if value.is_event_msg():
            buf.write_i32(1)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_req():
            buf.write_i32(2)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceTypeFilter.write(value.filters, buf)
        if value.is_count():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceTypeFilter.write(value.filters, buf)
        if value.is_close():
            buf.write_i32(4)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_auth():
            buf.write_i32(5)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_neg_open():
            buf.write_i32(6)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeFilter.write(value.filter, buf)
            _UniffiConverterUInt8.write(value.id_size, buf)
            _UniffiConverterString.write(value.initial_message, buf)
        if value.is_neg_msg():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_neg_close():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)







class DataVendingMachineStatus(enum.Enum):
    PAYMENT_REQUIRED = 1
    
    PROCESSING = 2
    
    ERROR = 3
    
    SUCCESS = 4
    
    PARTIAL = 5
    


class _UniffiConverterTypeDataVendingMachineStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DataVendingMachineStatus.PAYMENT_REQUIRED
        if variant == 2:
            return DataVendingMachineStatus.PROCESSING
        if variant == 3:
            return DataVendingMachineStatus.ERROR
        if variant == 4:
            return DataVendingMachineStatus.SUCCESS
        if variant == 5:
            return DataVendingMachineStatus.PARTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            return
        if value == DataVendingMachineStatus.PROCESSING:
            return
        if value == DataVendingMachineStatus.ERROR:
            return
        if value == DataVendingMachineStatus.SUCCESS:
            return
        if value == DataVendingMachineStatus.PARTIAL:
            return

    @staticmethod
    def write(value, buf):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            buf.write_i32(1)
        if value == DataVendingMachineStatus.PROCESSING:
            buf.write_i32(2)
        if value == DataVendingMachineStatus.ERROR:
            buf.write_i32(3)
        if value == DataVendingMachineStatus.SUCCESS:
            buf.write_i32(4)
        if value == DataVendingMachineStatus.PARTIAL:
            buf.write_i32(5)







class EncryptedSecretKeyVersion(enum.Enum):
    """Encrypted Secret Key version (NIP49)"""

    V2 = 1
    


class _UniffiConverterTypeEncryptedSecretKeyVersion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EncryptedSecretKeyVersion.V2
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == EncryptedSecretKeyVersion.V2:
            return

    @staticmethod
    def write(value, buf):
        if value == EncryptedSecretKeyVersion.V2:
            buf.write_i32(1)







class ErrorCode(enum.Enum):
    """NIP47 Response Error codes"""

    RATE_LIMITED = 1
    """The client is sending commands too fast."""

    
    NOT_IMPLEMENTED = 2
    """The command is not known of is intentionally not implemented"""

    
    INSUFFICIENT_BALANCE = 3
    """The wallet does not have enough funds to cover a fee reserve or the payment amount"""

    
    PAYMENT_FAILED = 4
    """The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar."""

    
    NOT_FOUND = 5
    """The invoice could not be found by the given parameters."""

    
    QUOTA_EXCEEDED = 6
    """The wallet has exceeded its spending quota"""

    
    RESTRICTED = 7
    """This public key is not allowed to do this operation"""

    
    UNAUTHORIZED = 8
    """This public key has no wallet connected"""

    
    INTERNAL = 9
    """An internal error"""

    
    OTHER = 10
    """Other error"""

    


class _UniffiConverterTypeErrorCode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ErrorCode.RATE_LIMITED
        if variant == 2:
            return ErrorCode.NOT_IMPLEMENTED
        if variant == 3:
            return ErrorCode.INSUFFICIENT_BALANCE
        if variant == 4:
            return ErrorCode.PAYMENT_FAILED
        if variant == 5:
            return ErrorCode.NOT_FOUND
        if variant == 6:
            return ErrorCode.QUOTA_EXCEEDED
        if variant == 7:
            return ErrorCode.RESTRICTED
        if variant == 8:
            return ErrorCode.UNAUTHORIZED
        if variant == 9:
            return ErrorCode.INTERNAL
        if variant == 10:
            return ErrorCode.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ErrorCode.RATE_LIMITED:
            return
        if value == ErrorCode.NOT_IMPLEMENTED:
            return
        if value == ErrorCode.INSUFFICIENT_BALANCE:
            return
        if value == ErrorCode.PAYMENT_FAILED:
            return
        if value == ErrorCode.NOT_FOUND:
            return
        if value == ErrorCode.QUOTA_EXCEEDED:
            return
        if value == ErrorCode.RESTRICTED:
            return
        if value == ErrorCode.UNAUTHORIZED:
            return
        if value == ErrorCode.INTERNAL:
            return
        if value == ErrorCode.OTHER:
            return

    @staticmethod
    def write(value, buf):
        if value == ErrorCode.RATE_LIMITED:
            buf.write_i32(1)
        if value == ErrorCode.NOT_IMPLEMENTED:
            buf.write_i32(2)
        if value == ErrorCode.INSUFFICIENT_BALANCE:
            buf.write_i32(3)
        if value == ErrorCode.PAYMENT_FAILED:
            buf.write_i32(4)
        if value == ErrorCode.NOT_FOUND:
            buf.write_i32(5)
        if value == ErrorCode.QUOTA_EXCEEDED:
            buf.write_i32(6)
        if value == ErrorCode.RESTRICTED:
            buf.write_i32(7)
        if value == ErrorCode.UNAUTHORIZED:
            buf.write_i32(8)
        if value == ErrorCode.INTERNAL:
            buf.write_i32(9)
        if value == ErrorCode.OTHER:
            buf.write_i32(10)







class ExternalIdentity(enum.Enum):
    """Supported external identity providers"""

    GIT_HUB = 1
    """github.com"""

    
    TWITTER = 2
    """twitter.com"""

    
    MASTODON = 3
    """mastodon.social"""

    
    TELEGRAM = 4
    """telegram.org"""

    


class _UniffiConverterTypeExternalIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalIdentity.GIT_HUB
        if variant == 2:
            return ExternalIdentity.TWITTER
        if variant == 3:
            return ExternalIdentity.MASTODON
        if variant == 4:
            return ExternalIdentity.TELEGRAM
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ExternalIdentity.GIT_HUB:
            return
        if value == ExternalIdentity.TWITTER:
            return
        if value == ExternalIdentity.MASTODON:
            return
        if value == ExternalIdentity.TELEGRAM:
            return

    @staticmethod
    def write(value, buf):
        if value == ExternalIdentity.GIT_HUB:
            buf.write_i32(1)
        if value == ExternalIdentity.TWITTER:
            buf.write_i32(2)
        if value == ExternalIdentity.MASTODON:
            buf.write_i32(3)
        if value == ExternalIdentity.TELEGRAM:
            buf.write_i32(4)







class HttpMethod(enum.Enum):
    GET = 1
    
    POST = 2
    
    PUT = 3
    
    PATCH = 4
    


class _UniffiConverterTypeHttpMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HttpMethod.GET
        if variant == 2:
            return HttpMethod.POST
        if variant == 3:
            return HttpMethod.PUT
        if variant == 4:
            return HttpMethod.PATCH
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == HttpMethod.GET:
            return
        if value == HttpMethod.POST:
            return
        if value == HttpMethod.PUT:
            return
        if value == HttpMethod.PATCH:
            return

    @staticmethod
    def write(value, buf):
        if value == HttpMethod.GET:
            buf.write_i32(1)
        if value == HttpMethod.POST:
            buf.write_i32(2)
        if value == HttpMethod.PUT:
            buf.write_i32(3)
        if value == HttpMethod.PATCH:
            buf.write_i32(4)







class JsonValue:
    def __init__(self):
        raise RuntimeError("JsonValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL:
        bool: "bool"

        @typing.no_type_check
        def __init__(self,bool: "bool"):
            
            self.bool = bool
            

        def __str__(self):
            return "JsonValue.BOOL(bool={})".format(self.bool)

        def __eq__(self, other):
            if not other.is_bool():
                return False
            if self.bool != other.bool:
                return False
            return True
    class NUMBER_POS_INT:
        number: "int"

        @typing.no_type_check
        def __init__(self,number: "int"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_POS_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_pos_int():
                return False
            if self.number != other.number:
                return False
            return True
    class NUMBER_NEG_INT:
        number: "int"

        @typing.no_type_check
        def __init__(self,number: "int"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_NEG_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_neg_int():
                return False
            if self.number != other.number:
                return False
            return True
    class NUMBER_FLOAT:
        number: "float"

        @typing.no_type_check
        def __init__(self,number: "float"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_FLOAT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_float():
                return False
            if self.number != other.number:
                return False
            return True
    class STR:
        s: "str"

        @typing.no_type_check
        def __init__(self,s: "str"):
            
            self.s = s
            

        def __str__(self):
            return "JsonValue.STR(s={})".format(self.s)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.s != other.s:
                return False
            return True
    class ARRAY:
        array: "typing.List[JsonValue]"

        @typing.no_type_check
        def __init__(self,array: "typing.List[JsonValue]"):
            
            self.array = array
            

        def __str__(self):
            return "JsonValue.ARRAY(array={})".format(self.array)

        def __eq__(self, other):
            if not other.is_array():
                return False
            if self.array != other.array:
                return False
            return True
    class OBJECT:
        map: "dict"

        @typing.no_type_check
        def __init__(self,map: "dict"):
            
            self.map = map
            

        def __str__(self):
            return "JsonValue.OBJECT(map={})".format(self.map)

        def __eq__(self, other):
            if not other.is_object():
                return False
            if self.map != other.map:
                return False
            return True
    class NULL:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "JsonValue.NULL()".format()

        def __eq__(self, other):
            if not other.is_null():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool(self) -> bool:
        return isinstance(self, JsonValue.BOOL)
    def is_number_pos_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_POS_INT)
    def is_number_neg_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_NEG_INT)
    def is_number_float(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_FLOAT)
    def is_str(self) -> bool:
        return isinstance(self, JsonValue.STR)
    def is_array(self) -> bool:
        return isinstance(self, JsonValue.ARRAY)
    def is_object(self) -> bool:
        return isinstance(self, JsonValue.OBJECT)
    def is_null(self) -> bool:
        return isinstance(self, JsonValue.NULL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
JsonValue.BOOL = type("JsonValue.BOOL", (JsonValue.BOOL, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_POS_INT = type("JsonValue.NUMBER_POS_INT", (JsonValue.NUMBER_POS_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_NEG_INT = type("JsonValue.NUMBER_NEG_INT", (JsonValue.NUMBER_NEG_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_FLOAT = type("JsonValue.NUMBER_FLOAT", (JsonValue.NUMBER_FLOAT, JsonValue,), {})  # type: ignore
JsonValue.STR = type("JsonValue.STR", (JsonValue.STR, JsonValue,), {})  # type: ignore
JsonValue.ARRAY = type("JsonValue.ARRAY", (JsonValue.ARRAY, JsonValue,), {})  # type: ignore
JsonValue.OBJECT = type("JsonValue.OBJECT", (JsonValue.OBJECT, JsonValue,), {})  # type: ignore
JsonValue.NULL = type("JsonValue.NULL", (JsonValue.NULL, JsonValue,), {})  # type: ignore




class _UniffiConverterTypeJsonValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JsonValue.BOOL(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return JsonValue.NUMBER_POS_INT(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return JsonValue.NUMBER_NEG_INT(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 4:
            return JsonValue.NUMBER_FLOAT(
                _UniffiConverterDouble.read(buf),
            )
        if variant == 5:
            return JsonValue.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return JsonValue.ARRAY(
                _UniffiConverterSequenceTypeJsonValue.read(buf),
            )
        if variant == 7:
            return JsonValue.OBJECT(
                _UniffiConverterMapStringTypeJsonValue.read(buf),
            )
        if variant == 8:
            return JsonValue.NULL(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bool():
            _UniffiConverterBool.check_lower(value.bool)
            return
        if value.is_number_pos_int():
            _UniffiConverterUInt64.check_lower(value.number)
            return
        if value.is_number_neg_int():
            _UniffiConverterInt64.check_lower(value.number)
            return
        if value.is_number_float():
            _UniffiConverterDouble.check_lower(value.number)
            return
        if value.is_str():
            _UniffiConverterString.check_lower(value.s)
            return
        if value.is_array():
            _UniffiConverterSequenceTypeJsonValue.check_lower(value.array)
            return
        if value.is_object():
            _UniffiConverterMapStringTypeJsonValue.check_lower(value.map)
            return
        if value.is_null():
            return

    @staticmethod
    def write(value, buf):
        if value.is_bool():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.bool, buf)
        if value.is_number_pos_int():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.number, buf)
        if value.is_number_neg_int():
            buf.write_i32(3)
            _UniffiConverterInt64.write(value.number, buf)
        if value.is_number_float():
            buf.write_i32(4)
            _UniffiConverterDouble.write(value.number, buf)
        if value.is_str():
            buf.write_i32(5)
            _UniffiConverterString.write(value.s, buf)
        if value.is_array():
            buf.write_i32(6)
            _UniffiConverterSequenceTypeJsonValue.write(value.array, buf)
        if value.is_object():
            buf.write_i32(7)
            _UniffiConverterMapStringTypeJsonValue.write(value.map, buf)
        if value.is_null():
            buf.write_i32(8)







class KeySecurity(enum.Enum):
    """Key security"""

    WEAK = 1
    """The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)"""

    
    MEDIUM = 2
    """The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)"""

    
    UNKNOWN = 3
    """The client does not track this data"""

    


class _UniffiConverterTypeKeySecurity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeySecurity.WEAK
        if variant == 2:
            return KeySecurity.MEDIUM
        if variant == 3:
            return KeySecurity.UNKNOWN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeySecurity.WEAK:
            return
        if value == KeySecurity.MEDIUM:
            return
        if value == KeySecurity.UNKNOWN:
            return

    @staticmethod
    def write(value, buf):
        if value == KeySecurity.WEAK:
            buf.write_i32(1)
        if value == KeySecurity.MEDIUM:
            buf.write_i32(2)
        if value == KeySecurity.UNKNOWN:
            buf.write_i32(3)







class LiveEventMarker(enum.Enum):
    """Live Event Marker"""

    HOST = 1
    """Host"""

    
    SPEAKER = 2
    """Speaker"""

    
    PARTICIPANT = 3
    """Participant"""

    


class _UniffiConverterTypeLiveEventMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventMarker.HOST
        if variant == 2:
            return LiveEventMarker.SPEAKER
        if variant == 3:
            return LiveEventMarker.PARTICIPANT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LiveEventMarker.HOST:
            return
        if value == LiveEventMarker.SPEAKER:
            return
        if value == LiveEventMarker.PARTICIPANT:
            return

    @staticmethod
    def write(value, buf):
        if value == LiveEventMarker.HOST:
            buf.write_i32(1)
        if value == LiveEventMarker.SPEAKER:
            buf.write_i32(2)
        if value == LiveEventMarker.PARTICIPANT:
            buf.write_i32(3)







class LiveEventStatus:
    def __init__(self):
        raise RuntimeError("LiveEventStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PLANNED:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.PLANNED()".format()

        def __eq__(self, other):
            if not other.is_planned():
                return False
            return True
    class LIVE:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.LIVE()".format()

        def __eq__(self, other):
            if not other.is_live():
                return False
            return True
    class ENDED:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.ENDED()".format()

        def __eq__(self, other):
            if not other.is_ended():
                return False
            return True
    class CUSTOM:
        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "LiveEventStatus.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_planned(self) -> bool:
        return isinstance(self, LiveEventStatus.PLANNED)
    def is_live(self) -> bool:
        return isinstance(self, LiveEventStatus.LIVE)
    def is_ended(self) -> bool:
        return isinstance(self, LiveEventStatus.ENDED)
    def is_custom(self) -> bool:
        return isinstance(self, LiveEventStatus.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LiveEventStatus.PLANNED = type("LiveEventStatus.PLANNED", (LiveEventStatus.PLANNED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.LIVE = type("LiveEventStatus.LIVE", (LiveEventStatus.LIVE, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.ENDED = type("LiveEventStatus.ENDED", (LiveEventStatus.ENDED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.CUSTOM = type("LiveEventStatus.CUSTOM", (LiveEventStatus.CUSTOM, LiveEventStatus,), {})  # type: ignore




class _UniffiConverterTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventStatus.PLANNED(
            )
        if variant == 2:
            return LiveEventStatus.LIVE(
            )
        if variant == 3:
            return LiveEventStatus.ENDED(
            )
        if variant == 4:
            return LiveEventStatus.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_planned():
            return
        if value.is_live():
            return
        if value.is_ended():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_planned():
            buf.write_i32(1)
        if value.is_live():
            buf.write_i32(2)
        if value.is_ended():
            buf.write_i32(3)
        if value.is_custom():
            buf.write_i32(4)
            _UniffiConverterString.write(value.custom, buf)







class Marker:
    """Marker"""

    def __init__(self):
        raise RuntimeError("Marker cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ROOT:
        """Root"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Marker.ROOT()".format()

        def __eq__(self, other):
            if not other.is_root():
                return False
            return True
    class REPLY:
        """Reply"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Marker.REPLY()".format()

        def __eq__(self, other):
            if not other.is_reply():
                return False
            return True
    class CUSTOM:
        """Custom"""

        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "Marker.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_root(self) -> bool:
        return isinstance(self, Marker.ROOT)
    def is_reply(self) -> bool:
        return isinstance(self, Marker.REPLY)
    def is_custom(self) -> bool:
        return isinstance(self, Marker.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Marker.ROOT = type("Marker.ROOT", (Marker.ROOT, Marker,), {})  # type: ignore
Marker.REPLY = type("Marker.REPLY", (Marker.REPLY, Marker,), {})  # type: ignore
Marker.CUSTOM = type("Marker.CUSTOM", (Marker.CUSTOM, Marker,), {})  # type: ignore




class _UniffiConverterTypeMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Marker.ROOT(
            )
        if variant == 2:
            return Marker.REPLY(
            )
        if variant == 3:
            return Marker.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_root():
            return
        if value.is_reply():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_root():
            buf.write_i32(1)
        if value.is_reply():
            buf.write_i32(2)
        if value.is_custom():
            buf.write_i32(3)
            _UniffiConverterString.write(value.custom, buf)







class Method(enum.Enum):
    """Method"""

    PAY_INVOICE = 1
    """Pay Invoice"""

    
    MULTI_PAY_INVOICE = 2
    """Multi Pay Invoice"""

    
    PAY_KEYSEND = 3
    """Pay Keysend"""

    
    MULTI_PAY_KEYSEND = 4
    """Multi Pay Keysend"""

    
    MAKE_INVOICE = 5
    """Make Invoice"""

    
    LOOKUP_INVOICE = 6
    """Lookup Invoice"""

    
    LIST_TRANSACTIONS = 7
    """List transactions"""

    
    GET_BALANCE = 8
    """Get Balance"""

    
    GET_INFO = 9
    """Get Info"""

    


class _UniffiConverterTypeMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Method.PAY_INVOICE
        if variant == 2:
            return Method.MULTI_PAY_INVOICE
        if variant == 3:
            return Method.PAY_KEYSEND
        if variant == 4:
            return Method.MULTI_PAY_KEYSEND
        if variant == 5:
            return Method.MAKE_INVOICE
        if variant == 6:
            return Method.LOOKUP_INVOICE
        if variant == 7:
            return Method.LIST_TRANSACTIONS
        if variant == 8:
            return Method.GET_BALANCE
        if variant == 9:
            return Method.GET_INFO
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Method.PAY_INVOICE:
            return
        if value == Method.MULTI_PAY_INVOICE:
            return
        if value == Method.PAY_KEYSEND:
            return
        if value == Method.MULTI_PAY_KEYSEND:
            return
        if value == Method.MAKE_INVOICE:
            return
        if value == Method.LOOKUP_INVOICE:
            return
        if value == Method.LIST_TRANSACTIONS:
            return
        if value == Method.GET_BALANCE:
            return
        if value == Method.GET_INFO:
            return

    @staticmethod
    def write(value, buf):
        if value == Method.PAY_INVOICE:
            buf.write_i32(1)
        if value == Method.MULTI_PAY_INVOICE:
            buf.write_i32(2)
        if value == Method.PAY_KEYSEND:
            buf.write_i32(3)
        if value == Method.MULTI_PAY_KEYSEND:
            buf.write_i32(4)
        if value == Method.MAKE_INVOICE:
            buf.write_i32(5)
        if value == Method.LOOKUP_INVOICE:
            buf.write_i32(6)
        if value == Method.LIST_TRANSACTIONS:
            buf.write_i32(7)
        if value == Method.GET_BALANCE:
            buf.write_i32(8)
        if value == Method.GET_INFO:
            buf.write_i32(9)







class Nip19Enum:
    """
    A representation any `fNIP19` bech32 nostr object. Useful for decoding
    `NIP19` bech32 strings without necessarily knowing what you're decoding
    ahead of time.
    """

    def __init__(self):
        raise RuntimeError("Nip19Enum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECRET:
        """nsec"""

        nsec: "SecretKey"

        @typing.no_type_check
        def __init__(self,nsec: "SecretKey"):
            
            self.nsec = nsec
            

        def __str__(self):
            return "Nip19Enum.SECRET(nsec={})".format(self.nsec)

        def __eq__(self, other):
            if not other.is_secret():
                return False
            if self.nsec != other.nsec:
                return False
            return True
    class ENCRYPTED_SECRET:
        """Encrypted Secret Key"""

        ncryptsec: "EncryptedSecretKey"

        @typing.no_type_check
        def __init__(self,ncryptsec: "EncryptedSecretKey"):
            
            self.ncryptsec = ncryptsec
            

        def __str__(self):
            return "Nip19Enum.ENCRYPTED_SECRET(ncryptsec={})".format(self.ncryptsec)

        def __eq__(self, other):
            if not other.is_encrypted_secret():
                return False
            if self.ncryptsec != other.ncryptsec:
                return False
            return True
    class PUBKEY:
        """npub"""

        npub: "PublicKey"

        @typing.no_type_check
        def __init__(self,npub: "PublicKey"):
            
            self.npub = npub
            

        def __str__(self):
            return "Nip19Enum.PUBKEY(npub={})".format(self.npub)

        def __eq__(self, other):
            if not other.is_pubkey():
                return False
            if self.npub != other.npub:
                return False
            return True
    class PROFILE:
        """nprofile"""

        nprofile: "Nip19Profile"

        @typing.no_type_check
        def __init__(self,nprofile: "Nip19Profile"):
            
            self.nprofile = nprofile
            

        def __str__(self):
            return "Nip19Enum.PROFILE(nprofile={})".format(self.nprofile)

        def __eq__(self, other):
            if not other.is_profile():
                return False
            if self.nprofile != other.nprofile:
                return False
            return True
    class NOTE:
        """note"""

        event_id: "EventId"

        @typing.no_type_check
        def __init__(self,event_id: "EventId"):
            
            self.event_id = event_id
            

        def __str__(self):
            return "Nip19Enum.NOTE(event_id={})".format(self.event_id)

        def __eq__(self, other):
            if not other.is_note():
                return False
            if self.event_id != other.event_id:
                return False
            return True
    class EVENT:
        """nevent"""

        event: "Nip19Event"

        @typing.no_type_check
        def __init__(self,event: "Nip19Event"):
            
            self.event = event
            

        def __str__(self):
            return "Nip19Enum.EVENT(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_event():
                return False
            if self.event != other.event:
                return False
            return True
    class COORD:
        """naddr"""

        coordinate: "Coordinate"

        @typing.no_type_check
        def __init__(self,coordinate: "Coordinate"):
            
            self.coordinate = coordinate
            

        def __str__(self):
            return "Nip19Enum.COORD(coordinate={})".format(self.coordinate)

        def __eq__(self, other):
            if not other.is_coord():
                return False
            if self.coordinate != other.coordinate:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secret(self) -> bool:
        return isinstance(self, Nip19Enum.SECRET)
    def is_encrypted_secret(self) -> bool:
        return isinstance(self, Nip19Enum.ENCRYPTED_SECRET)
    def is_pubkey(self) -> bool:
        return isinstance(self, Nip19Enum.PUBKEY)
    def is_profile(self) -> bool:
        return isinstance(self, Nip19Enum.PROFILE)
    def is_note(self) -> bool:
        return isinstance(self, Nip19Enum.NOTE)
    def is_event(self) -> bool:
        return isinstance(self, Nip19Enum.EVENT)
    def is_coord(self) -> bool:
        return isinstance(self, Nip19Enum.COORD)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Nip19Enum.SECRET = type("Nip19Enum.SECRET", (Nip19Enum.SECRET, Nip19Enum,), {})  # type: ignore
Nip19Enum.ENCRYPTED_SECRET = type("Nip19Enum.ENCRYPTED_SECRET", (Nip19Enum.ENCRYPTED_SECRET, Nip19Enum,), {})  # type: ignore
Nip19Enum.PUBKEY = type("Nip19Enum.PUBKEY", (Nip19Enum.PUBKEY, Nip19Enum,), {})  # type: ignore
Nip19Enum.PROFILE = type("Nip19Enum.PROFILE", (Nip19Enum.PROFILE, Nip19Enum,), {})  # type: ignore
Nip19Enum.NOTE = type("Nip19Enum.NOTE", (Nip19Enum.NOTE, Nip19Enum,), {})  # type: ignore
Nip19Enum.EVENT = type("Nip19Enum.EVENT", (Nip19Enum.EVENT, Nip19Enum,), {})  # type: ignore
Nip19Enum.COORD = type("Nip19Enum.COORD", (Nip19Enum.COORD, Nip19Enum,), {})  # type: ignore




class _UniffiConverterTypeNip19Enum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip19Enum.SECRET(
                _UniffiConverterTypeSecretKey.read(buf),
            )
        if variant == 2:
            return Nip19Enum.ENCRYPTED_SECRET(
                _UniffiConverterTypeEncryptedSecretKey.read(buf),
            )
        if variant == 3:
            return Nip19Enum.PUBKEY(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 4:
            return Nip19Enum.PROFILE(
                _UniffiConverterTypeNip19Profile.read(buf),
            )
        if variant == 5:
            return Nip19Enum.NOTE(
                _UniffiConverterTypeEventId.read(buf),
            )
        if variant == 6:
            return Nip19Enum.EVENT(
                _UniffiConverterTypeNip19Event.read(buf),
            )
        if variant == 7:
            return Nip19Enum.COORD(
                _UniffiConverterTypeCoordinate.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_secret():
            _UniffiConverterTypeSecretKey.check_lower(value.nsec)
            return
        if value.is_encrypted_secret():
            _UniffiConverterTypeEncryptedSecretKey.check_lower(value.ncryptsec)
            return
        if value.is_pubkey():
            _UniffiConverterTypePublicKey.check_lower(value.npub)
            return
        if value.is_profile():
            _UniffiConverterTypeNip19Profile.check_lower(value.nprofile)
            return
        if value.is_note():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            return
        if value.is_event():
            _UniffiConverterTypeNip19Event.check_lower(value.event)
            return
        if value.is_coord():
            _UniffiConverterTypeCoordinate.check_lower(value.coordinate)
            return

    @staticmethod
    def write(value, buf):
        if value.is_secret():
            buf.write_i32(1)
            _UniffiConverterTypeSecretKey.write(value.nsec, buf)
        if value.is_encrypted_secret():
            buf.write_i32(2)
            _UniffiConverterTypeEncryptedSecretKey.write(value.ncryptsec, buf)
        if value.is_pubkey():
            buf.write_i32(3)
            _UniffiConverterTypePublicKey.write(value.npub, buf)
        if value.is_profile():
            buf.write_i32(4)
            _UniffiConverterTypeNip19Profile.write(value.nprofile, buf)
        if value.is_note():
            buf.write_i32(5)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
        if value.is_event():
            buf.write_i32(6)
            _UniffiConverterTypeNip19Event.write(value.event, buf)
        if value.is_coord():
            buf.write_i32(7)
            _UniffiConverterTypeCoordinate.write(value.coordinate, buf)







class Nip21Enum:
    """
    A representation any `NIP21` object. Useful for decoding
    `NIP21` strings without necessarily knowing what you're decoding
    ahead of time.
    """

    def __init__(self):
        raise RuntimeError("Nip21Enum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PUBKEY:
        """nostr::npub"""

        public_key: "PublicKey"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey"):
            
            self.public_key = public_key
            

        def __str__(self):
            return "Nip21Enum.PUBKEY(public_key={})".format(self.public_key)

        def __eq__(self, other):
            if not other.is_pubkey():
                return False
            if self.public_key != other.public_key:
                return False
            return True
    class PROFILE:
        """nostr::nprofile"""

        profile: "Nip19Profile"

        @typing.no_type_check
        def __init__(self,profile: "Nip19Profile"):
            
            self.profile = profile
            

        def __str__(self):
            return "Nip21Enum.PROFILE(profile={})".format(self.profile)

        def __eq__(self, other):
            if not other.is_profile():
                return False
            if self.profile != other.profile:
                return False
            return True
    class NOTE:
        """nostr::note (EventId)"""

        event_id: "EventId"

        @typing.no_type_check
        def __init__(self,event_id: "EventId"):
            
            self.event_id = event_id
            

        def __str__(self):
            return "Nip21Enum.NOTE(event_id={})".format(self.event_id)

        def __eq__(self, other):
            if not other.is_note():
                return False
            if self.event_id != other.event_id:
                return False
            return True
    class EVENT:
        """nostr::nevent"""

        event: "Nip19Event"

        @typing.no_type_check
        def __init__(self,event: "Nip19Event"):
            
            self.event = event
            

        def __str__(self):
            return "Nip21Enum.EVENT(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_event():
                return False
            if self.event != other.event:
                return False
            return True
    class COORD:
        """nostr::naddr"""

        coordinate: "Coordinate"

        @typing.no_type_check
        def __init__(self,coordinate: "Coordinate"):
            
            self.coordinate = coordinate
            

        def __str__(self):
            return "Nip21Enum.COORD(coordinate={})".format(self.coordinate)

        def __eq__(self, other):
            if not other.is_coord():
                return False
            if self.coordinate != other.coordinate:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pubkey(self) -> bool:
        return isinstance(self, Nip21Enum.PUBKEY)
    def is_profile(self) -> bool:
        return isinstance(self, Nip21Enum.PROFILE)
    def is_note(self) -> bool:
        return isinstance(self, Nip21Enum.NOTE)
    def is_event(self) -> bool:
        return isinstance(self, Nip21Enum.EVENT)
    def is_coord(self) -> bool:
        return isinstance(self, Nip21Enum.COORD)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Nip21Enum.PUBKEY = type("Nip21Enum.PUBKEY", (Nip21Enum.PUBKEY, Nip21Enum,), {})  # type: ignore
Nip21Enum.PROFILE = type("Nip21Enum.PROFILE", (Nip21Enum.PROFILE, Nip21Enum,), {})  # type: ignore
Nip21Enum.NOTE = type("Nip21Enum.NOTE", (Nip21Enum.NOTE, Nip21Enum,), {})  # type: ignore
Nip21Enum.EVENT = type("Nip21Enum.EVENT", (Nip21Enum.EVENT, Nip21Enum,), {})  # type: ignore
Nip21Enum.COORD = type("Nip21Enum.COORD", (Nip21Enum.COORD, Nip21Enum,), {})  # type: ignore




class _UniffiConverterTypeNip21Enum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip21Enum.PUBKEY(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 2:
            return Nip21Enum.PROFILE(
                _UniffiConverterTypeNip19Profile.read(buf),
            )
        if variant == 3:
            return Nip21Enum.NOTE(
                _UniffiConverterTypeEventId.read(buf),
            )
        if variant == 4:
            return Nip21Enum.EVENT(
                _UniffiConverterTypeNip19Event.read(buf),
            )
        if variant == 5:
            return Nip21Enum.COORD(
                _UniffiConverterTypeCoordinate.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pubkey():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            return
        if value.is_profile():
            _UniffiConverterTypeNip19Profile.check_lower(value.profile)
            return
        if value.is_note():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            return
        if value.is_event():
            _UniffiConverterTypeNip19Event.check_lower(value.event)
            return
        if value.is_coord():
            _UniffiConverterTypeCoordinate.check_lower(value.coordinate)
            return

    @staticmethod
    def write(value, buf):
        if value.is_pubkey():
            buf.write_i32(1)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
        if value.is_profile():
            buf.write_i32(2)
            _UniffiConverterTypeNip19Profile.write(value.profile, buf)
        if value.is_note():
            buf.write_i32(3)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
        if value.is_event():
            buf.write_i32(4)
            _UniffiConverterTypeNip19Event.write(value.event, buf)
        if value.is_coord():
            buf.write_i32(5)
            _UniffiConverterTypeCoordinate.write(value.coordinate, buf)







class Nip44Version(enum.Enum):
    """NIP44 Version"""

    DEPRECATED = 1
    """V1 (deprecated)"""

    
    V2 = 2
    """V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64"""

    


class _UniffiConverterTypeNip44Version(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip44Version.DEPRECATED
        if variant == 2:
            return Nip44Version.V2
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Nip44Version.DEPRECATED:
            return
        if value == Nip44Version.V2:
            return

    @staticmethod
    def write(value, buf):
        if value == Nip44Version.DEPRECATED:
            buf.write_i32(1)
        if value == Nip44Version.V2:
            buf.write_i32(2)







class NostrConnectMessage:
    def __init__(self):
        raise RuntimeError("NostrConnectMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class REQUEST:
        id: "str"
        method: "str"
        params: "typing.List[JsonValue]"

        @typing.no_type_check
        def __init__(self,id: "str", method: "str", params: "typing.List[JsonValue]"):
            
            self.id = id
            self.method = method
            self.params = params
            

        def __str__(self):
            return "NostrConnectMessage.REQUEST(id={}, method={}, params={})".format(self.id, self.method, self.params)

        def __eq__(self, other):
            if not other.is_request():
                return False
            if self.id != other.id:
                return False
            if self.method != other.method:
                return False
            if self.params != other.params:
                return False
            return True
    class RESPONSE:
        id: "str"
        result: "typing.Optional[JsonValue]"
        error: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,id: "str", result: "typing.Optional[JsonValue]", error: "typing.Optional[str]"):
            
            self.id = id
            self.result = result
            self.error = error
            

        def __str__(self):
            return "NostrConnectMessage.RESPONSE(id={}, result={}, error={})".format(self.id, self.result, self.error)

        def __eq__(self, other):
            if not other.is_response():
                return False
            if self.id != other.id:
                return False
            if self.result != other.result:
                return False
            if self.error != other.error:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_request(self) -> bool:
        return isinstance(self, NostrConnectMessage.REQUEST)
    def is_response(self) -> bool:
        return isinstance(self, NostrConnectMessage.RESPONSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NostrConnectMessage.REQUEST = type("NostrConnectMessage.REQUEST", (NostrConnectMessage.REQUEST, NostrConnectMessage,), {})  # type: ignore
NostrConnectMessage.RESPONSE = type("NostrConnectMessage.RESPONSE", (NostrConnectMessage.RESPONSE, NostrConnectMessage,), {})  # type: ignore




class _UniffiConverterTypeNostrConnectMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrConnectMessage.REQUEST(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeJsonValue.read(buf),
            )
        if variant == 2:
            return NostrConnectMessage.RESPONSE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeJsonValue.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_request():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterString.check_lower(value.method)
            _UniffiConverterSequenceTypeJsonValue.check_lower(value.params)
            return
        if value.is_response():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterOptionalTypeJsonValue.check_lower(value.result)
            _UniffiConverterOptionalString.check_lower(value.error)
            return

    @staticmethod
    def write(value, buf):
        if value.is_request():
            buf.write_i32(1)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.method, buf)
            _UniffiConverterSequenceTypeJsonValue.write(value.params, buf)
        if value.is_response():
            buf.write_i32(2)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterOptionalTypeJsonValue.write(value.result, buf)
            _UniffiConverterOptionalString.write(value.error, buf)




# NostrError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrError(Exception):
    pass

_UniffiTempNostrError = NostrError

class NostrError:  # type: ignore
    class Generic(_UniffiTempNostrError):

        def __repr__(self):
            return "NostrError.Generic({})".format(repr(str(self)))
    _UniffiTempNostrError.Generic = Generic # type: ignore

NostrError = _UniffiTempNostrError # type: ignore
del _UniffiTempNostrError


class _UniffiConverterTypeNostrError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, NostrError.Generic):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrError.Generic):
            buf.write_i32(1)





class Protocol:
    """NIP48 Proxy Protocol"""

    def __init__(self):
        raise RuntimeError("Protocol cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACTIVITY_PUB:
        """ActivityPub"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.ACTIVITY_PUB()".format()

        def __eq__(self, other):
            if not other.is_activity_pub():
                return False
            return True
    class AT_PROTO:
        """AT Protocol"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.AT_PROTO()".format()

        def __eq__(self, other):
            if not other.is_at_proto():
                return False
            return True
    class RSS:
        """Rss"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.RSS()".format()

        def __eq__(self, other):
            if not other.is_rss():
                return False
            return True
    class WEB:
        """Web"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.WEB()".format()

        def __eq__(self, other):
            if not other.is_web():
                return False
            return True
    class CUSTOM:
        """Custom"""

        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "Protocol.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_activity_pub(self) -> bool:
        return isinstance(self, Protocol.ACTIVITY_PUB)
    def is_at_proto(self) -> bool:
        return isinstance(self, Protocol.AT_PROTO)
    def is_rss(self) -> bool:
        return isinstance(self, Protocol.RSS)
    def is_web(self) -> bool:
        return isinstance(self, Protocol.WEB)
    def is_custom(self) -> bool:
        return isinstance(self, Protocol.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Protocol.ACTIVITY_PUB = type("Protocol.ACTIVITY_PUB", (Protocol.ACTIVITY_PUB, Protocol,), {})  # type: ignore
Protocol.AT_PROTO = type("Protocol.AT_PROTO", (Protocol.AT_PROTO, Protocol,), {})  # type: ignore
Protocol.RSS = type("Protocol.RSS", (Protocol.RSS, Protocol,), {})  # type: ignore
Protocol.WEB = type("Protocol.WEB", (Protocol.WEB, Protocol,), {})  # type: ignore
Protocol.CUSTOM = type("Protocol.CUSTOM", (Protocol.CUSTOM, Protocol,), {})  # type: ignore




class _UniffiConverterTypeProtocol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Protocol.ACTIVITY_PUB(
            )
        if variant == 2:
            return Protocol.AT_PROTO(
            )
        if variant == 3:
            return Protocol.RSS(
            )
        if variant == 4:
            return Protocol.WEB(
            )
        if variant == 5:
            return Protocol.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_activity_pub():
            return
        if value.is_at_proto():
            return
        if value.is_rss():
            return
        if value.is_web():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_activity_pub():
            buf.write_i32(1)
        if value.is_at_proto():
            buf.write_i32(2)
        if value.is_rss():
            buf.write_i32(3)
        if value.is_web():
            buf.write_i32(4)
        if value.is_custom():
            buf.write_i32(5)
            _UniffiConverterString.write(value.custom, buf)







class RelayMessage:
    def __init__(self):
        raise RuntimeError("RelayMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        subscription_id: "str"
        event: "Event"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", event: "Event"):
            
            self.subscription_id = subscription_id
            self.event = event
            

        def __str__(self):
            return "RelayMessage.EVENT_MSG(subscription_id={}, event={})".format(self.subscription_id, self.event)

        def __eq__(self, other):
            if not other.is_event_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.event != other.event:
                return False
            return True
    class OK:
        event_id: "EventId"
        status: "bool"
        message: "str"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", status: "bool", message: "str"):
            
            self.event_id = event_id
            self.status = status
            self.message = message
            

        def __str__(self):
            return "RelayMessage.OK(event_id={}, status={}, message={})".format(self.event_id, self.status, self.message)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.event_id != other.event_id:
                return False
            if self.status != other.status:
                return False
            if self.message != other.message:
                return False
            return True
    class END_OF_STORED_EVENTS:
        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "RelayMessage.END_OF_STORED_EVENTS(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_end_of_stored_events():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class NOTICE:
        message: "str"

        @typing.no_type_check
        def __init__(self,message: "str"):
            
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NOTICE(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_notice():
                return False
            if self.message != other.message:
                return False
            return True
    class CLOSED:
        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "RelayMessage.CLOSED(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_closed():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class AUTH:
        challenge: "str"

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "RelayMessage.AUTH(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class COUNT:
        subscription_id: "str"
        count: "int"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", count: "int"):
            
            self.subscription_id = subscription_id
            self.count = count
            

        def __str__(self):
            return "RelayMessage.COUNT(subscription_id={}, count={})".format(self.subscription_id, self.count)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.count != other.count:
                return False
            return True
    class NEG_MSG:
        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_neg_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class NEG_ERR:
        subscription_id: "str"
        code: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", code: "str"):
            
            self.subscription_id = subscription_id
            self.code = code
            

        def __str__(self):
            return "RelayMessage.NEG_ERR(subscription_id={}, code={})".format(self.subscription_id, self.code)

        def __eq__(self, other):
            if not other.is_neg_err():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.code != other.code:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_event_msg(self) -> bool:
        return isinstance(self, RelayMessage.EVENT_MSG)
    def is_ok(self) -> bool:
        return isinstance(self, RelayMessage.OK)
    def is_end_of_stored_events(self) -> bool:
        return isinstance(self, RelayMessage.END_OF_STORED_EVENTS)
    def is_notice(self) -> bool:
        return isinstance(self, RelayMessage.NOTICE)
    def is_closed(self) -> bool:
        return isinstance(self, RelayMessage.CLOSED)
    def is_auth(self) -> bool:
        return isinstance(self, RelayMessage.AUTH)
    def is_count(self) -> bool:
        return isinstance(self, RelayMessage.COUNT)
    def is_neg_msg(self) -> bool:
        return isinstance(self, RelayMessage.NEG_MSG)
    def is_neg_err(self) -> bool:
        return isinstance(self, RelayMessage.NEG_ERR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RelayMessage.EVENT_MSG = type("RelayMessage.EVENT_MSG", (RelayMessage.EVENT_MSG, RelayMessage,), {})  # type: ignore
RelayMessage.OK = type("RelayMessage.OK", (RelayMessage.OK, RelayMessage,), {})  # type: ignore
RelayMessage.END_OF_STORED_EVENTS = type("RelayMessage.END_OF_STORED_EVENTS", (RelayMessage.END_OF_STORED_EVENTS, RelayMessage,), {})  # type: ignore
RelayMessage.NOTICE = type("RelayMessage.NOTICE", (RelayMessage.NOTICE, RelayMessage,), {})  # type: ignore
RelayMessage.CLOSED = type("RelayMessage.CLOSED", (RelayMessage.CLOSED, RelayMessage,), {})  # type: ignore
RelayMessage.AUTH = type("RelayMessage.AUTH", (RelayMessage.AUTH, RelayMessage,), {})  # type: ignore
RelayMessage.COUNT = type("RelayMessage.COUNT", (RelayMessage.COUNT, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_MSG = type("RelayMessage.NEG_MSG", (RelayMessage.NEG_MSG, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_ERR = type("RelayMessage.NEG_ERR", (RelayMessage.NEG_ERR, RelayMessage,), {})  # type: ignore




class _UniffiConverterTypeRelayMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMessage.EVENT_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return RelayMessage.OK(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterBool.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RelayMessage.END_OF_STORED_EVENTS(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RelayMessage.NOTICE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RelayMessage.CLOSED(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RelayMessage.AUTH(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return RelayMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 8:
            return RelayMessage.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return RelayMessage.NEG_ERR(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_event_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_ok():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterBool.check_lower(value.status)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_end_of_stored_events():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_notice():
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_closed():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_auth():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_count():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterUInt64.check_lower(value.count)
            return
        if value.is_neg_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_neg_err():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.code)
            return

    @staticmethod
    def write(value, buf):
        if value.is_event_msg():
            buf.write_i32(1)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_ok():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterBool.write(value.status, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_end_of_stored_events():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_notice():
            buf.write_i32(4)
            _UniffiConverterString.write(value.message, buf)
        if value.is_closed():
            buf.write_i32(5)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_auth():
            buf.write_i32(6)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_count():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterUInt64.write(value.count, buf)
        if value.is_neg_msg():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_neg_err():
            buf.write_i32(9)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.code, buf)







class RelayMetadata(enum.Enum):
    READ = 1
    """Read"""

    
    WRITE = 2
    """Write"""

    


class _UniffiConverterTypeRelayMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMetadata.READ
        if variant == 2:
            return RelayMetadata.WRITE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RelayMetadata.READ:
            return
        if value == RelayMetadata.WRITE:
            return

    @staticmethod
    def write(value, buf):
        if value == RelayMetadata.READ:
            buf.write_i32(1)
        if value == RelayMetadata.WRITE:
            buf.write_i32(2)







class Report(enum.Enum):
    """Report"""

    NUDITY = 1
    """Depictions of nudity, porn, etc"""

    
    PROFANITY = 2
    """Profanity, hateful speech, etc."""

    
    ILLEGAL = 3
    """
    Something which may be illegal in some jurisdiction

    Remember: there is what is right and there is the law.
    """

    
    SPAM = 4
    """Spam"""

    
    IMPERSONATION = 5
    """Someone pretending to be someone else"""

    


class _UniffiConverterTypeReport(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Report.NUDITY
        if variant == 2:
            return Report.PROFANITY
        if variant == 3:
            return Report.ILLEGAL
        if variant == 4:
            return Report.SPAM
        if variant == 5:
            return Report.IMPERSONATION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Report.NUDITY:
            return
        if value == Report.PROFANITY:
            return
        if value == Report.ILLEGAL:
            return
        if value == Report.SPAM:
            return
        if value == Report.IMPERSONATION:
            return

    @staticmethod
    def write(value, buf):
        if value == Report.NUDITY:
            buf.write_i32(1)
        if value == Report.PROFANITY:
            buf.write_i32(2)
        if value == Report.ILLEGAL:
            buf.write_i32(3)
        if value == Report.SPAM:
            buf.write_i32(4)
        if value == Report.IMPERSONATION:
            buf.write_i32(5)







class RequestParams:
    """Nostr Wallet Connect Request Params"""

    def __init__(self):
        raise RuntimeError("RequestParams cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAY_INVOICE:
        """Pay Invoice"""

        pay_invoice: "PayInvoiceRequestParams"

        @typing.no_type_check
        def __init__(self,pay_invoice: "PayInvoiceRequestParams"):
            
            self.pay_invoice = pay_invoice
            

        def __str__(self):
            return "RequestParams.PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_pay_invoice():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    class MULTI_PAY_INVOICE:
        """Multi Pay Invoice"""

        multi_pay_invoice: "MultiPayInvoiceRequestParams"

        @typing.no_type_check
        def __init__(self,multi_pay_invoice: "MultiPayInvoiceRequestParams"):
            
            self.multi_pay_invoice = multi_pay_invoice
            

        def __str__(self):
            return "RequestParams.MULTI_PAY_INVOICE(multi_pay_invoice={})".format(self.multi_pay_invoice)

        def __eq__(self, other):
            if not other.is_multi_pay_invoice():
                return False
            if self.multi_pay_invoice != other.multi_pay_invoice:
                return False
            return True
    class PAY_KEYSEND:
        """Pay Keysend"""

        pay_keysend: "PayKeysendRequestParams"

        @typing.no_type_check
        def __init__(self,pay_keysend: "PayKeysendRequestParams"):
            
            self.pay_keysend = pay_keysend
            

        def __str__(self):
            return "RequestParams.PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_pay_keysend():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    class MULTI_PAY_KEYSEND:
        """Multi Pay Keysend"""

        multi_pay_keysend: "MultiPayKeysendRequestParams"

        @typing.no_type_check
        def __init__(self,multi_pay_keysend: "MultiPayKeysendRequestParams"):
            
            self.multi_pay_keysend = multi_pay_keysend
            

        def __str__(self):
            return "RequestParams.MULTI_PAY_KEYSEND(multi_pay_keysend={})".format(self.multi_pay_keysend)

        def __eq__(self, other):
            if not other.is_multi_pay_keysend():
                return False
            if self.multi_pay_keysend != other.multi_pay_keysend:
                return False
            return True
    class MAKE_INVOICE:
        """Make Invoice"""

        make_invoice: "MakeInvoiceRequestParams"

        @typing.no_type_check
        def __init__(self,make_invoice: "MakeInvoiceRequestParams"):
            
            self.make_invoice = make_invoice
            

        def __str__(self):
            return "RequestParams.MAKE_INVOICE(make_invoice={})".format(self.make_invoice)

        def __eq__(self, other):
            if not other.is_make_invoice():
                return False
            if self.make_invoice != other.make_invoice:
                return False
            return True
    class LOOKUP_INVOICE:
        """Lookup Invoice"""

        lookup_invoice: "LookupInvoiceRequestParams"

        @typing.no_type_check
        def __init__(self,lookup_invoice: "LookupInvoiceRequestParams"):
            
            self.lookup_invoice = lookup_invoice
            

        def __str__(self):
            return "RequestParams.LOOKUP_INVOICE(lookup_invoice={})".format(self.lookup_invoice)

        def __eq__(self, other):
            if not other.is_lookup_invoice():
                return False
            if self.lookup_invoice != other.lookup_invoice:
                return False
            return True
    class LIST_TRANSACTIONS:
        """List Transactions"""

        list_transactions: "ListTransactionsRequestParams"

        @typing.no_type_check
        def __init__(self,list_transactions: "ListTransactionsRequestParams"):
            
            self.list_transactions = list_transactions
            

        def __str__(self):
            return "RequestParams.LIST_TRANSACTIONS(list_transactions={})".format(self.list_transactions)

        def __eq__(self, other):
            if not other.is_list_transactions():
                return False
            if self.list_transactions != other.list_transactions:
                return False
            return True
    class GET_BALANCE:
        """Get Balance"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "RequestParams.GET_BALANCE()".format()

        def __eq__(self, other):
            if not other.is_get_balance():
                return False
            return True
    class GET_INFO:
        """Get Info"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "RequestParams.GET_INFO()".format()

        def __eq__(self, other):
            if not other.is_get_info():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pay_invoice(self) -> bool:
        return isinstance(self, RequestParams.PAY_INVOICE)
    def is_multi_pay_invoice(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_INVOICE)
    def is_pay_keysend(self) -> bool:
        return isinstance(self, RequestParams.PAY_KEYSEND)
    def is_multi_pay_keysend(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_KEYSEND)
    def is_make_invoice(self) -> bool:
        return isinstance(self, RequestParams.MAKE_INVOICE)
    def is_lookup_invoice(self) -> bool:
        return isinstance(self, RequestParams.LOOKUP_INVOICE)
    def is_list_transactions(self) -> bool:
        return isinstance(self, RequestParams.LIST_TRANSACTIONS)
    def is_get_balance(self) -> bool:
        return isinstance(self, RequestParams.GET_BALANCE)
    def is_get_info(self) -> bool:
        return isinstance(self, RequestParams.GET_INFO)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RequestParams.PAY_INVOICE = type("RequestParams.PAY_INVOICE", (RequestParams.PAY_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.MULTI_PAY_INVOICE = type("RequestParams.MULTI_PAY_INVOICE", (RequestParams.MULTI_PAY_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.PAY_KEYSEND = type("RequestParams.PAY_KEYSEND", (RequestParams.PAY_KEYSEND, RequestParams,), {})  # type: ignore
RequestParams.MULTI_PAY_KEYSEND = type("RequestParams.MULTI_PAY_KEYSEND", (RequestParams.MULTI_PAY_KEYSEND, RequestParams,), {})  # type: ignore
RequestParams.MAKE_INVOICE = type("RequestParams.MAKE_INVOICE", (RequestParams.MAKE_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.LOOKUP_INVOICE = type("RequestParams.LOOKUP_INVOICE", (RequestParams.LOOKUP_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.LIST_TRANSACTIONS = type("RequestParams.LIST_TRANSACTIONS", (RequestParams.LIST_TRANSACTIONS, RequestParams,), {})  # type: ignore
RequestParams.GET_BALANCE = type("RequestParams.GET_BALANCE", (RequestParams.GET_BALANCE, RequestParams,), {})  # type: ignore
RequestParams.GET_INFO = type("RequestParams.GET_INFO", (RequestParams.GET_INFO, RequestParams,), {})  # type: ignore




class _UniffiConverterTypeRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RequestParams.PAY_INVOICE(
                _UniffiConverterTypePayInvoiceRequestParams.read(buf),
            )
        if variant == 2:
            return RequestParams.MULTI_PAY_INVOICE(
                _UniffiConverterTypeMultiPayInvoiceRequestParams.read(buf),
            )
        if variant == 3:
            return RequestParams.PAY_KEYSEND(
                _UniffiConverterTypePayKeysendRequestParams.read(buf),
            )
        if variant == 4:
            return RequestParams.MULTI_PAY_KEYSEND(
                _UniffiConverterTypeMultiPayKeysendRequestParams.read(buf),
            )
        if variant == 5:
            return RequestParams.MAKE_INVOICE(
                _UniffiConverterTypeMakeInvoiceRequestParams.read(buf),
            )
        if variant == 6:
            return RequestParams.LOOKUP_INVOICE(
                _UniffiConverterTypeLookupInvoiceRequestParams.read(buf),
            )
        if variant == 7:
            return RequestParams.LIST_TRANSACTIONS(
                _UniffiConverterTypeListTransactionsRequestParams.read(buf),
            )
        if variant == 8:
            return RequestParams.GET_BALANCE(
            )
        if variant == 9:
            return RequestParams.GET_INFO(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pay_invoice():
            _UniffiConverterTypePayInvoiceRequestParams.check_lower(value.pay_invoice)
            return
        if value.is_multi_pay_invoice():
            _UniffiConverterTypeMultiPayInvoiceRequestParams.check_lower(value.multi_pay_invoice)
            return
        if value.is_pay_keysend():
            _UniffiConverterTypePayKeysendRequestParams.check_lower(value.pay_keysend)
            return
        if value.is_multi_pay_keysend():
            _UniffiConverterTypeMultiPayKeysendRequestParams.check_lower(value.multi_pay_keysend)
            return
        if value.is_make_invoice():
            _UniffiConverterTypeMakeInvoiceRequestParams.check_lower(value.make_invoice)
            return
        if value.is_lookup_invoice():
            _UniffiConverterTypeLookupInvoiceRequestParams.check_lower(value.lookup_invoice)
            return
        if value.is_list_transactions():
            _UniffiConverterTypeListTransactionsRequestParams.check_lower(value.list_transactions)
            return
        if value.is_get_balance():
            return
        if value.is_get_info():
            return

    @staticmethod
    def write(value, buf):
        if value.is_pay_invoice():
            buf.write_i32(1)
            _UniffiConverterTypePayInvoiceRequestParams.write(value.pay_invoice, buf)
        if value.is_multi_pay_invoice():
            buf.write_i32(2)
            _UniffiConverterTypeMultiPayInvoiceRequestParams.write(value.multi_pay_invoice, buf)
        if value.is_pay_keysend():
            buf.write_i32(3)
            _UniffiConverterTypePayKeysendRequestParams.write(value.pay_keysend, buf)
        if value.is_multi_pay_keysend():
            buf.write_i32(4)
            _UniffiConverterTypeMultiPayKeysendRequestParams.write(value.multi_pay_keysend, buf)
        if value.is_make_invoice():
            buf.write_i32(5)
            _UniffiConverterTypeMakeInvoiceRequestParams.write(value.make_invoice, buf)
        if value.is_lookup_invoice():
            buf.write_i32(6)
            _UniffiConverterTypeLookupInvoiceRequestParams.write(value.lookup_invoice, buf)
        if value.is_list_transactions():
            buf.write_i32(7)
            _UniffiConverterTypeListTransactionsRequestParams.write(value.list_transactions, buf)
        if value.is_get_balance():
            buf.write_i32(8)
        if value.is_get_info():
            buf.write_i32(9)







class ResponseResult:
    """NIP47 Response Result"""

    def __init__(self):
        raise RuntimeError("ResponseResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAY_INVOICE:
        """Pay Invoice"""

        pay_invoice: "PayInvoiceResponseResult"

        @typing.no_type_check
        def __init__(self,pay_invoice: "PayInvoiceResponseResult"):
            
            self.pay_invoice = pay_invoice
            

        def __str__(self):
            return "ResponseResult.PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_pay_invoice():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    class MULTI_PAY_INVOICE:
        """Multi Pay Invoice"""

        pay_invoice: "PayInvoiceResponseResult"

        @typing.no_type_check
        def __init__(self,pay_invoice: "PayInvoiceResponseResult"):
            
            self.pay_invoice = pay_invoice
            

        def __str__(self):
            return "ResponseResult.MULTI_PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_multi_pay_invoice():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    class PAY_KEYSEND:
        """Pay Keysend"""

        pay_keysend: "PayKeysendResponseResult"

        @typing.no_type_check
        def __init__(self,pay_keysend: "PayKeysendResponseResult"):
            
            self.pay_keysend = pay_keysend
            

        def __str__(self):
            return "ResponseResult.PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_pay_keysend():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    class MULTI_PAY_KEYSEND:
        """Multi Pay Keysend"""

        pay_keysend: "PayKeysendResponseResult"

        @typing.no_type_check
        def __init__(self,pay_keysend: "PayKeysendResponseResult"):
            
            self.pay_keysend = pay_keysend
            

        def __str__(self):
            return "ResponseResult.MULTI_PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_multi_pay_keysend():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    class MAKE_INVOICE:
        """Make Invoice"""

        make_invoice: "MakeInvoiceResponseResult"

        @typing.no_type_check
        def __init__(self,make_invoice: "MakeInvoiceResponseResult"):
            
            self.make_invoice = make_invoice
            

        def __str__(self):
            return "ResponseResult.MAKE_INVOICE(make_invoice={})".format(self.make_invoice)

        def __eq__(self, other):
            if not other.is_make_invoice():
                return False
            if self.make_invoice != other.make_invoice:
                return False
            return True
    class LOOKUP_INVOICE:
        """Lookup Invoice"""

        lookup_invoice: "LookupInvoiceResponseResult"

        @typing.no_type_check
        def __init__(self,lookup_invoice: "LookupInvoiceResponseResult"):
            
            self.lookup_invoice = lookup_invoice
            

        def __str__(self):
            return "ResponseResult.LOOKUP_INVOICE(lookup_invoice={})".format(self.lookup_invoice)

        def __eq__(self, other):
            if not other.is_lookup_invoice():
                return False
            if self.lookup_invoice != other.lookup_invoice:
                return False
            return True
    class LIST_TRANSACTIONS:
        """List Transactions"""

        list_transactions: "typing.List[LookupInvoiceResponseResult]"

        @typing.no_type_check
        def __init__(self,list_transactions: "typing.List[LookupInvoiceResponseResult]"):
            
            self.list_transactions = list_transactions
            

        def __str__(self):
            return "ResponseResult.LIST_TRANSACTIONS(list_transactions={})".format(self.list_transactions)

        def __eq__(self, other):
            if not other.is_list_transactions():
                return False
            if self.list_transactions != other.list_transactions:
                return False
            return True
    class GET_BALANCE:
        """Get Balance"""

        get_balance: "GetBalanceResponseResult"

        @typing.no_type_check
        def __init__(self,get_balance: "GetBalanceResponseResult"):
            
            self.get_balance = get_balance
            

        def __str__(self):
            return "ResponseResult.GET_BALANCE(get_balance={})".format(self.get_balance)

        def __eq__(self, other):
            if not other.is_get_balance():
                return False
            if self.get_balance != other.get_balance:
                return False
            return True
    class GET_INFO:
        """Get Info"""

        get_info: "GetInfoResponseResult"

        @typing.no_type_check
        def __init__(self,get_info: "GetInfoResponseResult"):
            
            self.get_info = get_info
            

        def __str__(self):
            return "ResponseResult.GET_INFO(get_info={})".format(self.get_info)

        def __eq__(self, other):
            if not other.is_get_info():
                return False
            if self.get_info != other.get_info:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pay_invoice(self) -> bool:
        return isinstance(self, ResponseResult.PAY_INVOICE)
    def is_multi_pay_invoice(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_INVOICE)
    def is_pay_keysend(self) -> bool:
        return isinstance(self, ResponseResult.PAY_KEYSEND)
    def is_multi_pay_keysend(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_KEYSEND)
    def is_make_invoice(self) -> bool:
        return isinstance(self, ResponseResult.MAKE_INVOICE)
    def is_lookup_invoice(self) -> bool:
        return isinstance(self, ResponseResult.LOOKUP_INVOICE)
    def is_list_transactions(self) -> bool:
        return isinstance(self, ResponseResult.LIST_TRANSACTIONS)
    def is_get_balance(self) -> bool:
        return isinstance(self, ResponseResult.GET_BALANCE)
    def is_get_info(self) -> bool:
        return isinstance(self, ResponseResult.GET_INFO)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResponseResult.PAY_INVOICE = type("ResponseResult.PAY_INVOICE", (ResponseResult.PAY_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.MULTI_PAY_INVOICE = type("ResponseResult.MULTI_PAY_INVOICE", (ResponseResult.MULTI_PAY_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.PAY_KEYSEND = type("ResponseResult.PAY_KEYSEND", (ResponseResult.PAY_KEYSEND, ResponseResult,), {})  # type: ignore
ResponseResult.MULTI_PAY_KEYSEND = type("ResponseResult.MULTI_PAY_KEYSEND", (ResponseResult.MULTI_PAY_KEYSEND, ResponseResult,), {})  # type: ignore
ResponseResult.MAKE_INVOICE = type("ResponseResult.MAKE_INVOICE", (ResponseResult.MAKE_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.LOOKUP_INVOICE = type("ResponseResult.LOOKUP_INVOICE", (ResponseResult.LOOKUP_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.LIST_TRANSACTIONS = type("ResponseResult.LIST_TRANSACTIONS", (ResponseResult.LIST_TRANSACTIONS, ResponseResult,), {})  # type: ignore
ResponseResult.GET_BALANCE = type("ResponseResult.GET_BALANCE", (ResponseResult.GET_BALANCE, ResponseResult,), {})  # type: ignore
ResponseResult.GET_INFO = type("ResponseResult.GET_INFO", (ResponseResult.GET_INFO, ResponseResult,), {})  # type: ignore




class _UniffiConverterTypeResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResponseResult.PAY_INVOICE(
                _UniffiConverterTypePayInvoiceResponseResult.read(buf),
            )
        if variant == 2:
            return ResponseResult.MULTI_PAY_INVOICE(
                _UniffiConverterTypePayInvoiceResponseResult.read(buf),
            )
        if variant == 3:
            return ResponseResult.PAY_KEYSEND(
                _UniffiConverterTypePayKeysendResponseResult.read(buf),
            )
        if variant == 4:
            return ResponseResult.MULTI_PAY_KEYSEND(
                _UniffiConverterTypePayKeysendResponseResult.read(buf),
            )
        if variant == 5:
            return ResponseResult.MAKE_INVOICE(
                _UniffiConverterTypeMakeInvoiceResponseResult.read(buf),
            )
        if variant == 6:
            return ResponseResult.LOOKUP_INVOICE(
                _UniffiConverterTypeLookupInvoiceResponseResult.read(buf),
            )
        if variant == 7:
            return ResponseResult.LIST_TRANSACTIONS(
                _UniffiConverterSequenceTypeLookupInvoiceResponseResult.read(buf),
            )
        if variant == 8:
            return ResponseResult.GET_BALANCE(
                _UniffiConverterTypeGetBalanceResponseResult.read(buf),
            )
        if variant == 9:
            return ResponseResult.GET_INFO(
                _UniffiConverterTypeGetInfoResponseResult.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pay_invoice():
            _UniffiConverterTypePayInvoiceResponseResult.check_lower(value.pay_invoice)
            return
        if value.is_multi_pay_invoice():
            _UniffiConverterTypePayInvoiceResponseResult.check_lower(value.pay_invoice)
            return
        if value.is_pay_keysend():
            _UniffiConverterTypePayKeysendResponseResult.check_lower(value.pay_keysend)
            return
        if value.is_multi_pay_keysend():
            _UniffiConverterTypePayKeysendResponseResult.check_lower(value.pay_keysend)
            return
        if value.is_make_invoice():
            _UniffiConverterTypeMakeInvoiceResponseResult.check_lower(value.make_invoice)
            return
        if value.is_lookup_invoice():
            _UniffiConverterTypeLookupInvoiceResponseResult.check_lower(value.lookup_invoice)
            return
        if value.is_list_transactions():
            _UniffiConverterSequenceTypeLookupInvoiceResponseResult.check_lower(value.list_transactions)
            return
        if value.is_get_balance():
            _UniffiConverterTypeGetBalanceResponseResult.check_lower(value.get_balance)
            return
        if value.is_get_info():
            _UniffiConverterTypeGetInfoResponseResult.check_lower(value.get_info)
            return

    @staticmethod
    def write(value, buf):
        if value.is_pay_invoice():
            buf.write_i32(1)
            _UniffiConverterTypePayInvoiceResponseResult.write(value.pay_invoice, buf)
        if value.is_multi_pay_invoice():
            buf.write_i32(2)
            _UniffiConverterTypePayInvoiceResponseResult.write(value.pay_invoice, buf)
        if value.is_pay_keysend():
            buf.write_i32(3)
            _UniffiConverterTypePayKeysendResponseResult.write(value.pay_keysend, buf)
        if value.is_multi_pay_keysend():
            buf.write_i32(4)
            _UniffiConverterTypePayKeysendResponseResult.write(value.pay_keysend, buf)
        if value.is_make_invoice():
            buf.write_i32(5)
            _UniffiConverterTypeMakeInvoiceResponseResult.write(value.make_invoice, buf)
        if value.is_lookup_invoice():
            buf.write_i32(6)
            _UniffiConverterTypeLookupInvoiceResponseResult.write(value.lookup_invoice, buf)
        if value.is_list_transactions():
            buf.write_i32(7)
            _UniffiConverterSequenceTypeLookupInvoiceResponseResult.write(value.list_transactions, buf)
        if value.is_get_balance():
            buf.write_i32(8)
            _UniffiConverterTypeGetBalanceResponseResult.write(value.get_balance, buf)
        if value.is_get_info():
            buf.write_i32(9)
            _UniffiConverterTypeGetInfoResponseResult.write(value.get_info, buf)







class RetentionKind:
    def __init__(self):
        raise RuntimeError("RetentionKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SINGLE:
        single: "int"

        @typing.no_type_check
        def __init__(self,single: "int"):
            
            self.single = single
            

        def __str__(self):
            return "RetentionKind.SINGLE(single={})".format(self.single)

        def __eq__(self, other):
            if not other.is_single():
                return False
            if self.single != other.single:
                return False
            return True
    class RANGE:
        start: "int"
        end: "int"

        @typing.no_type_check
        def __init__(self,start: "int", end: "int"):
            
            self.start = start
            self.end = end
            

        def __str__(self):
            return "RetentionKind.RANGE(start={}, end={})".format(self.start, self.end)

        def __eq__(self, other):
            if not other.is_range():
                return False
            if self.start != other.start:
                return False
            if self.end != other.end:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_single(self) -> bool:
        return isinstance(self, RetentionKind.SINGLE)
    def is_range(self) -> bool:
        return isinstance(self, RetentionKind.RANGE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RetentionKind.SINGLE = type("RetentionKind.SINGLE", (RetentionKind.SINGLE, RetentionKind,), {})  # type: ignore
RetentionKind.RANGE = type("RetentionKind.RANGE", (RetentionKind.RANGE, RetentionKind,), {})  # type: ignore




class _UniffiConverterTypeRetentionKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RetentionKind.SINGLE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return RetentionKind.RANGE(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_single():
            _UniffiConverterUInt64.check_lower(value.single)
            return
        if value.is_range():
            _UniffiConverterUInt64.check_lower(value.start)
            _UniffiConverterUInt64.check_lower(value.end)
            return

    @staticmethod
    def write(value, buf):
        if value.is_single():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.single, buf)
        if value.is_range():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.start, buf)
            _UniffiConverterUInt64.write(value.end, buf)







class TagEnum:
    def __init__(self):
        raise RuntimeError("TagEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNKNOWN:
        kind: "TagKind"
        data: "typing.List[str]"

        @typing.no_type_check
        def __init__(self,kind: "TagKind", data: "typing.List[str]"):
            
            self.kind = kind
            self.data = data
            

        def __str__(self):
            return "TagEnum.UNKNOWN(kind={}, data={})".format(self.kind, self.data)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.kind != other.kind:
                return False
            if self.data != other.data:
                return False
            return True
    class EVENT_TAG:
        event_id: "EventId"
        relay_url: "typing.Optional[str]"
        marker: "typing.Optional[Marker]"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", relay_url: "typing.Optional[str]", marker: "typing.Optional[Marker]"):
            
            self.event_id = event_id
            self.relay_url = relay_url
            self.marker = marker
            

        def __str__(self):
            return "TagEnum.EVENT_TAG(event_id={}, relay_url={}, marker={})".format(self.event_id, self.relay_url, self.marker)

        def __eq__(self, other):
            if not other.is_event_tag():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            return True
    class PUBLIC_KEY_TAG:
        public_key: "PublicKey"
        relay_url: "typing.Optional[str]"
        alias: "typing.Optional[str]"
        uppercase: "bool"
        """Whether the p tag is an uppercase P or not"""


        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[str]", alias: "typing.Optional[str]", uppercase: "bool"):
            
            self.public_key = public_key
            self.relay_url = relay_url
            self.alias = alias
            self.uppercase = uppercase
            

        def __str__(self):
            return "TagEnum.PUBLIC_KEY_TAG(public_key={}, relay_url={}, alias={}, uppercase={})".format(self.public_key, self.relay_url, self.alias, self.uppercase)

        def __eq__(self, other):
            if not other.is_public_key_tag():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.alias != other.alias:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    class EVENT_REPORT:
        event_id: "EventId"
        report: "Report"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", report: "Report"):
            
            self.event_id = event_id
            self.report = report
            

        def __str__(self):
            return "TagEnum.EVENT_REPORT(event_id={}, report={})".format(self.event_id, self.report)

        def __eq__(self, other):
            if not other.is_event_report():
                return False
            if self.event_id != other.event_id:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_REPORT:
        public_key: "PublicKey"
        report: "Report"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", report: "Report"):
            
            self.public_key = public_key
            self.report = report
            

        def __str__(self):
            return "TagEnum.PUB_KEY_REPORT(public_key={}, report={})".format(self.public_key, self.report)

        def __eq__(self, other):
            if not other.is_pub_key_report():
                return False
            if self.public_key != other.public_key:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_LIVE_EVENT:
        public_key: "PublicKey"
        relay_url: "typing.Optional[str]"
        marker: "LiveEventMarker"
        proof: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[str]", marker: "LiveEventMarker", proof: "typing.Optional[str]"):
            
            self.public_key = public_key
            self.relay_url = relay_url
            self.marker = marker
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.PUB_KEY_LIVE_EVENT(public_key={}, relay_url={}, marker={}, proof={})".format(self.public_key, self.relay_url, self.marker, self.proof)

        def __eq__(self, other):
            if not other.is_pub_key_live_event():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.proof != other.proof:
                return False
            return True
    class REFERENCE:
        reference: "str"

        @typing.no_type_check
        def __init__(self,reference: "str"):
            
            self.reference = reference
            

        def __str__(self):
            return "TagEnum.REFERENCE(reference={})".format(self.reference)

        def __eq__(self, other):
            if not other.is_reference():
                return False
            if self.reference != other.reference:
                return False
            return True
    class RELAY_METADATA_TAG:
        relay_url: "str"
        rw: "typing.Optional[RelayMetadata]"

        @typing.no_type_check
        def __init__(self,relay_url: "str", rw: "typing.Optional[RelayMetadata]"):
            
            self.relay_url = relay_url
            self.rw = rw
            

        def __str__(self):
            return "TagEnum.RELAY_METADATA_TAG(relay_url={}, rw={})".format(self.relay_url, self.rw)

        def __eq__(self, other):
            if not other.is_relay_metadata_tag():
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.rw != other.rw:
                return False
            return True
    class HASHTAG:
        hashtag: "str"

        @typing.no_type_check
        def __init__(self,hashtag: "str"):
            
            self.hashtag = hashtag
            

        def __str__(self):
            return "TagEnum.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_hashtag():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    class GEOHASH:
        geohash: "str"

        @typing.no_type_check
        def __init__(self,geohash: "str"):
            
            self.geohash = geohash
            

        def __str__(self):
            return "TagEnum.GEOHASH(geohash={})".format(self.geohash)

        def __eq__(self, other):
            if not other.is_geohash():
                return False
            if self.geohash != other.geohash:
                return False
            return True
    class IDENTIFIER:
        identifier: "str"

        @typing.no_type_check
        def __init__(self,identifier: "str"):
            
            self.identifier = identifier
            

        def __str__(self):
            return "TagEnum.IDENTIFIER(identifier={})".format(self.identifier)

        def __eq__(self, other):
            if not other.is_identifier():
                return False
            if self.identifier != other.identifier:
                return False
            return True
    class EXTERNAL_IDENTITY_TAG:
        identity: "Identity"

        @typing.no_type_check
        def __init__(self,identity: "Identity"):
            
            self.identity = identity
            

        def __str__(self):
            return "TagEnum.EXTERNAL_IDENTITY_TAG(identity={})".format(self.identity)

        def __eq__(self, other):
            if not other.is_external_identity_tag():
                return False
            if self.identity != other.identity:
                return False
            return True
    class A:
        kind: "int"
        public_key: "PublicKey"
        identifier: "str"
        relay_url: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,kind: "int", public_key: "PublicKey", identifier: "str", relay_url: "typing.Optional[str]"):
            
            self.kind = kind
            self.public_key = public_key
            self.identifier = identifier
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.A(kind={}, public_key={}, identifier={}, relay_url={})".format(self.kind, self.public_key, self.identifier, self.relay_url)

        def __eq__(self, other):
            if not other.is_a():
                return False
            if self.kind != other.kind:
                return False
            if self.public_key != other.public_key:
                return False
            if self.identifier != other.identifier:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class RELAY_URL:
        relay_url: "str"

        @typing.no_type_check
        def __init__(self,relay_url: "str"):
            
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.RELAY_URL(relay_url={})".format(self.relay_url)

        def __eq__(self, other):
            if not other.is_relay_url():
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class POW:
        nonce: "str"
        difficulty: "int"

        @typing.no_type_check
        def __init__(self,nonce: "str", difficulty: "int"):
            
            self.nonce = nonce
            self.difficulty = difficulty
            

        def __str__(self):
            return "TagEnum.POW(nonce={}, difficulty={})".format(self.nonce, self.difficulty)

        def __eq__(self, other):
            if not other.is_pow():
                return False
            if self.nonce != other.nonce:
                return False
            if self.difficulty != other.difficulty:
                return False
            return True
    class DELEGATION:
        delegator: "PublicKey"
        conditions: "str"
        sig: "str"

        @typing.no_type_check
        def __init__(self,delegator: "PublicKey", conditions: "str", sig: "str"):
            
            self.delegator = delegator
            self.conditions = conditions
            self.sig = sig
            

        def __str__(self):
            return "TagEnum.DELEGATION(delegator={}, conditions={}, sig={})".format(self.delegator, self.conditions, self.sig)

        def __eq__(self, other):
            if not other.is_delegation():
                return False
            if self.delegator != other.delegator:
                return False
            if self.conditions != other.conditions:
                return False
            if self.sig != other.sig:
                return False
            return True
    class CONTENT_WARNING:
        reason: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,reason: "typing.Optional[str]"):
            
            self.reason = reason
            

        def __str__(self):
            return "TagEnum.CONTENT_WARNING(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_content_warning():
                return False
            if self.reason != other.reason:
                return False
            return True
    class EXPIRATION:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.EXPIRATION(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_expiration():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class SUBJECT:
        subject: "str"

        @typing.no_type_check
        def __init__(self,subject: "str"):
            
            self.subject = subject
            

        def __str__(self):
            return "TagEnum.SUBJECT(subject={})".format(self.subject)

        def __eq__(self, other):
            if not other.is_subject():
                return False
            if self.subject != other.subject:
                return False
            return True
    class CHALLENGE:
        challenge: "str"

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "TagEnum.CHALLENGE(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_challenge():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class TITLE:
        title: "str"

        @typing.no_type_check
        def __init__(self,title: "str"):
            
            self.title = title
            

        def __str__(self):
            return "TagEnum.TITLE(title={})".format(self.title)

        def __eq__(self, other):
            if not other.is_title():
                return False
            if self.title != other.title:
                return False
            return True
    class IMAGE:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.IMAGE(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_image():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class THUMB:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.THUMB(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_thumb():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class SUMMARY:
        summary: "str"

        @typing.no_type_check
        def __init__(self,summary: "str"):
            
            self.summary = summary
            

        def __str__(self):
            return "TagEnum.SUMMARY(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_summary():
                return False
            if self.summary != other.summary:
                return False
            return True
    class DESCRIPTION:
        desc: "str"

        @typing.no_type_check
        def __init__(self,desc: "str"):
            
            self.desc = desc
            

        def __str__(self):
            return "TagEnum.DESCRIPTION(desc={})".format(self.desc)

        def __eq__(self, other):
            if not other.is_description():
                return False
            if self.desc != other.desc:
                return False
            return True
    class BOLT11:
        bolt11: "str"

        @typing.no_type_check
        def __init__(self,bolt11: "str"):
            
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.BOLT11(bolt11={})".format(self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class PREIMAGE:
        preimage: "str"

        @typing.no_type_check
        def __init__(self,preimage: "str"):
            
            self.preimage = preimage
            

        def __str__(self):
            return "TagEnum.PREIMAGE(preimage={})".format(self.preimage)

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            if self.preimage != other.preimage:
                return False
            return True
    class RELAYS:
        urls: "typing.List[str]"

        @typing.no_type_check
        def __init__(self,urls: "typing.List[str]"):
            
            self.urls = urls
            

        def __str__(self):
            return "TagEnum.RELAYS(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_relays():
                return False
            if self.urls != other.urls:
                return False
            return True
    class AMOUNT:
        millisats: "int"
        bolt11: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,millisats: "int", bolt11: "typing.Optional[str]"):
            
            self.millisats = millisats
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.AMOUNT(millisats={}, bolt11={})".format(self.millisats, self.bolt11)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.millisats != other.millisats:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class LNURL:
        lnurl: "str"

        @typing.no_type_check
        def __init__(self,lnurl: "str"):
            
            self.lnurl = lnurl
            

        def __str__(self):
            return "TagEnum.LNURL(lnurl={})".format(self.lnurl)

        def __eq__(self, other):
            if not other.is_lnurl():
                return False
            if self.lnurl != other.lnurl:
                return False
            return True
    class NAME:
        name: "str"

        @typing.no_type_check
        def __init__(self,name: "str"):
            
            self.name = name
            

        def __str__(self):
            return "TagEnum.NAME(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_name():
                return False
            if self.name != other.name:
                return False
            return True
    class PUBLISHED_AT:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.PUBLISHED_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_published_at():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class URL_TAG:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.URL_TAG(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url_tag():
                return False
            if self.url != other.url:
                return False
            return True
    class MIME_TYPE:
        mime: "str"

        @typing.no_type_check
        def __init__(self,mime: "str"):
            
            self.mime = mime
            

        def __str__(self):
            return "TagEnum.MIME_TYPE(mime={})".format(self.mime)

        def __eq__(self, other):
            if not other.is_mime_type():
                return False
            if self.mime != other.mime:
                return False
            return True
    class AES256_GCM:
        key: "str"
        iv: "str"

        @typing.no_type_check
        def __init__(self,key: "str", iv: "str"):
            
            self.key = key
            self.iv = iv
            

        def __str__(self):
            return "TagEnum.AES256_GCM(key={}, iv={})".format(self.key, self.iv)

        def __eq__(self, other):
            if not other.is_aes256_gcm():
                return False
            if self.key != other.key:
                return False
            if self.iv != other.iv:
                return False
            return True
    class SHA256:
        hash: "str"

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.SHA256(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_sha256():
                return False
            if self.hash != other.hash:
                return False
            return True
    class SIZE:
        size: "int"

        @typing.no_type_check
        def __init__(self,size: "int"):
            
            self.size = size
            

        def __str__(self):
            return "TagEnum.SIZE(size={})".format(self.size)

        def __eq__(self, other):
            if not other.is_size():
                return False
            if self.size != other.size:
                return False
            return True
    class DIM:
        """Size of file in pixels"""

        dimensions: "ImageDimensions"

        @typing.no_type_check
        def __init__(self,dimensions: "ImageDimensions"):
            
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.DIM(dimensions={})".format(self.dimensions)

        def __eq__(self, other):
            if not other.is_dim():
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class MAGNET:
        uri: "str"

        @typing.no_type_check
        def __init__(self,uri: "str"):
            
            self.uri = uri
            

        def __str__(self):
            return "TagEnum.MAGNET(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_magnet():
                return False
            if self.uri != other.uri:
                return False
            return True
    class BLURHASH:
        blurhash: "str"

        @typing.no_type_check
        def __init__(self,blurhash: "str"):
            
            self.blurhash = blurhash
            

        def __str__(self):
            return "TagEnum.BLURHASH(blurhash={})".format(self.blurhash)

        def __eq__(self, other):
            if not other.is_blurhash():
                return False
            if self.blurhash != other.blurhash:
                return False
            return True
    class STREAMING:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.STREAMING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_streaming():
                return False
            if self.url != other.url:
                return False
            return True
    class RECORDING:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.RECORDING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_recording():
                return False
            if self.url != other.url:
                return False
            return True
    class STARTS:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.STARTS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_starts():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class ENDS:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.ENDS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_ends():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class LIVE_EVENT_STATUS_TAG:
        status: "LiveEventStatus"

        @typing.no_type_check
        def __init__(self,status: "LiveEventStatus"):
            
            self.status = status
            

        def __str__(self):
            return "TagEnum.LIVE_EVENT_STATUS_TAG(status={})".format(self.status)

        def __eq__(self, other):
            if not other.is_live_event_status_tag():
                return False
            if self.status != other.status:
                return False
            return True
    class CURRENT_PARTICIPANTS:
        num: "int"

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.CURRENT_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_current_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class TOTAL_PARTICIPANTS:
        num: "int"

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.TOTAL_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_total_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class ABSOLUTE_URL:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.ABSOLUTE_URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_absolute_url():
                return False
            if self.url != other.url:
                return False
            return True
    class METHOD:
        method: "HttpMethod"

        @typing.no_type_check
        def __init__(self,method: "HttpMethod"):
            
            self.method = method
            

        def __str__(self):
            return "TagEnum.METHOD(method={})".format(self.method)

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.method != other.method:
                return False
            return True
    class PAYLOAD:
        hash: "str"

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.PAYLOAD(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_payload():
                return False
            if self.hash != other.hash:
                return False
            return True
    class ANON:
        msg: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,msg: "typing.Optional[str]"):
            
            self.msg = msg
            

        def __str__(self):
            return "TagEnum.ANON(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_anon():
                return False
            if self.msg != other.msg:
                return False
            return True
    class PROXY:
        id: "str"
        protocol: "Protocol"

        @typing.no_type_check
        def __init__(self,id: "str", protocol: "Protocol"):
            
            self.id = id
            self.protocol = protocol
            

        def __str__(self):
            return "TagEnum.PROXY(id={}, protocol={})".format(self.id, self.protocol)

        def __eq__(self, other):
            if not other.is_proxy():
                return False
            if self.id != other.id:
                return False
            if self.protocol != other.protocol:
                return False
            return True
    class EMOJI:
        shortcode: "str"
        url: "str"

        @typing.no_type_check
        def __init__(self,shortcode: "str", url: "str"):
            
            self.shortcode = shortcode
            self.url = url
            

        def __str__(self):
            return "TagEnum.EMOJI(shortcode={}, url={})".format(self.shortcode, self.url)

        def __eq__(self, other):
            if not other.is_emoji():
                return False
            if self.shortcode != other.shortcode:
                return False
            if self.url != other.url:
                return False
            return True
    class ENCRYPTED:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagEnum.ENCRYPTED()".format()

        def __eq__(self, other):
            if not other.is_encrypted():
                return False
            return True
    class REQUEST:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "TagEnum.REQUEST(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_request():
                return False
            if self.event != other.event:
                return False
            return True
    class DATA_VENDING_MACHINE_STATUS_TAG:
        status: "DataVendingMachineStatus"
        extra_info: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,status: "DataVendingMachineStatus", extra_info: "typing.Optional[str]"):
            
            self.status = status
            self.extra_info = extra_info
            

        def __str__(self):
            return "TagEnum.DATA_VENDING_MACHINE_STATUS_TAG(status={}, extra_info={})".format(self.status, self.extra_info)

        def __eq__(self, other):
            if not other.is_data_vending_machine_status_tag():
                return False
            if self.status != other.status:
                return False
            if self.extra_info != other.extra_info:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_unknown(self) -> bool:
        return isinstance(self, TagEnum.UNKNOWN)
    def is_event_tag(self) -> bool:
        return isinstance(self, TagEnum.EVENT_TAG)
    def is_public_key_tag(self) -> bool:
        return isinstance(self, TagEnum.PUBLIC_KEY_TAG)
    def is_event_report(self) -> bool:
        return isinstance(self, TagEnum.EVENT_REPORT)
    def is_pub_key_report(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_REPORT)
    def is_pub_key_live_event(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_LIVE_EVENT)
    def is_reference(self) -> bool:
        return isinstance(self, TagEnum.REFERENCE)
    def is_relay_metadata_tag(self) -> bool:
        return isinstance(self, TagEnum.RELAY_METADATA_TAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, TagEnum.HASHTAG)
    def is_geohash(self) -> bool:
        return isinstance(self, TagEnum.GEOHASH)
    def is_identifier(self) -> bool:
        return isinstance(self, TagEnum.IDENTIFIER)
    def is_external_identity_tag(self) -> bool:
        return isinstance(self, TagEnum.EXTERNAL_IDENTITY_TAG)
    def is_a(self) -> bool:
        return isinstance(self, TagEnum.A)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagEnum.RELAY_URL)
    def is_pow(self) -> bool:
        return isinstance(self, TagEnum.POW)
    def is_delegation(self) -> bool:
        return isinstance(self, TagEnum.DELEGATION)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagEnum.CONTENT_WARNING)
    def is_expiration(self) -> bool:
        return isinstance(self, TagEnum.EXPIRATION)
    def is_subject(self) -> bool:
        return isinstance(self, TagEnum.SUBJECT)
    def is_challenge(self) -> bool:
        return isinstance(self, TagEnum.CHALLENGE)
    def is_title(self) -> bool:
        return isinstance(self, TagEnum.TITLE)
    def is_image(self) -> bool:
        return isinstance(self, TagEnum.IMAGE)
    def is_thumb(self) -> bool:
        return isinstance(self, TagEnum.THUMB)
    def is_summary(self) -> bool:
        return isinstance(self, TagEnum.SUMMARY)
    def is_description(self) -> bool:
        return isinstance(self, TagEnum.DESCRIPTION)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagEnum.BOLT11)
    def is_preimage(self) -> bool:
        return isinstance(self, TagEnum.PREIMAGE)
    def is_relays(self) -> bool:
        return isinstance(self, TagEnum.RELAYS)
    def is_amount(self) -> bool:
        return isinstance(self, TagEnum.AMOUNT)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagEnum.LNURL)
    def is_name(self) -> bool:
        return isinstance(self, TagEnum.NAME)
    def is_published_at(self) -> bool:
        return isinstance(self, TagEnum.PUBLISHED_AT)
    def is_url_tag(self) -> bool:
        return isinstance(self, TagEnum.URL_TAG)
    def is_mime_type(self) -> bool:
        return isinstance(self, TagEnum.MIME_TYPE)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagEnum.AES256_GCM)
    def is_sha256(self) -> bool:
        return isinstance(self, TagEnum.SHA256)
    def is_size(self) -> bool:
        return isinstance(self, TagEnum.SIZE)
    def is_dim(self) -> bool:
        return isinstance(self, TagEnum.DIM)
    def is_magnet(self) -> bool:
        return isinstance(self, TagEnum.MAGNET)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagEnum.BLURHASH)
    def is_streaming(self) -> bool:
        return isinstance(self, TagEnum.STREAMING)
    def is_recording(self) -> bool:
        return isinstance(self, TagEnum.RECORDING)
    def is_starts(self) -> bool:
        return isinstance(self, TagEnum.STARTS)
    def is_ends(self) -> bool:
        return isinstance(self, TagEnum.ENDS)
    def is_live_event_status_tag(self) -> bool:
        return isinstance(self, TagEnum.LIVE_EVENT_STATUS_TAG)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagEnum.CURRENT_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagEnum.TOTAL_PARTICIPANTS)
    def is_absolute_url(self) -> bool:
        return isinstance(self, TagEnum.ABSOLUTE_URL)
    def is_method(self) -> bool:
        return isinstance(self, TagEnum.METHOD)
    def is_payload(self) -> bool:
        return isinstance(self, TagEnum.PAYLOAD)
    def is_anon(self) -> bool:
        return isinstance(self, TagEnum.ANON)
    def is_proxy(self) -> bool:
        return isinstance(self, TagEnum.PROXY)
    def is_emoji(self) -> bool:
        return isinstance(self, TagEnum.EMOJI)
    def is_encrypted(self) -> bool:
        return isinstance(self, TagEnum.ENCRYPTED)
    def is_request(self) -> bool:
        return isinstance(self, TagEnum.REQUEST)
    def is_data_vending_machine_status_tag(self) -> bool:
        return isinstance(self, TagEnum.DATA_VENDING_MACHINE_STATUS_TAG)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagEnum.UNKNOWN = type("TagEnum.UNKNOWN", (TagEnum.UNKNOWN, TagEnum,), {})  # type: ignore
TagEnum.EVENT_TAG = type("TagEnum.EVENT_TAG", (TagEnum.EVENT_TAG, TagEnum,), {})  # type: ignore
TagEnum.PUBLIC_KEY_TAG = type("TagEnum.PUBLIC_KEY_TAG", (TagEnum.PUBLIC_KEY_TAG, TagEnum,), {})  # type: ignore
TagEnum.EVENT_REPORT = type("TagEnum.EVENT_REPORT", (TagEnum.EVENT_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_REPORT = type("TagEnum.PUB_KEY_REPORT", (TagEnum.PUB_KEY_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_LIVE_EVENT = type("TagEnum.PUB_KEY_LIVE_EVENT", (TagEnum.PUB_KEY_LIVE_EVENT, TagEnum,), {})  # type: ignore
TagEnum.REFERENCE = type("TagEnum.REFERENCE", (TagEnum.REFERENCE, TagEnum,), {})  # type: ignore
TagEnum.RELAY_METADATA_TAG = type("TagEnum.RELAY_METADATA_TAG", (TagEnum.RELAY_METADATA_TAG, TagEnum,), {})  # type: ignore
TagEnum.HASHTAG = type("TagEnum.HASHTAG", (TagEnum.HASHTAG, TagEnum,), {})  # type: ignore
TagEnum.GEOHASH = type("TagEnum.GEOHASH", (TagEnum.GEOHASH, TagEnum,), {})  # type: ignore
TagEnum.IDENTIFIER = type("TagEnum.IDENTIFIER", (TagEnum.IDENTIFIER, TagEnum,), {})  # type: ignore
TagEnum.EXTERNAL_IDENTITY_TAG = type("TagEnum.EXTERNAL_IDENTITY_TAG", (TagEnum.EXTERNAL_IDENTITY_TAG, TagEnum,), {})  # type: ignore
TagEnum.A = type("TagEnum.A", (TagEnum.A, TagEnum,), {})  # type: ignore
TagEnum.RELAY_URL = type("TagEnum.RELAY_URL", (TagEnum.RELAY_URL, TagEnum,), {})  # type: ignore
TagEnum.POW = type("TagEnum.POW", (TagEnum.POW, TagEnum,), {})  # type: ignore
TagEnum.DELEGATION = type("TagEnum.DELEGATION", (TagEnum.DELEGATION, TagEnum,), {})  # type: ignore
TagEnum.CONTENT_WARNING = type("TagEnum.CONTENT_WARNING", (TagEnum.CONTENT_WARNING, TagEnum,), {})  # type: ignore
TagEnum.EXPIRATION = type("TagEnum.EXPIRATION", (TagEnum.EXPIRATION, TagEnum,), {})  # type: ignore
TagEnum.SUBJECT = type("TagEnum.SUBJECT", (TagEnum.SUBJECT, TagEnum,), {})  # type: ignore
TagEnum.CHALLENGE = type("TagEnum.CHALLENGE", (TagEnum.CHALLENGE, TagEnum,), {})  # type: ignore
TagEnum.TITLE = type("TagEnum.TITLE", (TagEnum.TITLE, TagEnum,), {})  # type: ignore
TagEnum.IMAGE = type("TagEnum.IMAGE", (TagEnum.IMAGE, TagEnum,), {})  # type: ignore
TagEnum.THUMB = type("TagEnum.THUMB", (TagEnum.THUMB, TagEnum,), {})  # type: ignore
TagEnum.SUMMARY = type("TagEnum.SUMMARY", (TagEnum.SUMMARY, TagEnum,), {})  # type: ignore
TagEnum.DESCRIPTION = type("TagEnum.DESCRIPTION", (TagEnum.DESCRIPTION, TagEnum,), {})  # type: ignore
TagEnum.BOLT11 = type("TagEnum.BOLT11", (TagEnum.BOLT11, TagEnum,), {})  # type: ignore
TagEnum.PREIMAGE = type("TagEnum.PREIMAGE", (TagEnum.PREIMAGE, TagEnum,), {})  # type: ignore
TagEnum.RELAYS = type("TagEnum.RELAYS", (TagEnum.RELAYS, TagEnum,), {})  # type: ignore
TagEnum.AMOUNT = type("TagEnum.AMOUNT", (TagEnum.AMOUNT, TagEnum,), {})  # type: ignore
TagEnum.LNURL = type("TagEnum.LNURL", (TagEnum.LNURL, TagEnum,), {})  # type: ignore
TagEnum.NAME = type("TagEnum.NAME", (TagEnum.NAME, TagEnum,), {})  # type: ignore
TagEnum.PUBLISHED_AT = type("TagEnum.PUBLISHED_AT", (TagEnum.PUBLISHED_AT, TagEnum,), {})  # type: ignore
TagEnum.URL_TAG = type("TagEnum.URL_TAG", (TagEnum.URL_TAG, TagEnum,), {})  # type: ignore
TagEnum.MIME_TYPE = type("TagEnum.MIME_TYPE", (TagEnum.MIME_TYPE, TagEnum,), {})  # type: ignore
TagEnum.AES256_GCM = type("TagEnum.AES256_GCM", (TagEnum.AES256_GCM, TagEnum,), {})  # type: ignore
TagEnum.SHA256 = type("TagEnum.SHA256", (TagEnum.SHA256, TagEnum,), {})  # type: ignore
TagEnum.SIZE = type("TagEnum.SIZE", (TagEnum.SIZE, TagEnum,), {})  # type: ignore
TagEnum.DIM = type("TagEnum.DIM", (TagEnum.DIM, TagEnum,), {})  # type: ignore
TagEnum.MAGNET = type("TagEnum.MAGNET", (TagEnum.MAGNET, TagEnum,), {})  # type: ignore
TagEnum.BLURHASH = type("TagEnum.BLURHASH", (TagEnum.BLURHASH, TagEnum,), {})  # type: ignore
TagEnum.STREAMING = type("TagEnum.STREAMING", (TagEnum.STREAMING, TagEnum,), {})  # type: ignore
TagEnum.RECORDING = type("TagEnum.RECORDING", (TagEnum.RECORDING, TagEnum,), {})  # type: ignore
TagEnum.STARTS = type("TagEnum.STARTS", (TagEnum.STARTS, TagEnum,), {})  # type: ignore
TagEnum.ENDS = type("TagEnum.ENDS", (TagEnum.ENDS, TagEnum,), {})  # type: ignore
TagEnum.LIVE_EVENT_STATUS_TAG = type("TagEnum.LIVE_EVENT_STATUS_TAG", (TagEnum.LIVE_EVENT_STATUS_TAG, TagEnum,), {})  # type: ignore
TagEnum.CURRENT_PARTICIPANTS = type("TagEnum.CURRENT_PARTICIPANTS", (TagEnum.CURRENT_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.TOTAL_PARTICIPANTS = type("TagEnum.TOTAL_PARTICIPANTS", (TagEnum.TOTAL_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.ABSOLUTE_URL = type("TagEnum.ABSOLUTE_URL", (TagEnum.ABSOLUTE_URL, TagEnum,), {})  # type: ignore
TagEnum.METHOD = type("TagEnum.METHOD", (TagEnum.METHOD, TagEnum,), {})  # type: ignore
TagEnum.PAYLOAD = type("TagEnum.PAYLOAD", (TagEnum.PAYLOAD, TagEnum,), {})  # type: ignore
TagEnum.ANON = type("TagEnum.ANON", (TagEnum.ANON, TagEnum,), {})  # type: ignore
TagEnum.PROXY = type("TagEnum.PROXY", (TagEnum.PROXY, TagEnum,), {})  # type: ignore
TagEnum.EMOJI = type("TagEnum.EMOJI", (TagEnum.EMOJI, TagEnum,), {})  # type: ignore
TagEnum.ENCRYPTED = type("TagEnum.ENCRYPTED", (TagEnum.ENCRYPTED, TagEnum,), {})  # type: ignore
TagEnum.REQUEST = type("TagEnum.REQUEST", (TagEnum.REQUEST, TagEnum,), {})  # type: ignore
TagEnum.DATA_VENDING_MACHINE_STATUS_TAG = type("TagEnum.DATA_VENDING_MACHINE_STATUS_TAG", (TagEnum.DATA_VENDING_MACHINE_STATUS_TAG, TagEnum,), {})  # type: ignore




class _UniffiConverterTypeTagEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagEnum.UNKNOWN(
                _UniffiConverterTypeTagKind.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 2:
            return TagEnum.EVENT_TAG(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalTypeMarker.read(buf),
            )
        if variant == 3:
            return TagEnum.PUBLIC_KEY_TAG(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 4:
            return TagEnum.EVENT_REPORT(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 5:
            return TagEnum.PUB_KEY_REPORT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 6:
            return TagEnum.PUB_KEY_LIVE_EVENT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterTypeLiveEventMarker.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 7:
            return TagEnum.REFERENCE(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return TagEnum.RELAY_METADATA_TAG(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeRelayMetadata.read(buf),
            )
        if variant == 9:
            return TagEnum.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return TagEnum.GEOHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return TagEnum.IDENTIFIER(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return TagEnum.EXTERNAL_IDENTITY_TAG(
                _UniffiConverterTypeIdentity.read(buf),
            )
        if variant == 13:
            return TagEnum.A(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 14:
            return TagEnum.RELAY_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return TagEnum.POW(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 16:
            return TagEnum.DELEGATION(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return TagEnum.CONTENT_WARNING(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 18:
            return TagEnum.EXPIRATION(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 19:
            return TagEnum.SUBJECT(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return TagEnum.CHALLENGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return TagEnum.TITLE(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return TagEnum.IMAGE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 23:
            return TagEnum.THUMB(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 24:
            return TagEnum.SUMMARY(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return TagEnum.DESCRIPTION(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return TagEnum.BOLT11(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return TagEnum.PREIMAGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return TagEnum.RELAYS(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 29:
            return TagEnum.AMOUNT(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 30:
            return TagEnum.LNURL(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return TagEnum.NAME(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return TagEnum.PUBLISHED_AT(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 33:
            return TagEnum.URL_TAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 34:
            return TagEnum.MIME_TYPE(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return TagEnum.AES256_GCM(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return TagEnum.SHA256(
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return TagEnum.SIZE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 38:
            return TagEnum.DIM(
                _UniffiConverterTypeImageDimensions.read(buf),
            )
        if variant == 39:
            return TagEnum.MAGNET(
                _UniffiConverterString.read(buf),
            )
        if variant == 40:
            return TagEnum.BLURHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return TagEnum.STREAMING(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return TagEnum.RECORDING(
                _UniffiConverterString.read(buf),
            )
        if variant == 43:
            return TagEnum.STARTS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 44:
            return TagEnum.ENDS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 45:
            return TagEnum.LIVE_EVENT_STATUS_TAG(
                _UniffiConverterTypeLiveEventStatus.read(buf),
            )
        if variant == 46:
            return TagEnum.CURRENT_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 47:
            return TagEnum.TOTAL_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 48:
            return TagEnum.ABSOLUTE_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 49:
            return TagEnum.METHOD(
                _UniffiConverterTypeHttpMethod.read(buf),
            )
        if variant == 50:
            return TagEnum.PAYLOAD(
                _UniffiConverterString.read(buf),
            )
        if variant == 51:
            return TagEnum.ANON(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 52:
            return TagEnum.PROXY(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeProtocol.read(buf),
            )
        if variant == 53:
            return TagEnum.EMOJI(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 54:
            return TagEnum.ENCRYPTED(
            )
        if variant == 55:
            return TagEnum.REQUEST(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 56:
            return TagEnum.DATA_VENDING_MACHINE_STATUS_TAG(
                _UniffiConverterTypeDataVendingMachineStatus.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_unknown():
            _UniffiConverterTypeTagKind.check_lower(value.kind)
            _UniffiConverterSequenceString.check_lower(value.data)
            return
        if value.is_event_tag():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeMarker.check_lower(value.marker)
            return
        if value.is_public_key_tag():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterOptionalString.check_lower(value.alias)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_event_report():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_pub_key_report():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_pub_key_live_event():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterTypeLiveEventMarker.check_lower(value.marker)
            _UniffiConverterOptionalString.check_lower(value.proof)
            return
        if value.is_reference():
            _UniffiConverterString.check_lower(value.reference)
            return
        if value.is_relay_metadata_tag():
            _UniffiConverterString.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value.rw)
            return
        if value.is_hashtag():
            _UniffiConverterString.check_lower(value.hashtag)
            return
        if value.is_geohash():
            _UniffiConverterString.check_lower(value.geohash)
            return
        if value.is_identifier():
            _UniffiConverterString.check_lower(value.identifier)
            return
        if value.is_external_identity_tag():
            _UniffiConverterTypeIdentity.check_lower(value.identity)
            return
        if value.is_a():
            _UniffiConverterUInt64.check_lower(value.kind)
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.identifier)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            return
        if value.is_relay_url():
            _UniffiConverterString.check_lower(value.relay_url)
            return
        if value.is_pow():
            _UniffiConverterString.check_lower(value.nonce)
            _UniffiConverterUInt8.check_lower(value.difficulty)
            return
        if value.is_delegation():
            _UniffiConverterTypePublicKey.check_lower(value.delegator)
            _UniffiConverterString.check_lower(value.conditions)
            _UniffiConverterString.check_lower(value.sig)
            return
        if value.is_content_warning():
            _UniffiConverterOptionalString.check_lower(value.reason)
            return
        if value.is_expiration():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_subject():
            _UniffiConverterString.check_lower(value.subject)
            return
        if value.is_challenge():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_title():
            _UniffiConverterString.check_lower(value.title)
            return
        if value.is_image():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_thumb():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_summary():
            _UniffiConverterString.check_lower(value.summary)
            return
        if value.is_description():
            _UniffiConverterString.check_lower(value.desc)
            return
        if value.is_bolt11():
            _UniffiConverterString.check_lower(value.bolt11)
            return
        if value.is_preimage():
            _UniffiConverterString.check_lower(value.preimage)
            return
        if value.is_relays():
            _UniffiConverterSequenceString.check_lower(value.urls)
            return
        if value.is_amount():
            _UniffiConverterUInt64.check_lower(value.millisats)
            _UniffiConverterOptionalString.check_lower(value.bolt11)
            return
        if value.is_lnurl():
            _UniffiConverterString.check_lower(value.lnurl)
            return
        if value.is_name():
            _UniffiConverterString.check_lower(value.name)
            return
        if value.is_published_at():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_url_tag():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_mime_type():
            _UniffiConverterString.check_lower(value.mime)
            return
        if value.is_aes256_gcm():
            _UniffiConverterString.check_lower(value.key)
            _UniffiConverterString.check_lower(value.iv)
            return
        if value.is_sha256():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_size():
            _UniffiConverterUInt64.check_lower(value.size)
            return
        if value.is_dim():
            _UniffiConverterTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_magnet():
            _UniffiConverterString.check_lower(value.uri)
            return
        if value.is_blurhash():
            _UniffiConverterString.check_lower(value.blurhash)
            return
        if value.is_streaming():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_recording():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_starts():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_ends():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_live_event_status_tag():
            _UniffiConverterTypeLiveEventStatus.check_lower(value.status)
            return
        if value.is_current_participants():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_total_participants():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_absolute_url():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_method():
            _UniffiConverterTypeHttpMethod.check_lower(value.method)
            return
        if value.is_payload():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_anon():
            _UniffiConverterOptionalString.check_lower(value.msg)
            return
        if value.is_proxy():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterTypeProtocol.check_lower(value.protocol)
            return
        if value.is_emoji():
            _UniffiConverterString.check_lower(value.shortcode)
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_encrypted():
            return
        if value.is_request():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_data_vending_machine_status_tag():
            _UniffiConverterTypeDataVendingMachineStatus.check_lower(value.status)
            _UniffiConverterOptionalString.check_lower(value.extra_info)
            return

    @staticmethod
    def write(value, buf):
        if value.is_unknown():
            buf.write_i32(1)
            _UniffiConverterTypeTagKind.write(value.kind, buf)
            _UniffiConverterSequenceString.write(value.data, buf)
        if value.is_event_tag():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeMarker.write(value.marker, buf)
        if value.is_public_key_tag():
            buf.write_i32(3)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.alias, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_event_report():
            buf.write_i32(4)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_pub_key_report():
            buf.write_i32(5)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_pub_key_live_event():
            buf.write_i32(6)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterTypeLiveEventMarker.write(value.marker, buf)
            _UniffiConverterOptionalString.write(value.proof, buf)
        if value.is_reference():
            buf.write_i32(7)
            _UniffiConverterString.write(value.reference, buf)
        if value.is_relay_metadata_tag():
            buf.write_i32(8)
            _UniffiConverterString.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value.rw, buf)
        if value.is_hashtag():
            buf.write_i32(9)
            _UniffiConverterString.write(value.hashtag, buf)
        if value.is_geohash():
            buf.write_i32(10)
            _UniffiConverterString.write(value.geohash, buf)
        if value.is_identifier():
            buf.write_i32(11)
            _UniffiConverterString.write(value.identifier, buf)
        if value.is_external_identity_tag():
            buf.write_i32(12)
            _UniffiConverterTypeIdentity.write(value.identity, buf)
        if value.is_a():
            buf.write_i32(13)
            _UniffiConverterUInt64.write(value.kind, buf)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.identifier, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
        if value.is_relay_url():
            buf.write_i32(14)
            _UniffiConverterString.write(value.relay_url, buf)
        if value.is_pow():
            buf.write_i32(15)
            _UniffiConverterString.write(value.nonce, buf)
            _UniffiConverterUInt8.write(value.difficulty, buf)
        if value.is_delegation():
            buf.write_i32(16)
            _UniffiConverterTypePublicKey.write(value.delegator, buf)
            _UniffiConverterString.write(value.conditions, buf)
            _UniffiConverterString.write(value.sig, buf)
        if value.is_content_warning():
            buf.write_i32(17)
            _UniffiConverterOptionalString.write(value.reason, buf)
        if value.is_expiration():
            buf.write_i32(18)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_subject():
            buf.write_i32(19)
            _UniffiConverterString.write(value.subject, buf)
        if value.is_challenge():
            buf.write_i32(20)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_title():
            buf.write_i32(21)
            _UniffiConverterString.write(value.title, buf)
        if value.is_image():
            buf.write_i32(22)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_thumb():
            buf.write_i32(23)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_summary():
            buf.write_i32(24)
            _UniffiConverterString.write(value.summary, buf)
        if value.is_description():
            buf.write_i32(25)
            _UniffiConverterString.write(value.desc, buf)
        if value.is_bolt11():
            buf.write_i32(26)
            _UniffiConverterString.write(value.bolt11, buf)
        if value.is_preimage():
            buf.write_i32(27)
            _UniffiConverterString.write(value.preimage, buf)
        if value.is_relays():
            buf.write_i32(28)
            _UniffiConverterSequenceString.write(value.urls, buf)
        if value.is_amount():
            buf.write_i32(29)
            _UniffiConverterUInt64.write(value.millisats, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_lnurl():
            buf.write_i32(30)
            _UniffiConverterString.write(value.lnurl, buf)
        if value.is_name():
            buf.write_i32(31)
            _UniffiConverterString.write(value.name, buf)
        if value.is_published_at():
            buf.write_i32(32)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_url_tag():
            buf.write_i32(33)
            _UniffiConverterString.write(value.url, buf)
        if value.is_mime_type():
            buf.write_i32(34)
            _UniffiConverterString.write(value.mime, buf)
        if value.is_aes256_gcm():
            buf.write_i32(35)
            _UniffiConverterString.write(value.key, buf)
            _UniffiConverterString.write(value.iv, buf)
        if value.is_sha256():
            buf.write_i32(36)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_size():
            buf.write_i32(37)
            _UniffiConverterUInt64.write(value.size, buf)
        if value.is_dim():
            buf.write_i32(38)
            _UniffiConverterTypeImageDimensions.write(value.dimensions, buf)
        if value.is_magnet():
            buf.write_i32(39)
            _UniffiConverterString.write(value.uri, buf)
        if value.is_blurhash():
            buf.write_i32(40)
            _UniffiConverterString.write(value.blurhash, buf)
        if value.is_streaming():
            buf.write_i32(41)
            _UniffiConverterString.write(value.url, buf)
        if value.is_recording():
            buf.write_i32(42)
            _UniffiConverterString.write(value.url, buf)
        if value.is_starts():
            buf.write_i32(43)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_ends():
            buf.write_i32(44)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_live_event_status_tag():
            buf.write_i32(45)
            _UniffiConverterTypeLiveEventStatus.write(value.status, buf)
        if value.is_current_participants():
            buf.write_i32(46)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_total_participants():
            buf.write_i32(47)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_absolute_url():
            buf.write_i32(48)
            _UniffiConverterString.write(value.url, buf)
        if value.is_method():
            buf.write_i32(49)
            _UniffiConverterTypeHttpMethod.write(value.method, buf)
        if value.is_payload():
            buf.write_i32(50)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_anon():
            buf.write_i32(51)
            _UniffiConverterOptionalString.write(value.msg, buf)
        if value.is_proxy():
            buf.write_i32(52)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterTypeProtocol.write(value.protocol, buf)
        if value.is_emoji():
            buf.write_i32(53)
            _UniffiConverterString.write(value.shortcode, buf)
            _UniffiConverterString.write(value.url, buf)
        if value.is_encrypted():
            buf.write_i32(54)
        if value.is_request():
            buf.write_i32(55)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_data_vending_machine_status_tag():
            buf.write_i32(56)
            _UniffiConverterTypeDataVendingMachineStatus.write(value.status, buf)
            _UniffiConverterOptionalString.write(value.extra_info, buf)







class TagKind:
    def __init__(self):
        raise RuntimeError("TagKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class P:
        """Public key"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.P()".format()

        def __eq__(self, other):
            if not other.is_p():
                return False
            return True
    class UPPER_P:
        """Public key"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.UPPER_P()".format()

        def __eq__(self, other):
            if not other.is_upper_p():
                return False
            return True
    class E:
        """Event id"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.E()".format()

        def __eq__(self, other):
            if not other.is_e():
                return False
            return True
    class R:
        """Reference (URL, etc.)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.R()".format()

        def __eq__(self, other):
            if not other.is_r():
                return False
            return True
    class T:
        """Hashtag"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.T()".format()

        def __eq__(self, other):
            if not other.is_t():
                return False
            return True
    class G:
        """Geohash"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.G()".format()

        def __eq__(self, other):
            if not other.is_g():
                return False
            return True
    class D:
        """Identifier"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.D()".format()

        def __eq__(self, other):
            if not other.is_d():
                return False
            return True
    class A:
        """Referencing and tagging"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.A()".format()

        def __eq__(self, other):
            if not other.is_a():
                return False
            return True
    class I:
        """External Identities"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.I()".format()

        def __eq__(self, other):
            if not other.is_i():
                return False
            return True
    class M:
        """MIME type"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.M()".format()

        def __eq__(self, other):
            if not other.is_m():
                return False
            return True
    class U:
        """Absolute URL"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.U()".format()

        def __eq__(self, other):
            if not other.is_u():
                return False
            return True
    class X:
        """SHA256"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.X()".format()

        def __eq__(self, other):
            if not other.is_x():
                return False
            return True
    class RELAY_URL:
        """Relay"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.RELAY_URL()".format()

        def __eq__(self, other):
            if not other.is_relay_url():
                return False
            return True
    class NONCE:
        """Nonce"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.NONCE()".format()

        def __eq__(self, other):
            if not other.is_nonce():
                return False
            return True
    class DELEGATION:
        """Delegation"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.DELEGATION()".format()

        def __eq__(self, other):
            if not other.is_delegation():
                return False
            return True
    class CONTENT_WARNING:
        """Content warning"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.CONTENT_WARNING()".format()

        def __eq__(self, other):
            if not other.is_content_warning():
                return False
            return True
    class EXPIRATION:
        """Expiration"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.EXPIRATION()".format()

        def __eq__(self, other):
            if not other.is_expiration():
                return False
            return True
    class SUBJECT:
        """Subject"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.SUBJECT()".format()

        def __eq__(self, other):
            if not other.is_subject():
                return False
            return True
    class CHALLENGE:
        """Auth challenge"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.CHALLENGE()".format()

        def __eq__(self, other):
            if not other.is_challenge():
                return False
            return True
    class TITLE:
        """Title (NIP23)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.TITLE()".format()

        def __eq__(self, other):
            if not other.is_title():
                return False
            return True
    class IMAGE:
        """Image (NIP23)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.IMAGE()".format()

        def __eq__(self, other):
            if not other.is_image():
                return False
            return True
    class THUMB:
        """Thumbnail"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.THUMB()".format()

        def __eq__(self, other):
            if not other.is_thumb():
                return False
            return True
    class SUMMARY:
        """Summary (NIP23)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.SUMMARY()".format()

        def __eq__(self, other):
            if not other.is_summary():
                return False
            return True
    class PUBLISHED_AT:
        """PublishedAt (NIP23)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.PUBLISHED_AT()".format()

        def __eq__(self, other):
            if not other.is_published_at():
                return False
            return True
    class DESCRIPTION:
        """Description (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.DESCRIPTION()".format()

        def __eq__(self, other):
            if not other.is_description():
                return False
            return True
    class BOLT11:
        """Bolt11 Invoice (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.BOLT11()".format()

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            return True
    class PREIMAGE:
        """Preimage (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.PREIMAGE()".format()

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            return True
    class RELAYS:
        """Relays (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.RELAYS()".format()

        def __eq__(self, other):
            if not other.is_relays():
                return False
            return True
    class AMOUNT:
        """Amount (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.AMOUNT()".format()

        def __eq__(self, other):
            if not other.is_amount():
                return False
            return True
    class LNURL:
        """Lnurl (NIP57)"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.LNURL()".format()

        def __eq__(self, other):
            if not other.is_lnurl():
                return False
            return True
    class NAME:
        """Name tag"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.NAME()".format()

        def __eq__(self, other):
            if not other.is_name():
                return False
            return True
    class URL:
        """Url"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.URL()".format()

        def __eq__(self, other):
            if not other.is_url():
                return False
            return True
    class AES256_GCM:
        """AES 256 GCM"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.AES256_GCM()".format()

        def __eq__(self, other):
            if not other.is_aes256_gcm():
                return False
            return True
    class SIZE:
        """Size of file in bytes"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.SIZE()".format()

        def __eq__(self, other):
            if not other.is_size():
                return False
            return True
    class DIM:
        """Size of file in pixels"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.DIM()".format()

        def __eq__(self, other):
            if not other.is_dim():
                return False
            return True
    class MAGNET:
        """Magnet"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.MAGNET()".format()

        def __eq__(self, other):
            if not other.is_magnet():
                return False
            return True
    class BLURHASH:
        """Blurhash"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.BLURHASH()".format()

        def __eq__(self, other):
            if not other.is_blurhash():
                return False
            return True
    class STREAMING:
        """Streaming"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.STREAMING()".format()

        def __eq__(self, other):
            if not other.is_streaming():
                return False
            return True
    class RECORDING:
        """Recording"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.RECORDING()".format()

        def __eq__(self, other):
            if not other.is_recording():
                return False
            return True
    class STARTS:
        """Starts"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.STARTS()".format()

        def __eq__(self, other):
            if not other.is_starts():
                return False
            return True
    class ENDS:
        """Ends"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.ENDS()".format()

        def __eq__(self, other):
            if not other.is_ends():
                return False
            return True
    class STATUS:
        """Status"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.STATUS()".format()

        def __eq__(self, other):
            if not other.is_status():
                return False
            return True
    class CURRENT_PARTICIPANTS:
        """Current participants"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.CURRENT_PARTICIPANTS()".format()

        def __eq__(self, other):
            if not other.is_current_participants():
                return False
            return True
    class TOTAL_PARTICIPANTS:
        """Total participants"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.TOTAL_PARTICIPANTS()".format()

        def __eq__(self, other):
            if not other.is_total_participants():
                return False
            return True
    class METHOD:
        """HTTP Method Request"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.METHOD()".format()

        def __eq__(self, other):
            if not other.is_method():
                return False
            return True
    class PAYLOAD:
        """Payload HASH"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.PAYLOAD()".format()

        def __eq__(self, other):
            if not other.is_payload():
                return False
            return True
    class ANON:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.ANON()".format()

        def __eq__(self, other):
            if not other.is_anon():
                return False
            return True
    class PROXY:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.PROXY()".format()

        def __eq__(self, other):
            if not other.is_proxy():
                return False
            return True
    class EMOJI:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.EMOJI()".format()

        def __eq__(self, other):
            if not other.is_emoji():
                return False
            return True
    class ENCRYPTED:
        """Encrypted"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.ENCRYPTED()".format()

        def __eq__(self, other):
            if not other.is_encrypted():
                return False
            return True
    class REQUEST:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TagKind.REQUEST()".format()

        def __eq__(self, other):
            if not other.is_request():
                return False
            return True
    class UNKNOWN:
        unknown: "str"

        @typing.no_type_check
        def __init__(self,unknown: "str"):
            
            self.unknown = unknown
            

        def __str__(self):
            return "TagKind.UNKNOWN(unknown={})".format(self.unknown)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.unknown != other.unknown:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_p(self) -> bool:
        return isinstance(self, TagKind.P)
    def is_upper_p(self) -> bool:
        return isinstance(self, TagKind.UPPER_P)
    def is_e(self) -> bool:
        return isinstance(self, TagKind.E)
    def is_r(self) -> bool:
        return isinstance(self, TagKind.R)
    def is_t(self) -> bool:
        return isinstance(self, TagKind.T)
    def is_g(self) -> bool:
        return isinstance(self, TagKind.G)
    def is_d(self) -> bool:
        return isinstance(self, TagKind.D)
    def is_a(self) -> bool:
        return isinstance(self, TagKind.A)
    def is_i(self) -> bool:
        return isinstance(self, TagKind.I)
    def is_m(self) -> bool:
        return isinstance(self, TagKind.M)
    def is_u(self) -> bool:
        return isinstance(self, TagKind.U)
    def is_x(self) -> bool:
        return isinstance(self, TagKind.X)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagKind.RELAY_URL)
    def is_nonce(self) -> bool:
        return isinstance(self, TagKind.NONCE)
    def is_delegation(self) -> bool:
        return isinstance(self, TagKind.DELEGATION)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagKind.CONTENT_WARNING)
    def is_expiration(self) -> bool:
        return isinstance(self, TagKind.EXPIRATION)
    def is_subject(self) -> bool:
        return isinstance(self, TagKind.SUBJECT)
    def is_challenge(self) -> bool:
        return isinstance(self, TagKind.CHALLENGE)
    def is_title(self) -> bool:
        return isinstance(self, TagKind.TITLE)
    def is_image(self) -> bool:
        return isinstance(self, TagKind.IMAGE)
    def is_thumb(self) -> bool:
        return isinstance(self, TagKind.THUMB)
    def is_summary(self) -> bool:
        return isinstance(self, TagKind.SUMMARY)
    def is_published_at(self) -> bool:
        return isinstance(self, TagKind.PUBLISHED_AT)
    def is_description(self) -> bool:
        return isinstance(self, TagKind.DESCRIPTION)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagKind.BOLT11)
    def is_preimage(self) -> bool:
        return isinstance(self, TagKind.PREIMAGE)
    def is_relays(self) -> bool:
        return isinstance(self, TagKind.RELAYS)
    def is_amount(self) -> bool:
        return isinstance(self, TagKind.AMOUNT)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagKind.LNURL)
    def is_name(self) -> bool:
        return isinstance(self, TagKind.NAME)
    def is_url(self) -> bool:
        return isinstance(self, TagKind.URL)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagKind.AES256_GCM)
    def is_size(self) -> bool:
        return isinstance(self, TagKind.SIZE)
    def is_dim(self) -> bool:
        return isinstance(self, TagKind.DIM)
    def is_magnet(self) -> bool:
        return isinstance(self, TagKind.MAGNET)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagKind.BLURHASH)
    def is_streaming(self) -> bool:
        return isinstance(self, TagKind.STREAMING)
    def is_recording(self) -> bool:
        return isinstance(self, TagKind.RECORDING)
    def is_starts(self) -> bool:
        return isinstance(self, TagKind.STARTS)
    def is_ends(self) -> bool:
        return isinstance(self, TagKind.ENDS)
    def is_status(self) -> bool:
        return isinstance(self, TagKind.STATUS)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagKind.CURRENT_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagKind.TOTAL_PARTICIPANTS)
    def is_method(self) -> bool:
        return isinstance(self, TagKind.METHOD)
    def is_payload(self) -> bool:
        return isinstance(self, TagKind.PAYLOAD)
    def is_anon(self) -> bool:
        return isinstance(self, TagKind.ANON)
    def is_proxy(self) -> bool:
        return isinstance(self, TagKind.PROXY)
    def is_emoji(self) -> bool:
        return isinstance(self, TagKind.EMOJI)
    def is_encrypted(self) -> bool:
        return isinstance(self, TagKind.ENCRYPTED)
    def is_request(self) -> bool:
        return isinstance(self, TagKind.REQUEST)
    def is_unknown(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagKind.P = type("TagKind.P", (TagKind.P, TagKind,), {})  # type: ignore
TagKind.UPPER_P = type("TagKind.UPPER_P", (TagKind.UPPER_P, TagKind,), {})  # type: ignore
TagKind.E = type("TagKind.E", (TagKind.E, TagKind,), {})  # type: ignore
TagKind.R = type("TagKind.R", (TagKind.R, TagKind,), {})  # type: ignore
TagKind.T = type("TagKind.T", (TagKind.T, TagKind,), {})  # type: ignore
TagKind.G = type("TagKind.G", (TagKind.G, TagKind,), {})  # type: ignore
TagKind.D = type("TagKind.D", (TagKind.D, TagKind,), {})  # type: ignore
TagKind.A = type("TagKind.A", (TagKind.A, TagKind,), {})  # type: ignore
TagKind.I = type("TagKind.I", (TagKind.I, TagKind,), {})  # type: ignore
TagKind.M = type("TagKind.M", (TagKind.M, TagKind,), {})  # type: ignore
TagKind.U = type("TagKind.U", (TagKind.U, TagKind,), {})  # type: ignore
TagKind.X = type("TagKind.X", (TagKind.X, TagKind,), {})  # type: ignore
TagKind.RELAY_URL = type("TagKind.RELAY_URL", (TagKind.RELAY_URL, TagKind,), {})  # type: ignore
TagKind.NONCE = type("TagKind.NONCE", (TagKind.NONCE, TagKind,), {})  # type: ignore
TagKind.DELEGATION = type("TagKind.DELEGATION", (TagKind.DELEGATION, TagKind,), {})  # type: ignore
TagKind.CONTENT_WARNING = type("TagKind.CONTENT_WARNING", (TagKind.CONTENT_WARNING, TagKind,), {})  # type: ignore
TagKind.EXPIRATION = type("TagKind.EXPIRATION", (TagKind.EXPIRATION, TagKind,), {})  # type: ignore
TagKind.SUBJECT = type("TagKind.SUBJECT", (TagKind.SUBJECT, TagKind,), {})  # type: ignore
TagKind.CHALLENGE = type("TagKind.CHALLENGE", (TagKind.CHALLENGE, TagKind,), {})  # type: ignore
TagKind.TITLE = type("TagKind.TITLE", (TagKind.TITLE, TagKind,), {})  # type: ignore
TagKind.IMAGE = type("TagKind.IMAGE", (TagKind.IMAGE, TagKind,), {})  # type: ignore
TagKind.THUMB = type("TagKind.THUMB", (TagKind.THUMB, TagKind,), {})  # type: ignore
TagKind.SUMMARY = type("TagKind.SUMMARY", (TagKind.SUMMARY, TagKind,), {})  # type: ignore
TagKind.PUBLISHED_AT = type("TagKind.PUBLISHED_AT", (TagKind.PUBLISHED_AT, TagKind,), {})  # type: ignore
TagKind.DESCRIPTION = type("TagKind.DESCRIPTION", (TagKind.DESCRIPTION, TagKind,), {})  # type: ignore
TagKind.BOLT11 = type("TagKind.BOLT11", (TagKind.BOLT11, TagKind,), {})  # type: ignore
TagKind.PREIMAGE = type("TagKind.PREIMAGE", (TagKind.PREIMAGE, TagKind,), {})  # type: ignore
TagKind.RELAYS = type("TagKind.RELAYS", (TagKind.RELAYS, TagKind,), {})  # type: ignore
TagKind.AMOUNT = type("TagKind.AMOUNT", (TagKind.AMOUNT, TagKind,), {})  # type: ignore
TagKind.LNURL = type("TagKind.LNURL", (TagKind.LNURL, TagKind,), {})  # type: ignore
TagKind.NAME = type("TagKind.NAME", (TagKind.NAME, TagKind,), {})  # type: ignore
TagKind.URL = type("TagKind.URL", (TagKind.URL, TagKind,), {})  # type: ignore
TagKind.AES256_GCM = type("TagKind.AES256_GCM", (TagKind.AES256_GCM, TagKind,), {})  # type: ignore
TagKind.SIZE = type("TagKind.SIZE", (TagKind.SIZE, TagKind,), {})  # type: ignore
TagKind.DIM = type("TagKind.DIM", (TagKind.DIM, TagKind,), {})  # type: ignore
TagKind.MAGNET = type("TagKind.MAGNET", (TagKind.MAGNET, TagKind,), {})  # type: ignore
TagKind.BLURHASH = type("TagKind.BLURHASH", (TagKind.BLURHASH, TagKind,), {})  # type: ignore
TagKind.STREAMING = type("TagKind.STREAMING", (TagKind.STREAMING, TagKind,), {})  # type: ignore
TagKind.RECORDING = type("TagKind.RECORDING", (TagKind.RECORDING, TagKind,), {})  # type: ignore
TagKind.STARTS = type("TagKind.STARTS", (TagKind.STARTS, TagKind,), {})  # type: ignore
TagKind.ENDS = type("TagKind.ENDS", (TagKind.ENDS, TagKind,), {})  # type: ignore
TagKind.STATUS = type("TagKind.STATUS", (TagKind.STATUS, TagKind,), {})  # type: ignore
TagKind.CURRENT_PARTICIPANTS = type("TagKind.CURRENT_PARTICIPANTS", (TagKind.CURRENT_PARTICIPANTS, TagKind,), {})  # type: ignore
TagKind.TOTAL_PARTICIPANTS = type("TagKind.TOTAL_PARTICIPANTS", (TagKind.TOTAL_PARTICIPANTS, TagKind,), {})  # type: ignore
TagKind.METHOD = type("TagKind.METHOD", (TagKind.METHOD, TagKind,), {})  # type: ignore
TagKind.PAYLOAD = type("TagKind.PAYLOAD", (TagKind.PAYLOAD, TagKind,), {})  # type: ignore
TagKind.ANON = type("TagKind.ANON", (TagKind.ANON, TagKind,), {})  # type: ignore
TagKind.PROXY = type("TagKind.PROXY", (TagKind.PROXY, TagKind,), {})  # type: ignore
TagKind.EMOJI = type("TagKind.EMOJI", (TagKind.EMOJI, TagKind,), {})  # type: ignore
TagKind.ENCRYPTED = type("TagKind.ENCRYPTED", (TagKind.ENCRYPTED, TagKind,), {})  # type: ignore
TagKind.REQUEST = type("TagKind.REQUEST", (TagKind.REQUEST, TagKind,), {})  # type: ignore
TagKind.UNKNOWN = type("TagKind.UNKNOWN", (TagKind.UNKNOWN, TagKind,), {})  # type: ignore




class _UniffiConverterTypeTagKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKind.P(
            )
        if variant == 2:
            return TagKind.UPPER_P(
            )
        if variant == 3:
            return TagKind.E(
            )
        if variant == 4:
            return TagKind.R(
            )
        if variant == 5:
            return TagKind.T(
            )
        if variant == 6:
            return TagKind.G(
            )
        if variant == 7:
            return TagKind.D(
            )
        if variant == 8:
            return TagKind.A(
            )
        if variant == 9:
            return TagKind.I(
            )
        if variant == 10:
            return TagKind.M(
            )
        if variant == 11:
            return TagKind.U(
            )
        if variant == 12:
            return TagKind.X(
            )
        if variant == 13:
            return TagKind.RELAY_URL(
            )
        if variant == 14:
            return TagKind.NONCE(
            )
        if variant == 15:
            return TagKind.DELEGATION(
            )
        if variant == 16:
            return TagKind.CONTENT_WARNING(
            )
        if variant == 17:
            return TagKind.EXPIRATION(
            )
        if variant == 18:
            return TagKind.SUBJECT(
            )
        if variant == 19:
            return TagKind.CHALLENGE(
            )
        if variant == 20:
            return TagKind.TITLE(
            )
        if variant == 21:
            return TagKind.IMAGE(
            )
        if variant == 22:
            return TagKind.THUMB(
            )
        if variant == 23:
            return TagKind.SUMMARY(
            )
        if variant == 24:
            return TagKind.PUBLISHED_AT(
            )
        if variant == 25:
            return TagKind.DESCRIPTION(
            )
        if variant == 26:
            return TagKind.BOLT11(
            )
        if variant == 27:
            return TagKind.PREIMAGE(
            )
        if variant == 28:
            return TagKind.RELAYS(
            )
        if variant == 29:
            return TagKind.AMOUNT(
            )
        if variant == 30:
            return TagKind.LNURL(
            )
        if variant == 31:
            return TagKind.NAME(
            )
        if variant == 32:
            return TagKind.URL(
            )
        if variant == 33:
            return TagKind.AES256_GCM(
            )
        if variant == 34:
            return TagKind.SIZE(
            )
        if variant == 35:
            return TagKind.DIM(
            )
        if variant == 36:
            return TagKind.MAGNET(
            )
        if variant == 37:
            return TagKind.BLURHASH(
            )
        if variant == 38:
            return TagKind.STREAMING(
            )
        if variant == 39:
            return TagKind.RECORDING(
            )
        if variant == 40:
            return TagKind.STARTS(
            )
        if variant == 41:
            return TagKind.ENDS(
            )
        if variant == 42:
            return TagKind.STATUS(
            )
        if variant == 43:
            return TagKind.CURRENT_PARTICIPANTS(
            )
        if variant == 44:
            return TagKind.TOTAL_PARTICIPANTS(
            )
        if variant == 45:
            return TagKind.METHOD(
            )
        if variant == 46:
            return TagKind.PAYLOAD(
            )
        if variant == 47:
            return TagKind.ANON(
            )
        if variant == 48:
            return TagKind.PROXY(
            )
        if variant == 49:
            return TagKind.EMOJI(
            )
        if variant == 50:
            return TagKind.ENCRYPTED(
            )
        if variant == 51:
            return TagKind.REQUEST(
            )
        if variant == 52:
            return TagKind.UNKNOWN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_p():
            return
        if value.is_upper_p():
            return
        if value.is_e():
            return
        if value.is_r():
            return
        if value.is_t():
            return
        if value.is_g():
            return
        if value.is_d():
            return
        if value.is_a():
            return
        if value.is_i():
            return
        if value.is_m():
            return
        if value.is_u():
            return
        if value.is_x():
            return
        if value.is_relay_url():
            return
        if value.is_nonce():
            return
        if value.is_delegation():
            return
        if value.is_content_warning():
            return
        if value.is_expiration():
            return
        if value.is_subject():
            return
        if value.is_challenge():
            return
        if value.is_title():
            return
        if value.is_image():
            return
        if value.is_thumb():
            return
        if value.is_summary():
            return
        if value.is_published_at():
            return
        if value.is_description():
            return
        if value.is_bolt11():
            return
        if value.is_preimage():
            return
        if value.is_relays():
            return
        if value.is_amount():
            return
        if value.is_lnurl():
            return
        if value.is_name():
            return
        if value.is_url():
            return
        if value.is_aes256_gcm():
            return
        if value.is_size():
            return
        if value.is_dim():
            return
        if value.is_magnet():
            return
        if value.is_blurhash():
            return
        if value.is_streaming():
            return
        if value.is_recording():
            return
        if value.is_starts():
            return
        if value.is_ends():
            return
        if value.is_status():
            return
        if value.is_current_participants():
            return
        if value.is_total_participants():
            return
        if value.is_method():
            return
        if value.is_payload():
            return
        if value.is_anon():
            return
        if value.is_proxy():
            return
        if value.is_emoji():
            return
        if value.is_encrypted():
            return
        if value.is_request():
            return
        if value.is_unknown():
            _UniffiConverterString.check_lower(value.unknown)
            return

    @staticmethod
    def write(value, buf):
        if value.is_p():
            buf.write_i32(1)
        if value.is_upper_p():
            buf.write_i32(2)
        if value.is_e():
            buf.write_i32(3)
        if value.is_r():
            buf.write_i32(4)
        if value.is_t():
            buf.write_i32(5)
        if value.is_g():
            buf.write_i32(6)
        if value.is_d():
            buf.write_i32(7)
        if value.is_a():
            buf.write_i32(8)
        if value.is_i():
            buf.write_i32(9)
        if value.is_m():
            buf.write_i32(10)
        if value.is_u():
            buf.write_i32(11)
        if value.is_x():
            buf.write_i32(12)
        if value.is_relay_url():
            buf.write_i32(13)
        if value.is_nonce():
            buf.write_i32(14)
        if value.is_delegation():
            buf.write_i32(15)
        if value.is_content_warning():
            buf.write_i32(16)
        if value.is_expiration():
            buf.write_i32(17)
        if value.is_subject():
            buf.write_i32(18)
        if value.is_challenge():
            buf.write_i32(19)
        if value.is_title():
            buf.write_i32(20)
        if value.is_image():
            buf.write_i32(21)
        if value.is_thumb():
            buf.write_i32(22)
        if value.is_summary():
            buf.write_i32(23)
        if value.is_published_at():
            buf.write_i32(24)
        if value.is_description():
            buf.write_i32(25)
        if value.is_bolt11():
            buf.write_i32(26)
        if value.is_preimage():
            buf.write_i32(27)
        if value.is_relays():
            buf.write_i32(28)
        if value.is_amount():
            buf.write_i32(29)
        if value.is_lnurl():
            buf.write_i32(30)
        if value.is_name():
            buf.write_i32(31)
        if value.is_url():
            buf.write_i32(32)
        if value.is_aes256_gcm():
            buf.write_i32(33)
        if value.is_size():
            buf.write_i32(34)
        if value.is_dim():
            buf.write_i32(35)
        if value.is_magnet():
            buf.write_i32(36)
        if value.is_blurhash():
            buf.write_i32(37)
        if value.is_streaming():
            buf.write_i32(38)
        if value.is_recording():
            buf.write_i32(39)
        if value.is_starts():
            buf.write_i32(40)
        if value.is_ends():
            buf.write_i32(41)
        if value.is_status():
            buf.write_i32(42)
        if value.is_current_participants():
            buf.write_i32(43)
        if value.is_total_participants():
            buf.write_i32(44)
        if value.is_method():
            buf.write_i32(45)
        if value.is_payload():
            buf.write_i32(46)
        if value.is_anon():
            buf.write_i32(47)
        if value.is_proxy():
            buf.write_i32(48)
        if value.is_emoji():
            buf.write_i32(49)
        if value.is_encrypted():
            buf.write_i32(50)
        if value.is_request():
            buf.write_i32(51)
        if value.is_unknown():
            buf.write_i32(52)
            _UniffiConverterString.write(value.unknown, buf)







class TransactionType(enum.Enum):
    """Transaction Type"""

    INCOMING = 1
    """Incoming payments"""

    
    OUTGOING = 2
    """Outgoing payments"""

    


class _UniffiConverterTypeTransactionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionType.INCOMING
        if variant == 2:
            return TransactionType.OUTGOING
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TransactionType.INCOMING:
            return
        if value == TransactionType.OUTGOING:
            return

    @staticmethod
    def write(value, buf):
        if value == TransactionType.INCOMING:
            buf.write_i32(1)
        if value == TransactionType.OUTGOING:
            buf.write_i32(2)







class ZapType(enum.Enum):
    PUBLIC = 1
    """Public"""

    
    PRIVATE = 2
    """Private"""

    
    ANONYMOUS = 3
    """Anonymous"""

    


class _UniffiConverterTypeZapType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ZapType.PUBLIC
        if variant == 2:
            return ZapType.PRIVATE
        if variant == 3:
            return ZapType.ANONYMOUS
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ZapType.PUBLIC:
            return
        if value == ZapType.PRIVATE:
            return
        if value == ZapType.ANONYMOUS:
            return

    @staticmethod
    def write(value, buf):
        if value == ZapType.PUBLIC:
            buf.write_i32(1)
        if value == ZapType.PRIVATE:
            buf.write_i32(2)
        if value == ZapType.ANONYMOUS:
            buf.write_i32(3)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEventId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImageDimensions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImageDimensions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImageDimensions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImageDimensions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTimestamp(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTimestamp.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTimestamp.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTimestamp.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFeeSchedules(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFeeSchedules.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFeeSchedules.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFeeSchedules.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLimitation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLimitation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLimitation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLimitation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventHost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventHost.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventHost.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventHost.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMarker(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMarker.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMarker.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMarker.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRelayMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeRetentionKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeRetentionKind.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeRetentionKind.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeRetentionKind.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt16.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt16.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeContact(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeContact.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeContact.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeContact.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCoordinate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCoordinate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCoordinate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCoordinate.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEventId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEventId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEventId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePublicKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingMethod(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingMethod.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingMethod.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingMethod.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFeeSchedule(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFeeSchedule.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFeeSchedule.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFeeSchedule.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeImage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeImage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeImage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeKeysendTLVRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeKeysendTLVRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeKeysendTLVRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeKeysendTLVRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLookupInvoiceResponseResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLookupInvoiceResponseResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLookupInvoiceResponseResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLookupInvoiceResponseResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayInvoiceRequestParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayInvoiceRequestParams.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayInvoiceRequestParams.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayInvoiceRequestParams.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayKeysendRequestParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayKeysendRequestParams.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayKeysendRequestParams.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayKeysendRequestParams.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePerson(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePerson.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePerson.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePerson.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRetention(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRetention.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRetention.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRetention.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingCost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingCost.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingCost.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingCost.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeJsonValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeJsonValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeJsonValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRetentionKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRetentionKind.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRetentionKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRetentionKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceString.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeJsonValue.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeRelayMetadata.read(buf)
            d[key] = val
        return d

def create_delegation_tag(delegator_keys: "Keys",delegatee_pubkey: "PublicKey",conditions: "str") -> "str":
    """
    Create a NIP-26 delegation tag (including the signature).
    See also validate_delegation_tag().
    """

    _UniffiConverterTypeKeys.check_lower(delegator_keys)
    
    _UniffiConverterTypePublicKey.check_lower(delegatee_pubkey)
    
    _UniffiConverterString.check_lower(conditions)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_create_delegation_tag,
        _UniffiConverterTypeKeys.lower(delegator_keys),
        _UniffiConverterTypePublicKey.lower(delegatee_pubkey),
        _UniffiConverterString.lower(conditions)))


def extract_relay_list(event: "Event") -> "dict":
    """Extracts the relay info (url, optional read/write flag) from the event"""

    _UniffiConverterTypeEvent.check_lower(event)
    
    return _UniffiConverterMapStringOptionalTypeRelayMetadata.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_extract_relay_list,
        _UniffiConverterTypeEvent.lower(event)))


def generate_shared_key(secret_key: "SecretKey",public_key: "PublicKey") -> "bytes":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    return _UniffiConverterBytes.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key)))


def get_leading_zero_bits(bytes: "bytes") -> "int":
    """Gets the number of leading zero bits. Result is between 0 and 255."""

    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterUInt8.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_get_leading_zero_bits,
        _UniffiConverterBytes.lower(bytes)))


def get_nip05_profile(nip05: "str",proxy: "typing.Optional[str]") -> "Nip19Profile":
    _UniffiConverterString.check_lower(nip05)
    
    _UniffiConverterOptionalString.check_lower(proxy)
    
    return _UniffiConverterTypeNip19Profile.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile,
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy)))


def get_prefixes_for_difficulty(leading_zero_bits: "int") -> "typing.List[str]":
    """
    Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.

    Possible values: 0-255
    """

    _UniffiConverterUInt8.check_lower(leading_zero_bits)
    
    return _UniffiConverterSequenceString.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_get_prefixes_for_difficulty,
        _UniffiConverterUInt8.lower(leading_zero_bits)))


def gift_wrap(sender_keys: "Keys",receiver_pubkey: "PublicKey",rumor: "UnsignedEvent") -> "Event":
    _UniffiConverterTypeKeys.check_lower(sender_keys)
    
    _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
    
    _UniffiConverterTypeUnsignedEvent.check_lower(rumor)
    
    return _UniffiConverterTypeEvent.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_gift_wrap,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterTypeUnsignedEvent.lower(rumor)))


def nip04_decrypt(secret_key: "SecretKey",public_key: "PublicKey",encrypted_content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(encrypted_content)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)))


def nip04_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)))


def nip44_decrypt(secret_key: "SecretKey",public_key: "PublicKey",payload: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(payload)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)))


def nip44_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str",version: "Nip44Version") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    _UniffiConverterTypeNip44Version.check_lower(version)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content),
        _UniffiConverterTypeNip44Version.lower(version)))


def nip57_anonymous_zap_request(data: "ZapRequestData") -> "Event":
    _UniffiConverterTypeZapRequestData.check_lower(data)
    
    return _UniffiConverterTypeEvent.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_anonymous_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data)))


def nip57_decrypt_private_zap_message(secret_key: "SecretKey",public_key: "PublicKey",private_zap: "Event") -> "Event":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterTypeEvent.check_lower(private_zap)
    
    return _UniffiConverterTypeEvent.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_decrypt_private_zap_message,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeEvent.lower(private_zap)))


def nip57_private_zap_request(data: "ZapRequestData",keys: "Keys") -> "Event":
    _UniffiConverterTypeZapRequestData.check_lower(data)
    
    _UniffiConverterTypeKeys.check_lower(keys)
    
    return _UniffiConverterTypeEvent.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip57_private_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data),
        _UniffiConverterTypeKeys.lower(keys)))


def nip59_extract_rumor(keys: "Keys",gift_wrap: "Event") -> "UnsignedEvent":
    """Extract `rumor` from `gift wrap`"""

    _UniffiConverterTypeKeys.check_lower(keys)
    
    _UniffiConverterTypeEvent.check_lower(gift_wrap)
    
    return _UniffiConverterTypeUnsignedEvent.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip59_extract_rumor,
        _UniffiConverterTypeKeys.lower(keys),
        _UniffiConverterTypeEvent.lower(gift_wrap)))


def sign_delegation(delegator_keys: "Keys",delegatee_pk: "PublicKey",conditions: "str") -> "str":
    """
    Sign delegation.
    See `create_delegation_tag` for more complete functionality.
    """

    _UniffiConverterTypeKeys.check_lower(delegator_keys)
    
    _UniffiConverterTypePublicKey.check_lower(delegatee_pk)
    
    _UniffiConverterString.check_lower(conditions)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_sign_delegation,
        _UniffiConverterTypeKeys.lower(delegator_keys),
        _UniffiConverterTypePublicKey.lower(delegatee_pk),
        _UniffiConverterString.lower(conditions)))


def validate_delegation_tag(delegation_tag: "str",delegatee_pubkey: "PublicKey",event_kind: "int",created_at: "int") -> "bool":
    """Validate a NIP-26 delegation tag, check signature and conditions."""

    _UniffiConverterString.check_lower(delegation_tag)
    
    _UniffiConverterTypePublicKey.check_lower(delegatee_pubkey)
    
    _UniffiConverterUInt64.check_lower(event_kind)
    
    _UniffiConverterUInt64.check_lower(created_at)
    
    return _UniffiConverterBool.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_validate_delegation_tag,
        _UniffiConverterString.lower(delegation_tag),
        _UniffiConverterTypePublicKey.lower(delegatee_pubkey),
        _UniffiConverterUInt64.lower(event_kind),
        _UniffiConverterUInt64.lower(created_at)))


def verify_delegation_signature(delegator_public_key: "PublicKey",delegatee_public_key: "PublicKey",conditions: "str",signature: "str") -> "bool":
    """Verify delegation signature (NIP26)"""

    _UniffiConverterTypePublicKey.check_lower(delegator_public_key)
    
    _UniffiConverterTypePublicKey.check_lower(delegatee_public_key)
    
    _UniffiConverterString.check_lower(conditions)
    
    _UniffiConverterString.check_lower(signature)
    
    return _UniffiConverterBool.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_verify_delegation_signature,
        _UniffiConverterTypePublicKey.lower(delegator_public_key),
        _UniffiConverterTypePublicKey.lower(delegatee_public_key),
        _UniffiConverterString.lower(conditions),
        _UniffiConverterString.lower(signature)))


def verify_nip05(public_key: "PublicKey",nip05: "str",proxy: "typing.Optional[str]"):
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(nip05)
    
    _UniffiConverterOptionalString.check_lower(proxy)
    
    _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy))


__all__ = [
    "InternalError",
    "Alphabet",
    "ClientMessage",
    "DataVendingMachineStatus",
    "EncryptedSecretKeyVersion",
    "ErrorCode",
    "ExternalIdentity",
    "HttpMethod",
    "JsonValue",
    "KeySecurity",
    "LiveEventMarker",
    "LiveEventStatus",
    "Marker",
    "Method",
    "Nip19Enum",
    "Nip21Enum",
    "Nip44Version",
    "NostrConnectMessage",
    "NostrError",
    "Protocol",
    "RelayMessage",
    "RelayMetadata",
    "Report",
    "RequestParams",
    "ResponseResult",
    "RetentionKind",
    "TagEnum",
    "TagKind",
    "TransactionType",
    "ZapType",
    "FeeSchedule",
    "FeeSchedules",
    "GetBalanceResponseResult",
    "GetInfoResponseResult",
    "HttpData",
    "Identity",
    "Image",
    "KeysendTlvRecord",
    "Limitation",
    "ListTransactionsRequestParams",
    "LiveEvent",
    "LiveEventHost",
    "LookupInvoiceRequestParams",
    "LookupInvoiceResponseResult",
    "MakeInvoiceRequestParams",
    "MakeInvoiceResponseResult",
    "MultiPayInvoiceRequestParams",
    "MultiPayKeysendRequestParams",
    "Nip47Error",
    "PayInvoiceRequestParams",
    "PayInvoiceResponseResult",
    "PayKeysendRequestParams",
    "PayKeysendResponseResult",
    "Person",
    "ProductData",
    "Retention",
    "ShippingCost",
    "StallData",
    "create_delegation_tag",
    "extract_relay_list",
    "generate_shared_key",
    "get_leading_zero_bits",
    "get_nip05_profile",
    "get_prefixes_for_difficulty",
    "gift_wrap",
    "nip04_decrypt",
    "nip04_encrypt",
    "nip44_decrypt",
    "nip44_encrypt",
    "nip57_anonymous_zap_request",
    "nip57_decrypt_private_zap_message",
    "nip57_private_zap_request",
    "nip59_extract_rumor",
    "sign_delegation",
    "validate_delegation_tag",
    "verify_delegation_signature",
    "verify_nip05",
    "Contact",
    "Coordinate",
    "EncryptedSecretKey",
    "Event",
    "EventBuilder",
    "EventId",
    "FileMetadata",
    "Filter",
    "ImageDimensions",
    "Keys",
    "Metadata",
    "Nip19",
    "Nip19Event",
    "Nip19Profile",
    "Nip21",
    "NostrConnectMetadata",
    "NostrConnectUri",
    "NostrLibrary",
    "NostrWalletConnectUri",
    "PublicKey",
    "RelayInformationDocument",
    "Request",
    "Response",
    "SecretKey",
    "ShippingMethod",
    "SingleLetterTag",
    "Tag",
    "Timestamp",
    "UnsignedEvent",
    "ZapRequestData",
]

