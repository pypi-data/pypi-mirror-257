from typing import (
    Optional,
    Tuple,
    Any,
    Union,
    Sequence,
    List,
    Callable,
    Literal,
    TypeAlias,
)
from numbers import Real
import numpy
import numpy.typing
import asyncio

DimSelectionLike = Union[int, slice, str, List[Union[int, slice, str]]]

class ChunkLayout:
    class Grid:
        @property
        def aspect_ratio(
            arg0: ChunkLayout.Grid,
        ) -> Optional[Tuple[Optional[float], ...]]: ...
        @property
        def aspect_ratio_soft_constraint(
            arg0: ChunkLayout.Grid,
        ) -> Optional[Tuple[Optional[float], ...]]: ...
        @property
        def elements(arg0: ChunkLayout.Grid) -> Optional[int]: ...
        @property
        def elements_soft_constraint(arg0: ChunkLayout.Grid) -> Optional[int]: ...
        @property
        def ndim(arg0: ChunkLayout.Grid) -> Optional[int]: ...
        @property
        def rank(arg0: ChunkLayout.Grid) -> Optional[int]: ...
        @property
        def shape(arg0: ChunkLayout.Grid) -> Optional[Tuple[Optional[int], ...]]: ...
        @property
        def shape_soft_constraint(
            arg0: ChunkLayout.Grid,
        ) -> Optional[Tuple[Optional[int], ...]]: ...
        def to_json(self: ChunkLayout.Grid, include_defaults: bool = False) -> Any: ...
        def update(
            self: ChunkLayout.Grid,
            *,
            rank: Optional[int] = None,
            shape: Optional[Sequence[Optional[int]]] = None,
            shape_soft_constraint: Optional[Sequence[Optional[int]]] = None,
            aspect_ratio: Optional[Sequence[Optional[float]]] = None,
            aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None,
            elements: Optional[int] = None,
            elements_soft_constraint: Optional[int] = None,
            grid: Optional[ChunkLayout.Grid] = None,
            grid_soft_constraint: Optional[ChunkLayout.Grid] = None
        ) -> None: ...

    @property
    def codec_chunk(arg0: ChunkLayout) -> ChunkLayout.Grid: ...
    @property
    def grid_origin(arg0: ChunkLayout) -> Optional[Tuple[Optional[int], ...]]: ...
    @property
    def grid_origin_soft_constraint(
        arg0: ChunkLayout,
    ) -> Optional[Tuple[Optional[int], ...]]: ...
    @property
    def inner_order(arg0: ChunkLayout) -> Optional[Tuple[int, ...]]: ...
    @property
    def inner_order_soft_constraint(arg0: ChunkLayout) -> Optional[Tuple[int, ...]]: ...
    @property
    def ndim(arg0: ChunkLayout) -> int: ...
    @property
    def rank(arg0: ChunkLayout) -> int: ...
    @property
    def read_chunk(arg0: ChunkLayout) -> ChunkLayout.Grid: ...
    @property
    def read_chunk_template(arg0: ChunkLayout) -> IndexDomain: ...
    def to_json(self: ChunkLayout) -> Any: ...
    def update(
        self: ChunkLayout,
        *,
        rank: Optional[int] = None,
        inner_order: Optional[Sequence[int]] = None,
        inner_order_soft_constraint: Optional[Sequence[int]] = None,
        grid_origin: Optional[Sequence[Optional[int]]] = None,
        grid_origin_soft_constraint: Optional[Sequence[Optional[int]]] = None,
        chunk: Optional[ChunkLayout.Grid] = None,
        write_chunk: Optional[ChunkLayout.Grid] = None,
        read_chunk: Optional[ChunkLayout.Grid] = None,
        codec_chunk: Optional[ChunkLayout.Grid] = None,
        chunk_shape: Optional[Sequence[Optional[int]]] = None,
        chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None,
        write_chunk_shape: Optional[Sequence[Optional[int]]] = None,
        write_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None,
        read_chunk_shape: Optional[Sequence[Optional[int]]] = None,
        read_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None,
        codec_chunk_shape: Optional[Sequence[Optional[int]]] = None,
        codec_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None,
        chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None,
        chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None,
        write_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None,
        write_chunk_aspect_ratio_soft_constraint: Optional[
            Sequence[Optional[float]]
        ] = None,
        read_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None,
        read_chunk_aspect_ratio_soft_constraint: Optional[
            Sequence[Optional[float]]
        ] = None,
        codec_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None,
        codec_chunk_aspect_ratio_soft_constraint: Optional[
            Sequence[Optional[float]]
        ] = None,
        chunk_elements: Optional[int] = None,
        chunk_elements_soft_constraint: Optional[int] = None,
        write_chunk_elements: Optional[int] = None,
        write_chunk_elements_soft_constraint: Optional[int] = None,
        read_chunk_elements: Optional[int] = None,
        read_chunk_elements_soft_constraint: Optional[int] = None,
        codec_chunk_elements: Optional[int] = None,
        codec_chunk_elements_soft_constraint: Optional[int] = None,
        finalize: Optional[bool] = None
    ) -> None: ...
    @property
    def write_chunk(arg0: ChunkLayout) -> ChunkLayout.Grid: ...
    @property
    def write_chunk_template(arg0: ChunkLayout) -> IndexDomain: ...

class CodecSpec:
    def to_json(self: CodecSpec, include_defaults: bool = False) -> Any: ...

class Context:
    class Resource:
        def to_json(self: Context.Resource, include_defaults: bool = False) -> Any: ...

    class Spec:
        def to_json(self: Context.Spec, include_defaults: bool = False) -> Any: ...

    @property
    def parent(arg0: Context) -> Context: ...
    @property
    def spec(arg0: Context) -> Context.Spec: ...

class Dim:
    @property
    def empty(arg0: Dim) -> bool: ...
    @property
    def exclusive_max(arg0: Dim) -> int: ...
    @property
    def exclusive_min(arg0: Dim) -> int: ...
    @property
    def finite(arg0: Dim) -> bool: ...
    def hull(self: Dim, other: Dim) -> Dim: ...
    @property
    def implicit_lower(arg0: Dim) -> bool: ...
    @property
    def implicit_upper(arg0: Dim) -> bool: ...
    @property
    def inclusive_max(arg0: Dim) -> int: ...
    @property
    def inclusive_min(arg0: Dim) -> int: ...
    def intersect(self: Dim, other: Dim) -> Dim: ...
    @property
    def label(arg0: Dim) -> str: ...
    @property
    def size(arg0: Dim) -> int: ...

class DimExpression:
    @property
    def diagonal(arg0: DimExpression) -> DimExpression: ...
    @property
    def label(arg0: object) -> DimExpression: ...
    @property
    def mark_bounds_implicit(arg0: object) -> DimExpression: ...
    @property
    def oindex(arg0: object) -> DimExpression: ...
    @property
    def stride(arg0: object) -> DimExpression: ...
    @property
    def translate_backward_by(arg0: object) -> DimExpression: ...
    @property
    def translate_by(arg0: object) -> DimExpression: ...
    @property
    def translate_to(arg0: object) -> DimExpression: ...
    @property
    def transpose(arg0: object) -> DimExpression: ...
    @property
    def vindex(arg0: object) -> DimExpression: ...

class Future:
    def add_done_callback(self: Future, callback: Callable[[Future], None]) -> None: ...
    def cancel(self: Future) -> bool: ...
    def cancelled(self: Future) -> bool: ...
    def done(self: Future) -> bool: ...
    def exception(
        self: Future, timeout: Optional[float] = None, deadline: Optional[float] = None
    ) -> object: ...
    def force(self: Future) -> None: ...
    def remove_done_callback(
        self: Future, callback: Callable[[Future], None]
    ) -> int: ...
    def result(
        self: Future, timeout: Optional[float] = None, deadline: Optional[float] = None
    ) -> object: ...

class FutureLike:
    pass

class IndexDomain:
    @property
    def T(arg0: IndexDomain) -> IndexDomain: ...
    @property
    def exclusive_max(arg0: IndexDomain) -> Tuple[int, ...]: ...
    def hull(self: IndexDomain, other: IndexDomain) -> IndexDomain: ...
    @property
    def implicit_lower_bounds(arg0: IndexDomain) -> Tuple[bool, ...]: ...
    @property
    def implicit_upper_bounds(arg0: IndexDomain) -> Tuple[bool, ...]: ...
    @property
    def inclusive_max(arg0: IndexDomain) -> Tuple[int, ...]: ...
    @property
    def inclusive_min(arg0: IndexDomain) -> Tuple[int, ...]: ...
    @property
    def index_exp(arg0: IndexDomain) -> Tuple[slice, ...]: ...
    def intersect(self: IndexDomain, other: IndexDomain) -> IndexDomain: ...
    @property
    def label(arg0: object) -> IndexDomain._Label: ...
    @property
    def labels(arg0: IndexDomain) -> Tuple[str, ...]: ...
    @property
    def mark_bounds_implicit(arg0: object) -> IndexDomain._MarkBoundsImplicit: ...
    @property
    def ndim(arg0: IndexDomain) -> int: ...
    @property
    def origin(arg0: IndexDomain) -> Tuple[int, ...]: ...
    @property
    def rank(arg0: IndexDomain) -> int: ...
    @property
    def shape(arg0: IndexDomain) -> Tuple[int, ...]: ...
    @property
    def size(arg0: IndexDomain) -> int: ...
    def to_json(self: IndexDomain) -> Any: ...
    @property
    def translate_backward_by(arg0: object) -> IndexDomain._TranslateBackwardBy: ...
    @property
    def translate_by(arg0: object) -> IndexDomain._TranslateBy: ...
    @property
    def translate_to(arg0: object) -> IndexDomain._TranslateTo: ...
    def transpose(
        self: IndexDomain, axes: Optional[DimSelectionLike] = None
    ) -> IndexDomain: ...

class IndexTransform:
    @property
    def T(arg0: IndexTransform) -> IndexTransform: ...
    @property
    def domain(arg0: IndexTransform) -> IndexDomain: ...
    @property
    def implicit_lower_bounds(arg0: IndexTransform) -> Tuple[bool, ...]: ...
    @property
    def implicit_upper_bounds(arg0: IndexTransform) -> Tuple[bool, ...]: ...
    @property
    def input_exclusive_max(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def input_inclusive_max(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def input_inclusive_min(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def input_labels(arg0: IndexTransform) -> Tuple[str, ...]: ...
    @property
    def input_origin(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def input_rank(arg0: IndexTransform) -> int: ...
    @property
    def input_shape(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def label(arg0: object) -> IndexTransform._Label: ...
    @property
    def mark_bounds_implicit(arg0: object) -> IndexTransform._MarkBoundsImplicit: ...
    @property
    def ndim(arg0: IndexTransform) -> int: ...
    @property
    def oindex(arg0: object) -> IndexTransform._Oindex: ...
    @property
    def origin(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def output(arg0: IndexTransform) -> OutputIndexMaps: ...
    @property
    def output_rank(arg0: IndexTransform) -> int: ...
    @property
    def shape(arg0: IndexTransform) -> Tuple[int, ...]: ...
    @property
    def size(arg0: IndexTransform) -> int: ...
    def to_json(self: IndexTransform) -> Any: ...
    @property
    def translate_backward_by(arg0: object) -> IndexTransform._TranslateBackwardBy: ...
    @property
    def translate_by(arg0: object) -> IndexTransform._TranslateBy: ...
    @property
    def translate_to(arg0: object) -> IndexTransform._TranslateTo: ...
    def transpose(
        self: IndexTransform, axes: Optional[DimSelectionLike] = None
    ) -> IndexTransform: ...
    @property
    def vindex(arg0: object) -> IndexTransform._Vindex: ...

class Indexable:
    pass

class KvStore:
    class KeyRange:
        def copy(self: KvStore.KeyRange) -> KvStore.KeyRange: ...
        @property
        def empty(arg0: KvStore.KeyRange) -> bool: ...
        @property
        def exclusive_max(arg0: KvStore.KeyRange) -> str: ...
        @property
        def inclusive_min(arg0: KvStore.KeyRange) -> str: ...

    class ReadResult:
        @property
        def stamp(arg0: KvStore.ReadResult) -> KvStore.TimestampedStorageGeneration: ...
        @property
        def state(
            arg0: KvStore.ReadResult,
        ) -> Literal["unspecified", "missing", "value"]: ...
        @property
        def value(arg0: KvStore.ReadResult) -> bytes: ...

    class Spec:
        @property
        def base(arg0: KvStore.Spec) -> Optional[KvStore.Spec]: ...
        def copy(self: KvStore.Spec) -> KvStore.Spec: ...
        @property
        def path(arg0: KvStore.Spec) -> str: ...
        def to_json(self: KvStore.Spec, include_defaults: bool = False) -> Any: ...
        def update(
            self: KvStore.Spec,
            *,
            unbind_context: Optional[bool] = None,
            strip_context: Optional[bool] = None,
            context: Optional[Context] = None
        ) -> None: ...
        @property
        def url(arg0: KvStore.Spec) -> str: ...

    class TimestampedStorageGeneration:
        @property
        def generation(arg0: KvStore.TimestampedStorageGeneration) -> bytes: ...
        @property
        def time(arg0: KvStore.TimestampedStorageGeneration) -> float: ...

    @property
    def base(arg0: KvStore) -> Optional[KvStore]: ...
    def copy(self: KvStore) -> KvStore: ...
    def delete_range(self: KvStore, range: KvStore.KeyRange) -> Future[None]: ...
    def experimental_copy_range_to(
        self: KvStore,
        target: KvStore,
        source_range: Optional[KvStore.KeyRange] = None,
        source_staleness_bound: Optional[float] = None,
    ) -> Future[None]: ...
    def list(
        self: KvStore,
        range: Optional[KvStore.KeyRange] = None,
        strip_prefix_length: int = 0,
    ) -> Future[List[bytes]]: ...
    def open(
        spec: Union[KvStore.Spec, Any],
        *,
        context: Optional[Context] = None,
        transaction: Optional[Transaction] = None
    ) -> Future[KvStore]: ...
    @property
    def path(arg0: KvStore) -> str: ...
    def read(
        self: KvStore,
        key: str,
        *,
        if_not_equal: Optional[str] = None,
        staleness_bound: Optional[float] = None
    ) -> Future[KvStore.ReadResult]: ...
    def spec(
        self: KvStore,
        *,
        retain_context: Optional[bool] = None,
        unbind_context: Optional[bool] = None
    ) -> KvStore.Spec: ...
    @property
    def transaction(arg0: KvStore) -> Optional[Transaction]: ...
    @property
    def url(arg0: KvStore) -> str: ...
    def with_transaction(
        self: KvStore, transaction: Optional[Transaction]
    ) -> KvStore: ...
    def write(
        self: KvStore, key: str, value: Optional[str], *, if_equal: Optional[str] = None
    ) -> Future[KvStore.TimestampedStorageGeneration]: ...

class OpenMode:
    @property
    def assume_cached_metadata(arg0: OpenMode) -> bool: ...
    @property
    def assume_metadata(arg0: OpenMode) -> bool: ...
    @property
    def create(arg0: OpenMode) -> bool: ...
    @property
    def delete_existing(arg0: OpenMode) -> bool: ...
    @property
    def open(arg0: OpenMode) -> bool: ...

class OutputIndexMap:
    @property
    def index_array(arg0: OutputIndexMap) -> Optional[numpy.typing.ArrayLike]: ...
    @property
    def index_range(arg0: OutputIndexMap) -> Optional[Dim]: ...
    @property
    def input_dimension(arg0: OutputIndexMap) -> Optional[int]: ...
    @property
    def method(arg0: OutputIndexMap) -> OutputIndexMethod: ...
    @property
    def offset(arg0: OutputIndexMap) -> int: ...
    @property
    def stride(arg0: OutputIndexMap) -> Optional[int]: ...

class OutputIndexMaps:
    @property
    def rank(arg0: OutputIndexMaps) -> int: ...

class OutputIndexMethod:
    array = OutputIndexMethod.array
    constant = OutputIndexMethod.constant

    @property
    def name(self) -> str: ...
    single_input_dimension = OutputIndexMethod.single_input_dimension

    @property
    def value(arg0: OutputIndexMethod) -> int: ...

class Promise:
    def new() -> Tuple[Promise, Future]: ...
    def set_exception(self: Promise, exception: object) -> None: ...
    def set_result(self: Promise, result: object) -> None: ...

class Schema:
    @property
    def T(arg0: Schema) -> Schema: ...
    @property
    def chunk_layout(arg0: Schema) -> ChunkLayout: ...
    @property
    def codec(arg0: Schema) -> Optional[CodecSpec]: ...
    def copy(self: Schema) -> Schema: ...
    @property
    def dimension_units(arg0: Schema) -> Optional[Tuple[Optional[Unit], ...]]: ...
    @property
    def domain(arg0: Schema) -> Optional[IndexDomain]: ...
    @property
    def dtype(arg0: Schema) -> Optional[dtype]: ...
    @property
    def fill_value(arg0: Schema) -> Optional[numpy.typing.ArrayLike]: ...
    @property
    def label(arg0: object) -> Schema._Label: ...
    @property
    def mark_bounds_implicit(arg0: object) -> Schema._MarkBoundsImplicit: ...
    @property
    def ndim(arg0: Schema) -> Optional[int]: ...
    @property
    def oindex(arg0: object) -> Schema._Oindex: ...
    @property
    def origin(arg0: Schema) -> Tuple[int, ...]: ...
    @property
    def rank(arg0: Schema) -> Optional[int]: ...
    @property
    def shape(arg0: Schema) -> Tuple[int, ...]: ...
    @property
    def size(arg0: Schema) -> int: ...
    def to_json(self: Schema, include_defaults: bool = False) -> Any: ...
    @property
    def translate_backward_by(arg0: object) -> Schema._TranslateBackwardBy: ...
    @property
    def translate_by(arg0: object) -> Schema._TranslateBy: ...
    @property
    def translate_to(arg0: object) -> Schema._TranslateTo: ...
    def transpose(self: Schema, axes: Optional[DimSelectionLike] = None) -> Schema: ...
    def update(
        self: Schema,
        *,
        rank: Optional[int] = None,
        dtype: Optional[dtype] = None,
        domain: Optional[IndexDomain] = None,
        shape: Optional[Sequence[int]] = None,
        chunk_layout: Optional[ChunkLayout] = None,
        codec: Optional[CodecSpec] = None,
        fill_value: Optional[numpy.typing.ArrayLike] = None,
        dimension_units: Optional[
            Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
        ] = None,
        schema: Optional[Schema] = None
    ) -> None: ...
    @property
    def vindex(arg0: object) -> Schema._Vindex: ...

class Spec:
    @property
    def T(arg0: Spec) -> Spec: ...
    @property
    def base(arg0: Spec) -> Optional[Spec]: ...
    @property
    def chunk_layout(arg0: Spec) -> ChunkLayout: ...
    @property
    def codec(arg0: Spec) -> Optional[CodecSpec]: ...
    def copy(self: Spec) -> Spec: ...
    @property
    def dimension_units(arg0: Spec) -> Optional[Tuple[Optional[Unit], ...]]: ...
    @property
    def domain(arg0: Spec) -> Optional[IndexDomain]: ...
    @property
    def dtype(arg0: Spec) -> Optional[dtype]: ...
    @property
    def fill_value(arg0: Spec) -> Optional[numpy.typing.ArrayLike]: ...
    @property
    def kvstore(arg0: Spec) -> Optional[KvStore.Spec]: ...
    @property
    def label(arg0: object) -> Spec._Label: ...
    @property
    def mark_bounds_implicit(arg0: object) -> Spec._MarkBoundsImplicit: ...
    @property
    def ndim(arg0: Spec) -> Optional[int]: ...
    @property
    def oindex(arg0: object) -> Spec._Oindex: ...
    @property
    def open_mode(arg0: Spec) -> OpenMode: ...
    @property
    def origin(arg0: Spec) -> Tuple[int, ...]: ...
    @property
    def rank(arg0: Spec) -> Optional[int]: ...
    @property
    def schema(arg0: Spec) -> Schema: ...
    @property
    def shape(arg0: Spec) -> Tuple[int, ...]: ...
    @property
    def size(arg0: Spec) -> int: ...
    def to_json(self: Spec, include_defaults: bool = False) -> Any: ...
    @property
    def transform(arg0: Spec) -> Optional[IndexTransform]: ...
    @property
    def translate_backward_by(arg0: object) -> Spec._TranslateBackwardBy: ...
    @property
    def translate_by(arg0: object) -> Spec._TranslateBy: ...
    @property
    def translate_to(arg0: object) -> Spec._TranslateTo: ...
    def transpose(self: Spec, axes: Optional[DimSelectionLike] = None) -> Spec: ...
    def update(
        self: Spec,
        *,
        open_mode: Optional[OpenMode] = None,
        open: Optional[bool] = None,
        create: Optional[bool] = None,
        delete_existing: Optional[bool] = None,
        assume_metadata: Optional[bool] = None,
        assume_cached_metadata: Optional[bool] = None,
        unbind_context: Optional[bool] = None,
        strip_context: Optional[bool] = None,
        context: Optional[Context] = None,
        kvstore: Optional[KvStore.Spec] = None,
        rank: Optional[int] = None,
        dtype: Optional[dtype] = None,
        domain: Optional[IndexDomain] = None,
        shape: Optional[Sequence[int]] = None,
        chunk_layout: Optional[ChunkLayout] = None,
        codec: Optional[CodecSpec] = None,
        fill_value: Optional[numpy.typing.ArrayLike] = None,
        dimension_units: Optional[
            Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
        ] = None,
        schema: Optional[Schema] = None
    ) -> None: ...
    @property
    def vindex(arg0: object) -> Spec._Vindex: ...

class TensorStore:
    class StorageStatistics:
        @property
        def fully_stored(arg0: TensorStore.StorageStatistics) -> Optional[bool]: ...
        @property
        def not_stored(arg0: TensorStore.StorageStatistics) -> Optional[bool]: ...

    @property
    def T(arg0: TensorStore) -> TensorStore: ...
    def astype(self: TensorStore, dtype: dtype) -> TensorStore: ...
    @property
    def base(arg0: TensorStore) -> Optional[TensorStore]: ...
    @property
    def chunk_layout(arg0: TensorStore) -> ChunkLayout: ...
    @property
    def codec(arg0: TensorStore) -> Optional[CodecSpec]: ...
    @property
    def dimension_units(arg0: TensorStore) -> Tuple[Optional[Unit], ...]: ...
    @property
    def domain(arg0: TensorStore) -> IndexDomain: ...
    @property
    def dtype(arg0: TensorStore) -> dtype: ...
    @property
    def fill_value(arg0: TensorStore) -> Optional[numpy.typing.ArrayLike]: ...
    @property
    def kvstore(arg0: TensorStore) -> Optional[KvStore]: ...
    @property
    def label(arg0: object) -> TensorStore: ...
    @property
    def mark_bounds_implicit(arg0: object) -> TensorStore: ...
    @property
    def mode(arg0: TensorStore) -> str: ...
    @property
    def ndim(arg0: TensorStore) -> int: ...
    @property
    def oindex(arg0: object) -> TensorStore: ...
    @property
    def origin(arg0: TensorStore) -> Tuple[int, ...]: ...
    @property
    def rank(arg0: TensorStore) -> int: ...
    def read(
        self: TensorStore, order: Literal["C", "F"] = "C"
    ) -> Future[numpy.typing.ArrayLike]: ...
    @property
    def readable(arg0: TensorStore) -> bool: ...
    def resize(
        self: TensorStore,
        inclusive_min: Optional[Sequence[Optional[int]]] = None,
        exclusive_max: Optional[Sequence[Optional[int]]] = None,
        resize_metadata_only: bool = False,
        resize_tied_bounds: bool = False,
        expand_only: bool = False,
        shrink_only: bool = False,
    ) -> Future[TensorStore]: ...
    def resolve(
        self: TensorStore, fix_resizable_bounds: bool = False
    ) -> Future[TensorStore]: ...
    @property
    def schema(arg0: TensorStore) -> Schema: ...
    @property
    def shape(arg0: TensorStore) -> Tuple[int, ...]: ...
    @property
    def size(arg0: TensorStore) -> int: ...
    def spec(
        self: TensorStore,
        *,
        open_mode: Optional[OpenMode] = None,
        open: Optional[bool] = None,
        create: Optional[bool] = None,
        delete_existing: Optional[bool] = None,
        assume_metadata: Optional[bool] = None,
        assume_cached_metadata: Optional[bool] = None,
        minimal_spec: Optional[bool] = None,
        retain_context: Optional[bool] = None,
        unbind_context: Optional[bool] = None
    ) -> Spec: ...
    def storage_statistics(
        self: TensorStore,
        *,
        query_not_stored: bool = False,
        query_fully_stored: bool = False
    ) -> Future[TensorStore.StorageStatistics]: ...
    @property
    def transaction(arg0: TensorStore) -> Optional[Transaction]: ...
    @property
    def translate_backward_by(arg0: object) -> TensorStore: ...
    @property
    def translate_by(arg0: object) -> TensorStore: ...
    @property
    def translate_to(arg0: object) -> TensorStore: ...
    def transpose(
        self: TensorStore, axes: Optional[DimSelectionLike] = None
    ) -> TensorStore: ...
    @property
    def vindex(arg0: object) -> TensorStore: ...
    def with_transaction(
        self: TensorStore, transaction: Optional[Transaction]
    ) -> TensorStore: ...
    @property
    def writable(arg0: TensorStore) -> bool: ...
    def write(
        self: TensorStore, source: Union[TensorStore, numpy.typing.ArrayLike]
    ) -> WriteFutures: ...

class Transaction:
    def abort(self: Transaction) -> None: ...
    @property
    def aborted(arg0: Transaction) -> bool: ...
    @property
    def atomic(arg0: Transaction) -> bool: ...
    def commit_async(self: Transaction) -> Future[None]: ...
    @property
    def commit_started(arg0: Transaction) -> bool: ...
    def commit_sync(self: Transaction) -> None: ...
    @property
    def future(arg0: Transaction) -> Future[None]: ...
    @property
    def open(arg0: Transaction) -> bool: ...

class Unit:
    @property
    def base_unit(arg0: Unit) -> str: ...
    @property
    def multiplier(arg0: Unit) -> float: ...
    def to_json(self: Unit) -> Any: ...

class VirtualChunkedReadParameters:
    @property
    def if_not_equal(arg0: VirtualChunkedReadParameters) -> bytes: ...
    @property
    def staleness_bound(arg0: VirtualChunkedReadParameters) -> float: ...

class VirtualChunkedWriteParameters:
    @property
    def if_equal(arg0: VirtualChunkedWriteParameters) -> bytes: ...

class WriteFutures:
    def add_done_callback(
        self: WriteFutures, callback: Callable[[Future], None]
    ) -> None: ...
    def cancel(self: WriteFutures) -> bool: ...
    def cancelled(self: WriteFutures) -> bool: ...
    @property
    def commit(arg0: WriteFutures) -> Future[None]: ...
    @property
    def copy(arg0: WriteFutures) -> Future[None]: ...
    def done(self: WriteFutures) -> bool: ...
    def exception(
        self: WriteFutures,
        timeout: Optional[float] = None,
        deadline: Optional[float] = None,
    ) -> object: ...
    def remove_done_callback(
        self: WriteFutures, callback: Callable[[Future], None]
    ) -> int: ...
    def result(
        self: WriteFutures,
        timeout: Optional[float] = None,
        deadline: Optional[float] = None,
    ) -> object: ...

def array(
    array: numpy.typing.ArrayLike,
    dtype: Optional[dtype] = None,
    context: Context = None,
) -> TensorStore: ...

bfloat16 = dtype("bfloat16")
bool = dtype("bool")
byte = dtype("byte")

def cast(*args, **kwargs): ...

char = dtype("char")
complex128 = dtype("complex128")
complex64 = dtype("complex64")

def concat(
    layers: Sequence[Union[TensorStore, Spec]],
    axis: Union[int, str],
    *,
    read: Optional[bool] = None,
    write: Optional[bool] = None,
    context: Optional[Context] = None,
    transaction: Optional[Transaction] = None,
    rank: Optional[int] = None,
    dtype: Optional[dtype] = None,
    domain: Optional[IndexDomain] = None,
    shape: Optional[Sequence[int]] = None,
    dimension_units: Optional[
        Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
    ] = None,
    schema: Optional[Schema] = None
) -> TensorStore: ...

class d:
    @property
    def diagonal(arg0: DimExpression) -> DimExpression: ...
    @property
    def label(arg0: object) -> DimExpression: ...
    @property
    def mark_bounds_implicit(arg0: object) -> DimExpression: ...
    @property
    def oindex(arg0: object) -> DimExpression: ...
    @property
    def stride(arg0: object) -> DimExpression: ...
    @property
    def translate_backward_by(arg0: object) -> DimExpression: ...
    @property
    def translate_by(arg0: object) -> DimExpression: ...
    @property
    def translate_to(arg0: object) -> DimExpression: ...
    @property
    def transpose(arg0: object) -> DimExpression: ...
    @property
    def vindex(arg0: object) -> DimExpression: ...

def downsample(*args, **kwargs): ...

class dtype:
    @property
    def name(arg0: dtype) -> str: ...
    @property
    def numpy_dtype(arg0: dtype) -> dtype: ...
    def to_json(self: dtype) -> str: ...
    @property
    def type(arg0: dtype) -> object: ...

def experimental_collect_matching_metrics(
    metric_prefix: str = "", include_zero_metrics: bool = False
) -> List[Any]: ...
def experimental_collect_prometheus_format_metrics(
    metric_prefix: str = "",
) -> List[str]: ...
def experimental_push_metrics_to_prometheus(
    pushgateway: str = "", job: str = "", instance: str = "", metric_prefix: str = ""
) -> Future[int]: ...

float16 = dtype("float16")
float32 = dtype("float32")
float64 = dtype("float64")
float8_e4m3b11fnuz = dtype("float8_e4m3b11fnuz")
float8_e4m3fn = dtype("float8_e4m3fn")
float8_e4m3fnuz = dtype("float8_e4m3fnuz")
float8_e5m2 = dtype("float8_e5m2")
float8_e5m2fnuz = dtype("float8_e5m2fnuz")
inf = 4611686018427387903
int16 = dtype("int16")
int32 = dtype("int32")
int4 = dtype("int4")
int64 = dtype("int64")
int8 = dtype("int8")
json = dtype("json")
newaxis = None

def open(
    spec: Union[Spec, Any],
    *,
    read: Optional[bool] = None,
    write: Optional[bool] = None,
    open_mode: Optional[OpenMode] = None,
    open: Optional[bool] = None,
    create: Optional[bool] = None,
    delete_existing: Optional[bool] = None,
    assume_metadata: Optional[bool] = None,
    assume_cached_metadata: Optional[bool] = None,
    context: Optional[Context] = None,
    transaction: Optional[Transaction] = None,
    kvstore: Optional[KvStore.Spec] = None,
    rank: Optional[int] = None,
    dtype: Optional[dtype] = None,
    domain: Optional[IndexDomain] = None,
    shape: Optional[Sequence[int]] = None,
    chunk_layout: Optional[ChunkLayout] = None,
    codec: Optional[CodecSpec] = None,
    fill_value: Optional[numpy.typing.ArrayLike] = None,
    dimension_units: Optional[
        Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
    ] = None,
    schema: Optional[Schema] = None
) -> Future[TensorStore]: ...
def overlay(
    layers: Sequence[Union[TensorStore, Spec]],
    *,
    read: Optional[bool] = None,
    write: Optional[bool] = None,
    context: Optional[Context] = None,
    transaction: Optional[Transaction] = None,
    rank: Optional[int] = None,
    dtype: Optional[dtype] = None,
    domain: Optional[IndexDomain] = None,
    shape: Optional[Sequence[int]] = None,
    dimension_units: Optional[
        Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
    ] = None,
    schema: Optional[Schema] = None
) -> TensorStore: ...
def stack(
    layers: Sequence[Union[TensorStore, Spec]],
    axis: int = 0,
    *,
    read: Optional[bool] = None,
    write: Optional[bool] = None,
    context: Optional[Context] = None,
    transaction: Optional[Transaction] = None,
    rank: Optional[int] = None,
    dtype: Optional[dtype] = None,
    domain: Optional[IndexDomain] = None,
    shape: Optional[Sequence[int]] = None,
    dimension_units: Optional[
        Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
    ] = None,
    schema: Optional[Schema] = None
) -> TensorStore: ...

string = dtype("string")
uint16 = dtype("uint16")
uint32 = dtype("uint32")
uint64 = dtype("uint64")
uint8 = dtype("uint8")
ustring = dtype("ustring")

def virtual_chunked(
    read_function: Optional[
        Callable[
            [IndexDomain, numpy.typing.ArrayLike, VirtualChunkedReadParameters],
            FutureLike[Optional[KvStore.TimestampedStorageGeneration]],
        ]
    ] = None,
    write_function: Optional[
        Callable[
            [IndexDomain, numpy.typing.ArrayLike, VirtualChunkedWriteParameters],
            FutureLike[Optional[KvStore.TimestampedStorageGeneration]],
        ]
    ] = None,
    *,
    loop: Optional[asyncio.AbstractEventLoop] = None,
    rank: Optional[int] = None,
    dtype: Optional[dtype] = None,
    domain: Optional[IndexDomain] = None,
    shape: Optional[Sequence[int]] = None,
    chunk_layout: Optional[ChunkLayout] = None,
    dimension_units: Optional[
        Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]
    ] = None,
    schema: Optional[Schema] = None,
    context: Optional[Context] = None,
    transaction: Optional[Transaction] = None
) -> TensorStore: ...
