"""
Public API.
"""
from __future__ import annotations
import logging
from typing import Any
from .errors import BackendNotFound, BackendError, BackendNotAvailable
from .config import Config

_logger = logging.getLogger(__name__)


#region Access to passwords (any backend)

def get_password(name: str) -> str|None:
    any_backend = False

    for backend in get_backends():
        any_backend = True
        password = backend.get_password(name)
        if password is not None:
            return password
        
    if any_backend:        
        _logger.info("Password %s not found", name)
        return None
    else:
        raise BackendNotAvailable("No backend available")

def set_password(name: str, password: str, **options) -> None:
    for backend in get_backends():
        if not backend.readonly:
            backend.set_password(name, password, **options)
            return
        
    raise BackendNotAvailable("No writable backend available")

def delete_password(name: str) -> bool:
    any_writable = False
    deleted = False
    
    for backend in get_backends():
        if not backend.readonly:
            any_writable = True
            if backend.delete_password(name):
                deleted = True
        
    if not any_writable:
        raise BackendNotAvailable("No writable backend available")
    
    if not deleted:        
        _logger.info("Password %s not found", name)
    return deleted

def list_passwords() -> list[PasswordInfo]:
    passwords_by_name: dict[str,PasswordInfo] = {}
    for backend in get_backends():
        for p in backend.list_passwords():
            if not p.name in passwords_by_name:
                passwords_by_name[p.name] = PasswordInfo(p.name)
            passwords_by_name[p.name].add_backend_info(backend, p.backend_info[backend.__class__])

    return [passwords_by_name[name] for name in sorted(passwords_by_name.keys())]

class PasswordInfo:
    def __init__(self, name: str):
        self.name = name
        self.backends: list[Backend] = []  # sorted by decreasing priority
        self.backend_info: dict[type[Backend],dict[str,Any]] = {}

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name
    
    def add_backend_info(self, backend: Backend|type[Backend], info: dict[str,Any]):
        if not isinstance(backend, type):
            backend = type(backend)
        self.backend_info[backend] = info

        self.backends.append(backend)
        self.backends.sort(key=lambda backend: backend.priority, reverse=True)

#endregion


#region Access to backends

def get_backend(name_or_cls: str|type[Backend]) -> Backend:
    return Config.singleton().get_backend(name_or_cls)
        
def get_backends() -> list[Backend]:
    return Config.singleton().get_backends()

def get_backend_classes() -> list[type[Backend]]:
    return Config.singleton().get_backend_classes()

class Backend:
    readonly = False
    name: str = None
    aka: list[str] = None
    priority: int = None

    def __init__(self):
        self.logger = logging.getLogger(f'{__name__}.{self.__class__.__qualname__}')

    def get_password(self, name: str) -> str|None:
        raise NotImplementedError(f"{self.__class__} does not implement get_password() method.")

    def set_password(self, name: str, password: str, **options) -> bool:
        raise NotImplementedError(f"{self.__class__} does not implement set_password() method.")

    def delete_password(self, name: str) -> bool:
        raise NotImplementedError(f"{self.__class__} does not implement delete_password() method.")

    def list_passwords(self) -> list[PasswordInfo]:
        raise NotImplementedError(f"{self.__class__} does not implement list_passwords() method.")

#endregion
        

#region Configuration

def register_backend_class(backend_cls: type[Backend] = None, name: str|list[str] = None, priority: int = None):
    """
    Register a subclass of `Backend`.

    May be used as a normal function or as a decorator of the subclass.
    """
    if backend_cls is not None: # decorator used without arguments: `@register_backend`
        Config.singleton().register_backend_class(backend_cls, name=name, priority=priority)
        return backend_cls
    
    else: # decorator used with arguments, for example `@register_backend(name=...)` or `@register_backend()`            
        def decorator(backend: type[Backend]):
            Config.singleton().register_backend_class(backend, name=name, priority=priority)
            return backend

        return decorator

# endregion


#region Version information

__prog__ = 'flexpass'
try:
    # generated by setuptools_scm during build
    from ._version import __version__, __version_tuple__
except ImportError:
    __version__ = None
    __version_tuple__ = None

#endregion


__all__ = (
    'BackendNotFound', 'BackendError', 'BackendNotAvailable',
    'get_password', 'set_password', 'delete_password', 'list_passwords', 'PasswordInfo',
    'get_backend', 'get_backends', 'get_backend_classes', 'Backend',
    'register_backend_class',
)
