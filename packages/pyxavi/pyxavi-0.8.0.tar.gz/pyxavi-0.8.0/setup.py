# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pyxavi']

package_data = \
{'': ['*']}

install_requires = \
['Mastodon.py==1.8.1',
 'beautifulsoup4>=4.11,<5.0',
 'feedparser>=6.0.10,<7.0.0',
 'python-slugify>=7.0.0,<8.0.0',
 'pyyaml>=6.0.1,<7.0.0',
 'requests>=2.28.0,<3.0.0',
 'validators>=0.22.0,<0.23.0']

setup_kwargs = {
    'name': 'pyxavi',
    'version': '0.8.0',
    'description': 'Set of utilities to assist on simple Python projects',
    'long_description': '# The Xavi\'s Python package\n\nSet of utilities to assist on simple Python projects.\n\n## Disclaimer\n\nThis is a constant *work in progress* package, adding and improving the libraries within with\nthe goal of abstracting and reusing code, and easing the coding experience of real life\nprojects.\n\nSuggestions are welcome :)\n\n\n# Modules included in the package\n\nThis package contains a set of modules, divided by functionality.\n\n\n## The `Dictionary` module\n\nA class to bring some extras to work with `dict` object files, like getter and setter, checks,\nand a way to trasverse the object with keys like `family.category.parameter1.subparameter2`\n\nFor example, consider the following snippet:\n\n```python\nfrom pyxavi.dictionary import Dictionary\n\nd = {\n  "a": 1,\n  "b": "B",\n  "c": [1, 2],\n  "d": {"d1": "D1", "d2": "D2"},\n  "e": [\n    {"e1": "E1"},\n    {"e2": {"e21": "E21"}}\n  ]\n}\n\ninstance = Dictionary(d)\n\nassert instance.get("a") == 1\nassert instance.get("c.0") == 1\nassert instance.get("d.d1") == "D1"\nassert instance.get("e.1.e2.e21") == "E21"\nassert instance.get("d.d3", "default") == "default"\n\nassert instance.key_exists("f.f1.foo") is False\ninstance.initialise_recursive("f.f1.foo")\nassert instance.key_exists("f.f1.foo") is True\ninstance.set("f.f1.foo", "bar")\nassert instance.get_parent("f.f1.foo") == {"foo": "bar"}\n\nassert instance.get_keys_in("d") == ["d1", "d2"]\nassert instance.delete("d.d9") is False\nassert instance.delete("c.1") is True\nassert instance.get("c") == [1]\n\n```\n\n\n## The `Storage` module\n\nA class to bring a basic load/write, get/set behaviour for key/value file based storage. Under\nthe hood it uses YAML files so they\'re human readable and inherits from the `Dictionary` module\nto apply the easy data manipulation into the loaded yaml files.\n\n\n## The `Queue` module\n\nA class to manage fifo queue style lists relying in the `Storage` module.\n\n\n## The `Config` module\n\nA class for read-only config values inheriting from the `Storage` module.\n\n\n## The `Logger` module\n\nA class that helps setting up a built-in logger based on the configuration in a file, handled\nby the `Config` module.\n\nFor example, a `config.yaml` with all parameters to configure the logger explicitly defined would look like this:\n```yaml\n# Logging config\nlogger:\n  # [Integer] Log level: NOTSET=0 | DEBUG=10 | INFO=20 | WARN=30 | ERROR=40 | CRITICAL=50\n  loglevel: 10\n  # [String] Name of the logger\n  name: "my_app"\n  # [String] Format of the log\n  format: "[%(asctime)s] %(levelname)-8s %(name)-12s %(message)s"\n  # File related parameters\n  file:\n    # [Bool] Dump the log into a file\n    active: False\n    # [String] Path and filename of the log file\n    filename: "log/my_app.log"\n    # [String] The encoding of the log file\n    encoding: "UTF-8"\n    # [Bool] Do we want to rotate the log files? Only will apply if we log to files\n    rotate:\n        active: False\n        # [String] When do we rotate. Accepts "S" | "M" | "H" | "D" | "W0"-"W6" | "midnight"\n        #   See https://docs.python.org/3/library/logging.handlers.html#timedrotatingfilehandler\n        when: "midnight"\n        # [Int] How many rotated old files to keep before it starts to delete the older\n        backup_count: 10\n        # [Bool] Stick to UTC timings when triggering the rotation\n        utc: False\n        # [String] in format "%H:%M:%S". When to trigger THE VERY FIRST rotation.\n        #   Subsequent will attend to when_rotate\n        at_time: "1:00:00"\n  # Standard output related parameters\n  stdout:\n  # [Bool] Dump the log into a stdout\n      active: True\n```\n\nRead more about the [`Logger` module](docs/logger.md).\n\n## The `Debugger` module\n\nA function library with a *PHP\'s var_dump()*-like function and other debugging tools\n\n\n## The `TerminalColor` module\n\nA class with a basic set of terminal color codes, ready to assist on printing colorful\nterminal messages.\n\n\n## The `Media` module\n\nA class for operations with media files, at this point extracting media URLs from texts and\ndownload files discovering the mime types.\n\n\n## The `Janitor` module\n\nA class that wraps the API to report to [Janitor](https://github.com/XaviArnaus/janitor), a\nseparated GitHub repository project.\n\n## The `Firefish` module\n\nA class that wraps the API for [Firefish](https://firefish.social/api-doc). It is meant to be \ninterchangeable with the [Mastodon.py](https://mastodonpy.readthedocs.io/en/latest/index.html) \nwrapper library, so one could inject any of both.\n\nAt this point of time it only covers:\n- Posting a new status (creating a note in Firefish).\n- Posting new media (create a drive/media in Firefish)\n\n## The `Network` module\n\nA class to perform some networking actions. At this point:\n- Get the external IP addres for IPv4 and IPv6\n- Validate an IPv4 and IPv6 IP address\n\n## The `Url` module\n\nA class to perform some actions over URLs. At this point:\n- Clean the URL based on given parameters\n- Validate URLs\n- Discover the Feed URL from a given site URL\n\n## The `MastodonHelper` module\n\nA class that abstracts the instantiation of the Mastodon-like API wrapper. At this point it\nsupports the original *Mastodon.py* wrapper that at its time supports Mastodon, Pleroma and Akkoma,\nand Firefish through the `Firefish` module above (which support is limited).\n\nThe class is meant to receive an object `MastodonConnectionParams` that is responsible of bringing in\nthe parameters that facilitate the connection to the Mastodon wrappers and define some specifics\nregarding the server connecting to, like maximum *post length and visibility*.\n\nAlso includes a `StatusPost` that is meant to encapsulate everything that is needed to represent\na Status to be posted. Internally it makes use of `StatusPostVisibility` and `StatusPostContentType`\nthat are also referenced from the `MastodonConnectionParams`. While this object is meant to easy the\ntransport of the status publishing item, it is not required and totally optional.\n\nThe benefit of using this set of tools is to encapsulate and abstract what is needed to initiate\na connection to the Mastodon-like API and post a status, including the authorisation, making it \nreally simple to include into a given app. One can even instantiate different wrappers to publish\ninto different servers at the same time.\n\n```python\nconnection_params = MastodonConnectionParams.from_dict({\n  "app_name": "SuperApp",\n  "instance_type": "mastodon",\n  "api_base_url": "https://mastodon.social",\n  "credentials": {\n    "user_file": "user.secret",\n    "client_file": "client.secret",\n    "user": {\n        "email": "bot@my-fancy.site",\n        "password": "SuperSecureP4ss",\n    }\n  }\n})\n\nmastodon_instance =  MastodonHelper.get_instance(\n  connection_params=connection_params\n)\n\nmastodon_instance.status_post(\n  status="I am a text"\n)\n```\n\n## The `MastodonPublisher` module\n\nA class that abstracts the process of publishing text and media into a Mastodon-like API.\n\nBenefits of using it:\n- Total encapsulation of `MastodonHelper` related work.\n- Facilitates methods to publish simple text, full `StatusPost` objects and media URLs or paths.\n- Retries with delay in case the communication is poor.\n- Slices the text so that it fits within the defined status maximum length\n- Proxies the posting through any of the supported instance types.\n- Supports the definition of a *dry run* so that execution can be tested without actual publishing\n- Supports parametrisation through `Config` objects\n\nHaving a `Config` like the following YAML:\n```yaml\npublisher:\n  media_storage: "storage/media/"\n  dry_run: False\n  named_account: test\nmastodon:\n  named_accounts:\n    test:\n      app_name: "Test"\n      api_base_url: "https://mastodon.social"\n      instance_type: "mastodon"\n      credentials:\n        client_file: "client_test.secret"\n        user_file: "user_test.secret"\n        user:\n          email: "test@my-fancy.site"\n          password: "SuperSecureP4ss"\n```\n\nPublishing is as simple as:\n```Python\nPublisher(config=Config()).publish_text("This is a test")\n```\n\n\n# How to use it\n\n1. Assuming you have `pip` installed:\n```\npip install pyxavi\n```\n\nYou can also add the `pyxavi` package as a dependency of your project in its `requirements.txt`\nor `pyproject.toml` file.\n\n2. Import the desired module in your code. For example, in your `my_python_script.py`:\n```python\nfrom pyxavi.debugger import dd\n\nfoo = [1, 2, 3]\ndd(foo)\n```\n\n\n# Give me an example\n\n0. First of all you have installed the package, right?\n```bash\npip install pyxavi\n```\n\n1. Create a yaml file with some params, for example the app\'s name and the logger. Let\'s call\nit `config.yaml`:\n```yaml\napp:\n    name: My app\n\nlogger:\n    name: "my_app"\n    file:\n      active: True\n```\n\n2. Create a python file called `test.py` and open it in your editor.\n\n2. Import the modules by adding these lines in the top of the script file:\n```python\nfrom pyxavi.config import Config\nfrom pyxavi.logger import Logger\n```\n\n3. Now just add the following lines to instantiate the config and the logger using the config.\n```python\nconfig = Config()\nlogger = Logger(config).get_logger()\n```\nThis will give you a `config` object with the parameters in the config file, and a `logger`\nobject ready to log events using the built-in interface.\n\n4. Simply use the objects!\n```python\napp_name = config.get("app.name", "Default app\'s name")\nlogger.info(f"The config file says the app\'s name is {app_name}")\n```\n\nLet\'s see it all together, and extend it a bit more:\n\n```python\nfrom pyxavi.config import Config\nfrom pyxavi.logger import Logger\nfrom pyxavi.debugger import dd\n\nconfig = Config()\nlogger = Logger(config).get_logger()\n\napp_name = config.get("app.name", "Default app\'s name")\nlogger.info(f"The config file says the app\'s name is {app_name}")\n\nlogger.debug("Inspecting the config object")\ndd(config)\n```\n\nNow, when it runs it should give the following output:\n```bash\n$ python test.py\n(Config){\n  "_filename": (str[11])"config.yaml",\n  "_content": (dict[2]){\n    "app": (dict[1]){"name": (str[6])"My app"},\n    "logger": (dict[2]){\n      "name": (str[6])"my_app",\n      "file": (dict[1]){"active": (bool)True}\n    }\n  },\n  "_separator": (str[1])".",\n  class methods: _Dictionary__recursive_set, _get_horizontally, _get_parent_horizontally, _is_int, _is_out_of_range, _load_file_contents, _merge_complex_recursive, _merge_simple_recursive, _remove_none_recursive, _set_horizontally, delete, get, get_all, get_hashed, get_keys_in, get_last_key, get_parent, get_parent_path, initialise_recursive, key_exists, merge, merge_from_dict, merge_from_file, needs_resolving, read_file, remove_none, reso\n```\n\n... and also create a `debug.log` file that contains the following content:\n```\n[2023-08-06 22:24:34,491] INFO     my_app       The config file says the app\'s name is My app\n```\n\nNote that the default `LOG_LEVEL` is 20, therefor the call `logger.debug` was not registered as\nit\'s level is 10.\n\n\n# ToDo\n- [ ] Documentation per module\n- [ ] Iterate inline documentation\n- [x] Empty the [NEXT MAJOR](./NEXT_MAJOR.md) list\n',
    'author': 'Xavier Arnaus',
    'author_email': 'xavi@arnaus.net',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/XaviArnaus/pyxavi',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
